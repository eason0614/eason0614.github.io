[{"content":"","date":"2025年7月10日","externalUrl":null,"permalink":"/daily-notes/","section":"Daily-Notes","summary":"","title":"Daily-Notes","type":"daily-notes"},{"content":"","date":"2025年7月10日","externalUrl":null,"permalink":"/tags/%E6%89%93%E5%B7%A5%E5%BA%A6%E5%81%87/","section":"Tags","summary":"","title":"打工度假","type":"tags"},{"content":"","date":"2025年7月10日","externalUrl":null,"permalink":"/categories/%E6%97%A5%E6%9C%AC%E7%94%9F%E6%B4%BB/","section":"Categories","summary":"","title":"日本生活","type":"categories"},{"content":" 前言 # 隨著打工度假的簽證的到期，回國前有一些手續需要處理，這邊做個記錄。\n1. 租屋解約 # 每個管理公司的合約不同，日本租屋通常簽訂的是二年契約，當初簽訂的契約同樣是二年約，但在租滿一年後解約不需付違約金，而且解約日需在一個月前向管理公司提出申請。\n承租物件負責的管理公司有App，可以線上提出申請。 提出解約申請後，管理公司會再打電話來確認實際要退房的日期與時間，並且需要在退房日前完成房屋清空、水電瓦斯解約。 2. 回國機票 # 解約日、退房日一確定下來就可以先訂回程的機票啦。 3. 租屋處清空 # 當初簽約時怎麼樣，離開也要是一樣的空屋狀態歸還。 比較麻煩的就是大型傢俱的處理，與無法直接丟棄的大型垃圾。\n大型傢俱的處理 : 找不用品回收業者來處理，很多業者雖然廣告狀況良好的傢俱買取、無料回收，但其實你東西本身不多，就算狀況保持的再好，不但買取回收很困難，甚至還不能無料回收，要額外付回收的費用。因為業者會出車載也是需要車馬費的。 無法直接丟棄的大型物件 : 購買大件垃圾處理券貼紙：在指定商店依照垃圾的種類、尺寸，購買正確金額的處理卷貼紙，通常超商會有賣。 聯絡居住區域的大型垃圾受理中心(粗大ゴミ受付センター)：可以網路線上預約或是電話預約，預約申請完成後，於預約好的時間，將貼好貼紙的大型垃圾放到指定地點即可。 到社群轉讓、出售 : 最後我選擇這個方式，雖然要花點時間個別聯絡約時間，考慮到只用1年東西狀況都還不錯，還能回收點錢回來。 最後終於把房子清空了，剩下行李箱裝不下的，用郵局海運的方式寄回台灣。 4. 水電瓦斯解約 # 建議是在確認好退房日期時，就提前去申請解約(遇到搬家尖峰期，日期可能會不好喬)，通常能透過網路預約、電話聯絡的方式申請解約。 身為I人的我當然是想透過網路預約的方式解決，無奈我遇到的狀況是大阪的水電瓦斯，網路解約都要必填搬家住址，而且限定日本住址，只好硬著頭皮打電話預約，最後還是順利聯絡好解約日，還好這一年日文沒白學。\n5. 房屋保險解約 # 這個其實很多人都會忘記去解約，其實放著不管時間一到保險契約也就失效了，在網路申請填一下資料就完成解約的申請了，最後還退了1/4的保費回來。\n6. 區役所 - 住民票轉出、年金健保退出 # 住民票轉出: 可以在要離開的14天前提出申請，到區役所直接跟櫃檯人員說要歸國，並填寫住民票轉出申請表就好了，依照指示填寫住址、轉出地寫上歸國的國家、預計歸國的日期，就完成了。\n年金退保: 接著就到年金櫃檯，因為國民年金已申請免除，就只剩下健康保險的部分要確認，當初寄來的繳費單還少最後二個月份的(應該4月份寄整年份的樣子，當初6月底入境只有收到8個月份的繳費單)，所以進行補繳的動作，繳完就結束了。\n7. 銀行帳戶解約 # 因為太晚才申請保險解約，需等待讓房屋退保的款項入帳(此時已經不在日本了)，所以我就只有把錢都領出來而已，沒有進行解約的動作。 但即使銀行帳戶裡的餘額清空，也不代表帳戶已經正式關閉，建議回國前還是親自前往日本的銀行櫃檯辦理銷戶。此外，若你的帳戶有綁定手機費、電費、水費、瓦斯費、網路費或信用卡等自動扣款，請務必等所有扣款都完成後再辦理解約，否則扣款失敗會被視為欠費，留下不良紀錄，未來在日本申辦信用卡、貸款時可能會受到影響。\n8. 手機門號解約 # 看各家電信的解約流程，樂天能透過App線上提出申請。 9. 退房日前幾天 # 因為水電瓦斯退房前二天就停了，加上傢俱都清空了，所以這幾天都是住附近的飯店。\n10. 退房日當天 # 當天管理公司就派人來，進行退房手續，檢查房屋狀況，因為房子狀況保持的很好，所以沒有被多收其他費用，只有被收當初合約上寫的退房清潔費。 11. 機場在留卡注銷 # 最後到機場入海關時，跟海關確認沒有要再入國後，就會將你的在留卡打洞做註銷。\n","date":"2025年7月10日","externalUrl":null,"permalink":"/daily-notes/japan-life/leaving-working-holiday/","section":"Daily-Notes","summary":"","title":"日本打工度假｜結束回國離開前的手續","type":"daily-notes"},{"content":" Day 1 # 大阪出發 - 商船三井さんふらわあ # 從大阪搭19:05的渡輪前往別府，搭船處就位在ATC HALL的隔壁，從大阪地鐵搭到貿易中心前站(トレードセンター前駅)下車就會到。\n這次是先上網預約，再現場付款，拿到一張票券，上面的QR Code就是房間的出入鑰匙。 登船前可以逛旁邊的貿易中心，也順便買在船上吃的東西。\n船舶介紹 # 這次因為前往別府，與上次搭乘的名門大洋フェリー不同家公司。\n船內大廳 個室 這次的房間的門雖然是可以鎖，但是拉門，沒有完全封閉，所以需要注意不要吵到隔壁房間。 明石海峽大橋 # Day 2 # 早餐 - 船上Buffet # 早餐還算蠻便宜的，就選擇在船上吃了，一邊欣賞窗外風景。 吃完早餐後，就下船前往附近公車站，開啟地獄溫泉巡禮。\n地獄溫泉巡禮 # 從最上面的海地獄開始逛起，買了地獄周遊套票，全部有七個點，每個地獄大概相隔幾百公尺，最後兩個比較遠需要搭公車。\n海地獄 # 鬼石坊主地獄 # かまど地獄 # 鬼山地獄 # 白池地獄 # 血の池地獄 # 搭乘巴士從鐵輪站搭到血の池地獄前站下車。\n這裡有紀念品店，入手了限定的鑰匙圈。 龍巻地獄 # 這裡地獄是間歇泉，一段時間會噴發。\n最後終於集滿七個地獄的印章，結束了地獄溫泉巡禮。 午餐 - Furari # 午餐選了附近的拉麵名店，點了招牌的豚骨醤油ラーメン，非常好吃湯頭蠻順口的。 湯けむり展望台 # 飯後就散步到附近的展望台，可惜沒有拍到煙霧的景色。 大分香りの博物館 # 然後就沿路下山走到，大分香水博物館，順便來吹冷氣避暑一下。 別府駅 # 結束後就來到別府車站，順便去附近的飯店放行李。 車站前有溫泉手湯 やよい天狗 # 接著就來附近的商店街，順路看看巨大天狗。 竹瓦溫泉 # 商店街走到底就會到，當地有名的竹瓦溫泉。 泡澡後來一瓶阿蘇牛奶！ 世界之塔(グローバルタワー) # 回飯店Check In 稍作休息後，來到世界之塔。\n上來都沒有人，包場了！ 晚餐 - 天丼 とよ常本店 # 晚餐在逛完車站附近的百貨後，選了一間評價不錯的天丼店，食材新鮮還不錯吃。 這裡有名的炸雞天婦羅，炸得很酥脆，裡面肉很軟嫩不乾柴。 Day 3 # 九州橫斷特急 # 隔天一早從別府到熊本，搭乘九州橫斷特急，大概3個半小時。 熊本駅 # 抵達熊本站已接近中午。 午餐 - 大漁食堂 HERO海 熊本駅店 # 午餐選在熊本車站附近吃，原本找了一間叫天外天的拉麵，但人太多了， 就另外找了一間壽司店，結果還蠻好吃的。\nAMU PLAZA 熊本 # 吃飽飯後就去旁邊的百貨走走，到處都看得到海賊王，不愧是尾田老師的故鄉。 在 Kiddy Land 入手了限定的鑰匙圈。 熊本城 # 接著來到熊本城。 走了一段路後就會到天守閣。 裡面非常現代化，還有冷氣。 晚餐 - 熊本ラーメン黒亭 下通店 # 來吃一下熊本當地有名的黑亭，這裡的特色是會有生蛋黃，吃到一半再加進去，有另一種風味。 晚餐 - 酒湊 SAKASOU # 與在熊本工作的朋友約在這裡見面，吃他推薦的居酒屋。\n第一次吃生馬肉，口感跟味道有點像咬不爛的鮪魚。 生魚片都蠻新鮮的。 熊本台積電 JASM # 接著他就開車載我到他上班的熊本台積電，經過看看外面就走了，沒辦法進去🤣 索隆銅像 # 附近有索隆銅像就順路來看看了，晚上沒開燈還蠻暗的。 阿蘇山-草千里 # 朋友聽到我白天沒去阿蘇山，就開車帶我上去看看了。 不過晚上其實蠻黑的，都看不到什麼東西。 稍微看一下就載我回飯店了，隔天他還要上班，真的很感謝他抽空帶我逛逛。\nDay 4 # 熊本熊廣場(くまモンスクエア) # 隔天一早來到熊本商店街附近走走，順路來看看熊本熊的店。 午餐 - お好み焼・鉄板焼 大文字 本店 # 午餐吃位在商店街內的御好燒，需要自己DIY親手做，旁邊有教學。 魯夫銅像 # 接著來看魯夫的銅像，就位在熊本縣廳的旁邊廣場。\n博多駅 # 下午原本預計是要到佐賀的，晚上要入住佐賀的飯店。 結果搭錯班次，搭到沒有停高速基山站轉車的班次，是直達博多的班次， 就將錯就錯來博多逛了，反正車錢是差不多的，福岡也比較多東西好吃。\n博多運河城 # 接著又來運河城逛。 晚餐 - 博多やきとり処 楽がき 中洲川端店 # 晚餐找了一間評價蠻高的燒鳥店，還蠻好吃的。\n佐賀駅 # 到佐賀車站已經是晚上9點多。 Day 5 # ゆめタウン佐賀 # 佐賀市區其實沒什麼景點，加上時間有限只有半天的就決定，逛一下附近的購物中心就好。 然後在這裡的NAMCO大開殺戒，鄉下的機台真的超級佛心！兩隻都500日幣內就入手了！\n午餐 - 佐賀牛レストラン 季楽 本店 # 都來到佐賀了，一定要吃的就是佐賀牛，找了一間名店，點了午間套餐。 鐵板溫度非常高，肉能煎到外脆內軟入口即化，就像和牛一樣非常油，煎完的油可以拿來炒青菜。\n佐賀駅 - えきマチ1丁目 # 接著在車站旁邊的紀念品店，入手限定的吊飾。 晚餐 - 博多らーめんShinShin 福岡PARCO店 # 接著就搭車到福岡了，下午在天神商店街附近逛逛， 沿路會經過福岡 PARCO，就順勢在這裡吃晚餐。 排了2個人就入場了，湯頭沒有太重的豬骨味，個人覺得比一蘭還好吃。 自製的辣油還蠻香的。 宵夜 - とりかわ博多かわっこ 薬院店 # 這次來福岡的目的，其中一個就是這裡的雞皮，捲成特殊的形狀烤起來會外脆內Q！ 找了一間飯店附近評價蠻高的雞皮店，果然沒讓人失望，非常好吃。\nDay 6 # ちいかわらんど 福岡パルコ店 # 這次吉伊卡哇剛好有新品，事先抽了早上福岡店入場的整理券，然後順便入手上次沒買到的限定鑰匙圈。\n午餐 - 博多もつ鍋おおやま 福岡パルコ店 # 午餐就順勢在福岡 PARCO吃了，找了間牛腸鍋，點了午間套餐。 味噌湯底，配上比較油的牛腸還蠻搭的。 ブルーボトルコーヒー 福岡天神カフェ # 下午就在天神商店街、警固公園附近走走，逛累了加上天氣炎熱，找間附近的藍瓶咖啡休息。 小倉駅 # 接近傍晚的時候前往小倉站，晚上入住小倉這邊的飯店。 福岡的住宿其實蠻貴的，想省預算隔天又預計前往北九州的話，住小倉這邊還不錯，價格便宜一半左右，從博多搭過來差不多1個小時。 晚餐 - 資さんうどん 魚町店 # 晚餐在小倉車站附近的，魚町銀天商店街逛逛，找了一間這裡有名的連鎖烏龍麵店來吃。 點了期間限定的穴子天婦羅烏龍冷麵套餐。 Day 7 # 下關 - 唐戶市場 # 隔天前往位於下關的唐戶市場，順便在這邊吃早午餐。 這天剛好是假日，人潮蠻多的。 因為沒吃過河豚，有點擔心不合胃口，就沒有點整盤的生魚片。 分別點了炸河豚跟壽司，來嚐鮮看看。\n在外面的用餐區，一邊欣賞`關門橋`的風景，一邊享用。 龜山八幡宮 # 吃飽來到魚市場旁邊的龜山八幡宮參拜。 赤間神宮 # 沿路一直走下去會走到赤間神宮。\n大連神社、紅石稲荷神社 # 沿著赤間神宮旁邊的階梯再往上走，會走到大連神社、紅石稲荷神社。\n魚町銀天街 # 下午就回到了小倉站這邊的商店街逛逛，因為6點就要搭前往渡輪港口的接駁車，沒有時間跑太遠的地方。\nぎょらん亭 魚町店 # 因為早午餐的壽司吃太飽，一直拖到了4點才吃飯，找了一間商店街附近評分還蠻高的拉麵店。 可以自己調整豚骨跟雞湯的比例。\n福岡とりかわ 焼とり権兵衛 小倉魚町店 # 因為太想念前天宵夜的雞皮，於是附近又再找了一間解解饞，味道還不錯但還是福岡的好吃。\n名門大洋フェリー # 晚上搭乘上次搭過的名門大洋的渡輪回大阪，從小倉站有免費的接駁車可以過去。\n上次拍過船上的設施，就沒有再多拍了，不過早上有出來拍明石海峽大橋，又是不一樣的景色。 最後渡輪就抵達大阪了，結束了這趟九州之旅。\n","date":"2025年6月24日","externalUrl":null,"permalink":"/daily-notes/japan-travel/kyushu-trip/","section":"Daily-Notes","summary":"","title":"九州｜別府、熊本、佐賀、福岡、小倉 七天六夜自由行","type":"daily-notes"},{"content":"","date":"2025年6月24日","externalUrl":null,"permalink":"/tags/%E7%86%8A%E6%9C%AC%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"熊本旅遊","type":"tags"},{"content":"","date":"2025年6月24日","externalUrl":null,"permalink":"/tags/%E4%BD%90%E8%B3%80%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"佐賀旅遊","type":"tags"},{"content":"","date":"2025年6月24日","externalUrl":null,"permalink":"/tags/%E5%A4%A7%E5%88%86%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"大分旅遊","type":"tags"},{"content":"","date":"2025年6月24日","externalUrl":null,"permalink":"/categories/%E6%97%A5%E5%B8%B8%E9%9A%A8%E8%A8%98/","section":"Categories","summary":"","title":"日常隨記","type":"categories"},{"content":"","date":"2025年6月24日","externalUrl":null,"permalink":"/categories/%E6%97%A5%E6%9C%AC%E6%97%85%E9%81%8A/","section":"Categories","summary":"","title":"日本旅遊","type":"categories"},{"content":"","date":"2025年6月24日","externalUrl":null,"permalink":"/tags/%E7%A6%8F%E5%B2%A1%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"福岡旅遊","type":"tags"},{"content":"","date":"2025年6月24日","externalUrl":null,"permalink":"/tags/%E5%8C%97%E4%B9%9D%E5%B7%9E%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"北九州旅遊","type":"tags"},{"content":"","date":"2025年6月9日","externalUrl":null,"permalink":"/tags/%E5%90%89%E4%BC%8A%E5%8D%A1%E5%93%87/","section":"Tags","summary":"","title":"吉伊卡哇","type":"tags"},{"content":"梅田目前有二間吉伊卡哇的店，都在梅田站附近，分別位在阪急三番街 B1、HEP FIVE B1。\nちいかわらんど 大阪梅田店 # 位在阪急三番街 B1，梅田站1、2號出口可以直接過去。 ナガノ老師對 Kiddy Land 梅田店 55週年的祝福，原來梅田這間開這麼久了！ 新出的餅卡！ まじかるちいかわストア 梅田HEPFIVE店 # 位在HEP FIVE B1。\n烏薩奇被那孩子虎視眈眈的看著。 結帳櫃檯笑死🤣 剛好有特典活動，拿到小八的魔法棒。 ","date":"2025年6月9日","externalUrl":null,"permalink":"/daily-notes/japan-life/osaka-umeda-chiikawa/","section":"Daily-Notes","summary":"","title":"大阪梅田 | 吉伊卡哇 Land、魔法少女 HEP FIVE 店","type":"daily-notes"},{"content":"","date":"2025年6月9日","externalUrl":null,"permalink":"/tags/%E5%8B%95%E6%BC%AB/","section":"Tags","summary":"","title":"動漫","type":"tags"},{"content":" 早餐 - 木津壽司 # 早上去木津市場看看有名的 魚市食堂有沒有機會吃到，無奈8點去已經要等上一個小時， 所以就吃隔壁的木津壽司，大概10分左右就排到， 點了干貝、鮭魚、鮪魚中腹的組合丼飯，生魚片跟干貝都很新鮮很好吃。\n交通 # 飽餐一頓後就到新今宮站，搭乘南海電鐵前往和歌山市，大概1小時左右會到。 和歌山市駅 # 抵達和歌山市車站，比我想像中還要大，原本以為是個小站。 和歌山城 # 因為早餐吃得有點好，想說要運動一下順便欣賞沿路風景，就用走的走到和歌山城，大概步行半小時左右。 結果到和歌山城公園還有一小鹿山路要走，有點小後悔🤣 紀三井寺 # 接著就到紀三井寺走走。 旁邊的仏殿二樓有個展望台，上面景色非常好可以看到整個和歌山市跟和歌山灣。\n午餐 - 井出商店 # 最後回到市區吃午餐，找了一間有名的拉麵店，湯底是醬油豚骨，豚骨豬味蠻重的。 因為下午2點多才吃午餐，和歌山其他景點還要再往下，也要花不少時間，所以車站附近稍微逛一下 就回去了。\n","date":"2025年6月3日","externalUrl":null,"permalink":"/daily-notes/japan-travel/osaka-wakayama-trip/","section":"Daily-Notes","summary":"","title":"大阪 | 和歌山一日遊","type":"daily-notes"},{"content":"","date":"2025年6月3日","externalUrl":null,"permalink":"/tags/%E5%A4%A7%E9%98%AA%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"大阪旅遊","type":"tags"},{"content":" 交通 # 從大阪難波搭近鐵特急，有直達的電車，大概2個鐘頭會到伊勢車站。 伊勢神宮(外宮) # 就在伊勢車站的附近，走路10分鐘內就會到。 宮內禁止拍攝，只有鳥居跟外圍的照片。 伊勢內宮前 托福橫丁 # 接著就搭巴士前往，伊勢神宮前的商店街，由於太早到，店家大部分都尚未開門，沿路商店都是木造建築，別有風味。\n赤福 本店 # 赤福的本店就位於此處，早上人潮還不算多。 五十鈴川咖啡 # 參拜伊勢神宮參拜後，在咖啡廳享用早餐並稍作休息，一邊欣賞窗外的景色。 山村みるくがっこう 内宮前店 # 這裡有名的霜淇淋布丁店，濃厚的牛奶味蠻好吃的。 還入手了伊勢的限定吊飾 伊勢神宮 內宮 # 因為宮內禁止拍攝，只有拍攝進入神宮前跟外圍的照片。 猿田彥神社 # 午餐前的空檔前往猿田彥神社進行參拜。 午餐 - ゑびや大食堂 # 午餐找了一間評分不錯的餐廳，點了お伊勢さんのご馳走定食什麼都能吃到的套餐定食。 海鮮都算新鮮還不錯，覺得最好吃的是神戶牛的壽司。 二見興玉神社 # 下午前往二見興玉神社進行參拜，看一下有名的夫婦岩。\n伊勢觀光列車 # 回程搭乘伊勢觀光列車回大阪，票價比一般列車貴了800日幣。 觀光列車進站。\n紀念乘車證。 椅子也是比一般列車高級的沙發椅。 另一個看點是，車上有餐廳，可以一邊享用晚餐，一邊欣賞透明窗戶外的風景。 點了神戶牛咖哩飯，都只有小肉塊，味道偏鹹有點普通。 就這樣搭乘觀光列車回大阪，結束了一日三重伊勢之旅。\n","date":"2025年5月29日","externalUrl":null,"permalink":"/daily-notes/japan-travel/mie-ise-trip/","section":"Daily-Notes","summary":"","title":"三重 | 伊勢一日遊","type":"daily-notes"},{"content":"","date":"2025年5月29日","externalUrl":null,"permalink":"/tags/%E4%B8%89%E9%87%8D%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"三重旅遊","type":"tags"},{"content":"","date":"2025年4月3日","externalUrl":null,"permalink":"/tags/docker/","section":"Tags","summary":"","title":"Docker","type":"tags"},{"content":" Docker 常用指令 # 1. 拉取映像檔 # 要從 Docker Registry 中下載映像檔，可以使用以下指令：\ndocker pull [image name]:[image tag] 例如，下載最新版本的 nginx：\ndocker pull nginx 2. 創建並運行容器 # 使用映像檔創建並運行一個新的容器：\ndocker run [OPTIONS] [image name]:[image tag] 例如，運行一個 hello-world 容器：\ndocker run hello-world 3. 查看容器狀態 # 查看所有容器的運行狀態：\ndocker ps -a 4. 進入運行中的容器 # 對正在運行的容器下達指令，或進入容器：\n`docker exec -it [container id] /bin/bash` 5. 查看容器日誌 # 查看容器輸出的日誌：\n`docker logs [container id]` 6. 查看容器詳細資訊 # 查看容器的詳細資訊：\n`docker inspect [container id]` 7. 刪除容器和映像檔 # 刪除某個容器：\n`docker rm [container id]` 刪除某個映像檔：\n`docker rmi [image id]` 8. 查看已下載的映像檔 # 查看目前已下載的映像檔：\n`docker images` 9. 設置容器網絡 # 配置容器的網絡設置可以使用以下指令：\n`docker network create [network name]` 創建一個新的網絡，然後可以將容器連接到該網絡：\n`docker network connect [network name] [container id]` 10. 管理數據卷 # 數據卷用於持久化容器數據，以下是一些常用的數據卷指令：\n創建數據卷：\n`docker volume create [volume name]` 將數據卷掛載到容器：\n`docker run -v [volume name]:[container path] [image name]` 11. 設置容器資源限制 # 在運行容器時，可以設置資源限制以控制容器的資源使用：\n限制 CPU 使用：\n`docker run --cpus=\u0026#34;1.5\u0026#34; [image name]` 限制內存使用：\n`docker run -m 512m [image name]` 這些指令可以幫助你更靈活地管理 Docker 容器的網絡、數據和資源使用。\n","date":"2025年4月3日","externalUrl":null,"permalink":"/tech-articles/backend/docker-command/","section":"技術文章","summary":"","title":"Docker 基本指令、操作","type":"tech-articles"},{"content":"","date":"2025年4月3日","externalUrl":null,"permalink":"/categories/%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/","section":"Categories","summary":"","title":"基本指令","type":"categories"},{"content":"","date":"2025年4月3日","externalUrl":null,"permalink":"/categories/%E5%BE%8C%E7%AB%AF%E9%96%8B%E7%99%BC/","section":"Categories","summary":"","title":"後端開發","type":"categories"},{"content":" Day 1 # 新幹線 # 從大阪搭乘新幹線大概一個半小時就會到廣島。 廣島城 # 抵達廣島站後，轉乘巴士前往廣島城，\n從大鳥居(廣島護國神社)前往裏御門跡，往廣島天守閣的方向前進。 廣島護國神社 # 從表御門回去的沿路會經過廣島護國神社。 午餐 - 広島牡蠣と和牛ラーメン 衝青天 # 午餐找了一間評價還不錯的拉麵．點了和牛拉麵再加點單品牡蠣。 鹽系的湯底，搭配牛肉還不錯吃，牡蠣不愧是產地又大顆又鮮甜。 廣島 PARCO # 下午吃飽後去 PARCO 附近逛逛，看一下有沒有廣島限定的周邊。\nちいかわらんど 広島パルコ店 剛好是復活節蛋周邊發售的期間，人還蠻多的，這個系列只剩吉伊了。 有跟`廣島鯉魚隊`合作的周邊，轉了幾顆扭蛋。 晚餐 - お好み焼き 紀乃国屋ぶんちゃん # 在飯店Check In 完放好行李後，到附近找了一間廣島燒餐廳。 味道還不錯，份量還蠻大的，跟大阪燒比起來菜量比較偏多，麵皮跟蛋比較分離。 因為是產地，又單點了牡蠣。 廣島駅 # 吃飽飯後，就在廣島車站周圍的購物中心逛逛。 Day 2 # 從廣島駅，搭乘 JR 從宮島口站下車，之後再轉前往宮島的船，跟JR一樣直接刷閘口就能進站。\n宮島桟橋 # 船抵達宮島桟橋後，就往宮島商店街的方向走。 宮島商店街 # 這裡賣很多當地的特產周邊、特色小吃， 午餐 - 牡蠣屋 # 我們也在這邊找了一間評價還不錯的牡蠣料理，產地新鮮不用說， 點了牡蠣套餐有好幾種吃法，最好吃的還是烤牡蠣，最能吃到牡蠣本身的味道。 揚げもみじの紅葉堂 本店 # 這裡有名的炸楓葉饅頭，裡面有包餡，點了期間限定的起司火腿還不錯。 だいこん屋 # 被旁邊店家的招牌吸引到，還點了的楓葉饅頭冰淇淋來吃。 宮島咖喱麵包研究所 # 從嚴島神社回去的路上又點了咖哩麵包來吃，炸的麵包體裡面包咖哩跟牡蠣，意外還蠻搭的。 cafe Miyaji # 下午逛到腳有點酸，到一間人不多的咖啡廳稍作休息。 嚴島神社 # 這裡為了拍到白天跟黃昏二種版本的宮島神社，我們吃完午餐就先去一路走到神社那邊， 然後再回去商店街跟其他地方逛，最後快黃昏的時候再過來。\n黃昏的時候陽光灑在海面上，又是另一種不同的樣貌。\n其實周圍的海灘就拍得到嚴島神社，但想說都來了就進去本殿看一下。 宮島纜車 # 下午前往宮島纜車，沿路上會經過紅葉谷公園，這裡會看到蠻多鹿，這裡的鹿比奈良溫馴多了🤣\n之後就一路搭乘纜車，往獅子岩展望台前進。\n獅子岩展望台 # 纜車終點是獅子岩展望台，這裡可以看到廣島灣與宮島周邊的島嶼景色，不過可惜當天的天氣不是說太好。\n晚餐 - 焼肉ふるさと 広島駅前店 # 晚餐吃廣島車站附近的燒肉，就是中規中矩的好吃，價格也還行的燒肉店。 最後就同樣搭乘新幹線回大阪了，結束了這趟廣島之旅。\n","date":"2025年3月25日","externalUrl":null,"permalink":"/daily-notes/japan-travel/hiroshima-trip/","section":"Daily-Notes","summary":"","title":"廣島、宮島 | 二天一夜自由行","type":"daily-notes"},{"content":"","date":"2025年3月25日","externalUrl":null,"permalink":"/tags/%E5%BB%A3%E5%B3%B6%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"廣島旅遊","type":"tags"},{"content":"","date":"2025年3月21日","externalUrl":null,"permalink":"/tags/mlb%E6%9D%B1%E4%BA%AC%E6%B5%B7%E5%A4%96%E9%96%8B%E5%B9%95%E6%88%B0/","section":"Tags","summary":"","title":"MLB東京海外開幕戰","type":"tags"},{"content":"這次去東京最主要的目的就是MLB東京海外開幕戰跟順便逛吉伊卡哇東京店， 原本是先訂好票跟飯店，想說如果有搶到開幕賽的票可以順便去的。 無奈沒搶到開幕賽的門票，所以只能去物販跟展覽。\nDay1 # 新幹線 # 從大阪搭新幹線到到東京差不多二個半小時。 一到先去超商買早餐，這個時間哪裡都看得到大谷翔平。 新宿マルイメン店 # 一到先陪女友去位在新宿マルイメン火影快閃店。 ポケモンセンター 渋谷 # 涉谷的寶可夢中心就位在渋谷PARCO 6F 午餐 - 博多天ぷらたかお 渋谷パルコ店 # 午餐吃這間位在渋谷PARCO內的天婦羅，食材新鮮，非常酥脆好吃。 MIYASHITA PARK - MLB Tokyo Series Official Store # 接著就到東京系列賽的物販會場，不過想買的球員卡都沒了，沒買什麼就離開了。\n澀谷TSUTAYA - 大谷翔平シグネチャーコレクションの期間限定店 # 剛好看到期間限定的大谷翔平特展，免費入場而且不用排隊整理卷。 大谷的手比我大好多! 大谷用的護具。 雙刀流的大谷。 50-50紀念衣。 印有大谷養的狗デコビン圖案的鞋子。 晚餐 - 東京たらこスパゲティ 原宿表参道店 # 下午在涉谷逛完後，晚餐跑到原宿來吃，點了明太子麵來吃，味道還不錯。 ちいかわらんど 原宿店 # 接著到ちいかわ原宿店，入手東京限定的周邊。 Day2 # 早上打開電視，看到今天開球的來賓，竟然還是Twice的 Mina、Sana、Momo，真的好想去😭 MIYASHITA PARK # 到涉谷宮下公園附近逛，有展出球員卡的區域，填問卷可以免費抽一包。\n女友抽到大谷! 君のハンバーグを食べたい 渋谷店 # 午餐又來到涉谷吃，看到這間漢堡排名分很高就進來吃了，沒讓我失望，飯很Ｑ粒粒分明，漢堡排非常香。 還遇到台灣人店員，一開始用日文點餐，然後她也用日文回我們，雙方都以為對方是日本人。 後來聽到我們用中文聊天，主動來跟我們打招呼🤣 老闆日本人後來也來了，還跟我們秀了幾句中文🤣\n池袋 # 後來下午都在池袋逛，都是買逛街買東西的行程，就沒有拍照了，只有這張ちいかわ🤣 晚餐 - 鳥貴族 駒込店 # 晚餐吃飯店附近的鳥貴族，這間的品質還行。 Day3 # 東京スカイツリー MLB Tokyo Series Fan Fest # 第三天一早前往晴空塔，參觀 MLB Tokyo Series Fan Fest。\nポケモンセンタースカイツリータウン # 隔壁就是寶可夢中心晴空塔店。 ちいかわベーカリー # 早上的行程結束後，前往位在原宿的吉伊卡哇麵包店，需事先購票才能入場。 在 Lawson Ticket 上購買並抽選，如果中籤信用卡會刷下去。 裡面有一張1000元的購買卷，可以拿來買麵包或周邊。 到現場的時候蠻多東西都賣完了。 點完餐與挑好周邊後，就可以去結帳。\n代代木公園 # 接著就去代代木公園，三月中已經有一些櫻花開了。\n品嚐剛剛買的麵包，這樣拍起來好可愛，會捨不得吃掉🤣 晚餐 - AFURI 原宿 # 一樣點了柚子鹽拉麵，感覺味道沒有2年前來這麼好吃了。 原宿竹下通り # 吃飽後就到附近的竹下通逛逛。 Day4 # 第四天的行程都給了富士山了，一大早就去搭新宿站巴士站搭高速巴士。 因為要去富士急樂園，已先在富士急樂園官網上買好樂園＋巴士的套票。 富士山河口湖 # 因為買的富士急樂園套票是下午才入場，所以早上就先去河口湖拍富士山。 河口湖駅，之後再轉公車前往大石公園， 沿路會經有名的拍照景點 Lawson 富士河口湖町役場前店之前報導的黑幕已經拆掉了。 大石公園 # 到大石公園，可以拍到有河口湖的富士山。 富士急樂園 # 其實來富士急樂園主要是陪女友來這裡的火影忍者園區。\n午餐 一楽ラーメン # 午餐吃一樂拉麵。 摩天輪 # 摩天輪上面可以看到整個富士急樂園。 當然刺激的也可以看到，但女友不敢坐，而且排隊都要一小時以上，沒人陪我排就放棄了。 只好叫要她去果然沒辦法的牌子區罰站。 Day5 # 這天一早東京突然下了很大的三月雪，從飯店窗戶外都能感覺到有多大，不過還好中午前雪就停了。\n午餐 - 三崎豊魚 東武池袋店 # 午餐吃池袋車站附近的生魚片丼飯，點了サーモンいくらまぐろ丼，鮭魚跟鮪魚都蠻新鮮的不錯吃。 ポケモンセンタートウキョーDX # 然後又到了日本橋附近的寶可夢中心DX店。 日本橋 # 接著就到日本橋附近逛逛，真的哪裡都看得到大谷。 虎ノ門之丘 Glass Rock - 道奇體驗展 # 需事先上網購票，我們買的是チャンピオンパス(6600円) 可以拿冠軍戒指跟獎杯拍照。 螢幕播放介紹。 上一次奪冠是2021年的事了。 然後去年也奪冠了! Mookie 的金手套獎。 Kershaw 的 賽揚獎。 投影牆。 去年世界大賽 Game1 的活躍選手。 大谷專區。 大谷40/40盜壘紀念。 大谷57、58盜壘紀念。 道奇簽名牆。 跟冠軍獎盃、戒指的合照。 連送教練的車子都有🤣 Day6 # 池袋 サンシャインシティ - 火影快閃店 # 有一些吃的跟玩的設施，但都需要另外付費。 然後非常多中國代購仔在這裡，排隊動線也設計很差排非常久，時間都浪費在這裡。 物販周邊也很快就沒了，體驗非常糟糕。 午晚餐 - Shintori Komagome # 下午4點多，回飯店拿寄放的行李，準備去機場。 途中找了一間看起來評價還不錯居酒屋，東西也非常好吃。 成田機場 # 從成田機場，逛了一下伴手禮店就搭機回去了。 ","date":"2025年3月21日","externalUrl":null,"permalink":"/daily-notes/japan-travel/tokyo-trip/","section":"Daily-Notes","summary":"","title":"東京｜六天五夜自由行","type":"daily-notes"},{"content":"","date":"2025年3月21日","externalUrl":null,"permalink":"/tags/%E6%9D%B1%E4%BA%AC%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"東京旅遊","type":"tags"},{"content":"","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/","section":"Easonのブログ","summary":"","title":"Easonのブログ","type":"page"},{"content":"","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/tags/hashmap-problem/","section":"Tags","summary":"","title":"HashMap Problem","type":"tags"},{"content":"","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/tags/heap-problem/","section":"Tags","summary":"","title":"Heap Problem","type":"tags"},{"content":"","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/tags/java/","section":"Tags","summary":"","title":"Java","type":"tags"},{"content":"","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/categories/leetcode/","section":"Categories","summary":"","title":"Leetcode","type":"categories"},{"content":" 問題 # leetcode 1 - 2つの数の和 (問題の詳細はリンクをクリック)\n例題 # Example 1:\nInput: nums = [2, 7, 11, 15], target = 9 Output: [0, 1] Example 2:\nInput: nums = [3, 2, 4], target = 6 Output: [1, 2] 解法のアプローチ # この問題では、配列内で2つの数字を見つけ、その和が与えられた target と等しくなる場合、それらのインデックスを返すことが求められます。これは典型的な ハッシュマップ（HashMap） の問題で、ハッシュマップを使用することで効率的に解決でき、時間計算量は O(n) となります。\n解法 # ハッシュマップを使用して各数字のインデックスを保存し、配列の各要素を走査する際に、target - nums[i] が既に出現した数字と等しくなるかを確認します。もし存在する場合、その2つの数字のインデックスを返します。\n具体的な手順は以下の通りです：\n空のハッシュマップ map を初期化し、数字の値とインデックスを保存します。 配列 nums を走査し、各要素 nums[i] に対して target - nums[i] を計算し、ハッシュマップにその差が存在するか確認します。 存在する場合、その2つの数字のインデックスを返します。 存在しない場合、現在の数字とそのインデックスをハッシュマップに追加します。 例の説明：nums = [2, 7, 11, 15], target = 9 # 初期状態：map = {}、target = 9、nums の各要素を走査します。 最初の数字 2 の処理：\ntarget - 2 = 9 - 2 = 7 を計算します。 ハッシュマップ map に 7 は存在しないので、2 とそのインデックス 0 をハッシュマップに保存します：map = {2: 0}。 2番目の数字 7 の処理：\ntarget - 7 = 9 - 7 = 2 を計算します。 ハッシュマップ map に 2 が存在するので、map.get(2) と現在のインデックス 1 を返します：[0, 1]。 したがって、答えは [0, 1] となり、これは nums[0] + nums[1] = 9 を意味します。\n完全なコード # import java.util.Map; import java.util.HashMap; class Solution { public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // ハッシュマップを初期化して数字とインデックスを保存 for (int i = 0; i \u0026lt; nums.length; i++) { // 配列を走査 if (map.containsKey(target - nums[i])) { // ハッシュマップに目標値との差が存在するか確認 return new int[] { map.get(target - nums[i]), i }; // 存在する場合、インデックスを返す } else { map.put(nums[i], i); // 存在しない場合、現在の数字とインデックスをハッシュマップに追加 } } return new int[2]; // 空の配列を返す（理論的にはここには到達しない） } } ","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/posts/leetcode/easy/leetcode1/","section":"Posts","summary":"","title":"leetcode 1 - 2つの数の和","type":"posts"},{"content":" 題目 # leetcode 1 - Two Sum (題目說明請點連結)\n範例 # Example 1:\nInput: nums = [2, 7, 11, 15], target = 9 Output: [0, 1] Example 2:\nInput: nums = [3, 2, 4], target = 6 Output: [1, 2] 解題思路 # 這題要求我們在數組中找到兩個數字，這兩個數字的和等於給定的 target，並返回它們的索引。這是經典的 哈希表（HashMap） 問題，可以利用哈希表高效地解決，時間複雜度為 O(n)。\n解法 # 我們可以使用哈希表來存儲每個數字的索引，當我們遍歷數組中的每一個數字時，檢查是否存在一個數字，使得 target - nums[i] 等於某個已經出現過的數字。如果存在，就直接返回這兩個數字的索引。\n具體步驟如下：\n初始化一個空的哈希表 map，用來存儲數字的值和索引。 遍歷數組 nums，對於每個元素 nums[i]，計算 target - nums[i]，並檢查哈希表中是否存在這個差值。 如果存在，則返回這兩個數字的索引。 如果不存在，則將當前數字及其索引放入哈希表中。 例子說明：nums = [2, 7, 11, 15], target = 9 # 初始情況：map = {}，target = 9，我們從 nums 中遍歷每一個數字。 處理第一個數字 2：\n計算 target - 2 = 9 - 2 = 7。 哈希表 map 中沒有 7，所以把 2 和它的索引 0 存入哈希表，map = {2: 0}。 處理第二個數字 7：\n計算 target - 7 = 9 - 7 = 2。 哈希表 map 中有 2，所以返回 map.get(2) 和當前索引 1，即返回 [0, 1]。 所以答案是 [0, 1]，表示 nums[0] + nums[1] = 9。\n完整程式碼 # import java.util.Map; import java.util.HashMap; class Solution { public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 初始化一個哈希表來存儲數字和索引 for (int i = 0; i \u0026lt; nums.length; i++) { // 遍歷數組 if (map.containsKey(target - nums[i])) { // 檢查哈希表中是否存在目標數字的差值 return new int[] { map.get(target - nums[i]), i }; // 如果存在，返回索引 } else { map.put(nums[i], i); // 如果不存在，將當前數字和索引存入哈希表 } } return new int[2]; // 返回空數組（理論上不會到這一步） } } ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/easy/leetcode1/","section":"技術文章","summary":"","title":"leetcode 1 - Two Sum","type":"tech-articles"},{"content":" 問題 # leetcode 20 - Valid Parentheses (問題の詳細はリンクをクリック)\n例題 # Example 1:\nInput: s = \u0026ldquo;()\u0026rdquo; Output: true Example 2:\nInput: s = \u0026ldquo;()[]{}\u0026rdquo; Output: true Example 3:\nInput: s = \u0026ldquo;(]\u0026rdquo; Output: false 解法のアプローチ # この問題は括弧のペアが正しく対応しているか、また順序が正しいかを確認することが求められます。有効な括弧は以下の条件を満たす必要があります：\n括弧の種類は3つのみ：()、[]、{} 各開き括弧には対応する閉じ括弧が必要で、順序も正しくなければなりません すべての括弧が正しく対応している場合は true、そうでない場合は false を返します この問題は スタック（Stack） を使用して解決できます。スタックは後入れ先出し（LIFO）の構造を持ち、ネストされた構造の処理に適しています。\n解法 # 文字列の各文字を走査します： 開き括弧 (、[、{ の場合、スタックにプッシュします 閉じ括弧 )、]、} の場合、スタックの一番上が対応する開き括弧かを確認し、そうであればポップします 対応する開き括弧でない場合、またはスタックが空の場合は false を返します 走査終了後、スタックが空であれば（すべての括弧が対応している）true、そうでなければ false を返します 完全なコード # import java.util.Stack; class Solution { public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (c == \u0026#39;(\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;{\u0026#39;) { stack.push(c); } else if (!stack.isEmpty() \u0026amp;\u0026amp; c == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; stack.peek() == \u0026#39;(\u0026#39;) { stack.pop(); } else if (!stack.isEmpty() \u0026amp;\u0026amp; c == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; stack.peek() == \u0026#39;[\u0026#39;) { stack.pop(); } else if (!stack.isEmpty() \u0026amp;\u0026amp; c == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; stack.peek() == \u0026#39;{\u0026#39;) { stack.pop(); } else { return false; } } return stack.isEmpty(); } } ","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/posts/leetcode/easy/leetcode20/","section":"Posts","summary":"","title":"leetcode 20 - Valid Parentheses","type":"posts"},{"content":" 題目 # leetcode 20 - Valid Parentheses (題目說明請點連結)\n範例 # Example 1:\nInput: s = \u0026ldquo;()\u0026rdquo; Output: true Example 2:\nInput: s = \u0026ldquo;()[]{}\u0026rdquo; Output: true Example 3:\nInput: s = \u0026ldquo;(]\u0026rdquo; Output: false 解題思路 # 題目要求檢查括號是否成對匹配並且順序正確。有效的括號必須滿足以下條件：\n只有三種括號類型：()，[]，{}。 每個開括號都必須有對應的閉括號，並且順序必須正確。 如果所有括號都正確匹配，則返回 true，否則返回 false。 這個問題可以使用 Stack（堆疊） 來解決，因為堆疊是後進先出的結構，適合處理嵌套的結構。\n解法 # 遍歷字串中的每個字元： 如果是開括號 (、[、{，則壓入堆疊。 如果是閉括號 )、]、}，則檢查堆疊頂端是否是對應的開括號，如果是則彈出。 如果不是對應的開括號或堆疊為空，則返回 false。 遍歷結束後，檢查堆疊是否為空，若為空則表示所有括號匹配，返回 true，否則返回 false。 完整程式碼 # import java.util.Stack; class Solution { public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); if (c == \u0026#39;(\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;{\u0026#39;) { stack.push(c); } else if (!stack.isEmpty() \u0026amp;\u0026amp; c == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; stack.peek() == \u0026#39;(\u0026#39;) { stack.pop(); } else if (!stack.isEmpty() \u0026amp;\u0026amp; c == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; stack.peek() == \u0026#39;[\u0026#39;) { stack.pop(); } else if (!stack.isEmpty() \u0026amp;\u0026amp; c == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; stack.peek() == \u0026#39;{\u0026#39;) { stack.pop(); } else { return false; } } return stack.isEmpty(); } } ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/easy/leetcode20/","section":"技術文章","summary":"","title":"leetcode 20 - Valid Parentheses","type":"tech-articles"},{"content":" 問題 # leetcode 215 - Kth Largest Element in an Array (問題の詳細はリンクをクリックしてください)\n例題 # 例1:\n入力: nums = [3,2,1,5,6,4], k = 2 出力: 5 例2:\n入力: nums = [3,2,3,1,2,4,5,5,6], k = 4 出力: 4 解法 # この問題は配列内のk番目に大きい要素を見つけることが求められます。この問題を解決するために、以下の2つの一般的な方法があります：\nソート法：配列をソートし、k番目に大きい要素を選択します。 ヒープ法：最小ヒープ（Min-Heap）を使用して解決します。ヒープには常にk個の最大要素を保持し、最小ヒープのルート要素がk番目に大きい要素となります。 ここでは、より効率的な時間複雑度を達成できる最小ヒープを使用する方法を選択します。具体的な手順は以下の通りです：\nアプローチ # 最小ヒープ（Min-Heap）を初期化します。 配列の各要素に対して： ヒープのサイズがkより小さい場合、現在の要素をヒープに追加します。 ヒープのサイズがkに達し、かつ現在の要素がヒープの最小要素（ルート要素）より大きい場合、ヒープの最小要素を削除し、現在の要素を追加します。 すべての要素を処理した後、ヒープの最小要素がk番目に大きい要素となります。 この方法により、O(n log k)の時間複雑度でk番目に大きい要素を見つけることができます。\n完全なコード # import java.util.PriorityQueue; class Solution { public int findKthLargest(int[] nums, int k) { PriorityQueue\u0026lt;Integer\u0026gt; heap = new PriorityQueue\u0026lt;\u0026gt;(); // 配列の各要素を処理 for (int num : nums) { // ヒープのサイズがkより小さい場合、または要素がヒープの最小値以上の場合 if (heap.size() \u0026lt; k || heap.peek() \u0026lt;= num) { heap.offer(num); } // ヒープのサイズがkを超えた場合、最小要素を削除 if (heap.size() \u0026gt; k) { heap.poll(); } } // ヒープの最小要素を返す（k番目に大きい要素） return heap.peek(); } } ","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/posts/leetcode/medium/leetcode215/","section":"Posts","summary":"","title":"leetcode 215 - Kth Largest Element in an Array","type":"posts"},{"content":" 題目 # leetcode 215 - Kth Largest Element in an Array (題目說明請點連結)\n範例 # Example 1:\nInput: nums = [3,2,1,5,6,4], k = 2 Output: 5 Example 2:\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 解題思路 # 題目要求找到數組中第 k 大的元素。可以使用多種方法來解決此問題，常見的解法有以下兩種：\n排序法：將數組排序，然後選擇第 k 大的元素。 堆法：使用最小堆（Min-Heap）來解決，堆中始終保持 k 個最大元素，最小堆的根元素即為第 k 大的元素。 在這裡，我們選擇使用 最小堆，因為這樣可以達到更高效的時間複雜度。具體步驟如下：\n解法 # 初始化一個最小堆（Min-Heap）。 遍歷數組中的每個元素： 如果堆的大小小於 k，將當前元素加入堆中。 如果堆的大小達到 k，並且當前元素大於堆頂元素（最小值），則將堆頂元素移除並將當前元素加入堆中。 當所有元素遍歷完成後，堆頂元素即為第 k 大的元素。 這樣我們就能在 O(n log k) 的時間複雜度內找到第 k 大的元素。\n完整程式碼 # import java.util.PriorityQueue; class Solution { public int findKthLargest(int[] nums, int k) { PriorityQueue\u0026lt;Integer\u0026gt; heap = new PriorityQueue\u0026lt;\u0026gt;(); // 遍歷數組中的每個元素 for (int num : nums) { // 如果堆的大小小於 k，直接插入元素 if (heap.size() \u0026lt; k || heap.peek() \u0026lt;= num) { heap.offer(num); } // 如果堆的大小超過 k，移除堆頂最小元素 if (heap.size() \u0026gt; k) { heap.poll(); } } // 返回堆頂元素，即為第 k 大的元素 return heap.peek(); } } ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode215/","section":"技術文章","summary":"","title":"leetcode 215 - Kth Largest Element in an Array","type":"tech-articles"},{"content":" 問題 # leetcode 23 - Merge k Sorted Lists (問題の詳細はリンクをクリックしてください)\n例題 # 例1:\n入力: lists = [[1,4,5],[1,3,4],[2,6]] 出力: [1,1,2,3,4,4,5,6] 例2:\n入力: lists = [] 出力: [] 解法 # この問題は、k個のソート済みリンクドリストを1つのソート済みリンクドリストにマージすることが求められます。**最小ヒープ（Min-Heap）**を使用して解くことができます。最小ヒープは各ステップで最小の要素を選択するのに役立ちます。\nアプローチ # 最小ヒープを使用して、各リンクドリストの先頭ノードをヒープに追加します。 ヒープから最小の要素を取り出し、そのノードの次のノードをヒープに追加します。 ヒープが空になるまでステップ2を繰り返し、最終的にマージされたソート済みリンクドリストを得ます。 完全なコード # import java.util.PriorityQueue; class Solution { public ListNode mergeKLists(ListNode[] lists) { PriorityQueue\u0026lt;ListNode\u0026gt; heap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a.val - b.val); // 各リンクドリストの先頭ノードをヒープに追加 for (ListNode list : lists) { if (list != null) { heap.offer(list); } } ListNode res = new ListNode(0); ListNode cur = res; // すべてのリンクドリストをマージ while (!heap.isEmpty()) { ListNode node = heap.poll(); cur.next = node; cur = cur.next; // 現在のノードに次のノードがある場合、ヒープに追加 if (node.next != null) { heap.offer(node.next); } } return res.next; } } ","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/posts/leetcode/hard/leetcode23/","section":"Posts","summary":"","title":"leetcode 23 - Merge k Sorted Lists","type":"posts"},{"content":" 題目 # leetcode 23 - Merge k Sorted Lists (題目說明請點連結)\n範例 # Example 1:\nInput: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Example 2:\nInput: lists = [] Output: [] 解題思路 # 題目要求將 k 個已經排序的鏈表合併成一個排序的鏈表。可以使用 最小堆（Min-Heap） 來解決，因為最小堆可以幫助我們在每一步選擇當前最小的元素。\n解法 # 使用最小堆將每個鏈表的頭結點加入堆中。 從堆中取出最小的元素，並將該元素的下一個節點加入堆中。 重複步驟2直到堆為空，最終得到合併後的排序鏈表。 完整程式碼 # import java.util.PriorityQueue; class Solution { public ListNode mergeKLists(ListNode[] lists) { PriorityQueue\u0026lt;ListNode\u0026gt; heap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a.val - b.val); // 將每個鏈表的頭節點加入堆中 for (ListNode list : lists) { if (list != null) { heap.offer(list); } } ListNode res = new ListNode(0); ListNode cur = res; // 合併所有鏈表 while (!heap.isEmpty()) { ListNode node = heap.poll(); cur.next = node; cur = cur.next; // 如果當前節點有下一個節點，則將其加入堆中 if (node.next != null) { heap.offer(node.next); } } return res.next; } } ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/hard/leetcode23/","section":"技術文章","summary":"","title":"leetcode 23 - Merge k Sorted Lists","type":"tech-articles"},{"content":" 問題 # leetcode 394 - Decode String (問題の詳細はリンクをクリックしてください)\n例題 # 例1:\n入力: s = \u0026ldquo;3[a]2[bc]\u0026rdquo; 出力: \u0026ldquo;aaabcbc\u0026rdquo; 例2:\n入力: s = \u0026ldquo;3[a2[c]]\u0026rdquo; 出力: \u0026ldquo;accaccacc\u0026rdquo; 例3:\n入力: s = \u0026ldquo;2[abc]3[cd]ef\u0026rdquo; 出力: \u0026ldquo;abcabccdcdcdef\u0026rdquo; 解法 # この問題は、ネストされた形式の文字列をデコードすることが求められます。例えば、3[a2[c]]はaccaccaccに展開する必要があります。\n解法：スタック（Stack）を使用して展開プロセスをシミュレート\n数字の処理：数字に遭遇した場合、その値を累積し、後続の文字列を繰り返す回数として使用します。 左括弧 [：[に遭遇した場合、現在の数字と解析済みの文字列をスタックにプッシュし、新しい部分文字列の処理を開始します。 右括弧 ]：]に遭遇した場合、スタックから数字と以前の文字列を取り出し、現在処理中の部分文字列を指定回数繰り返して追加します。 文字の処理：通常の文字の場合は、直接現在の文字列に追加します。 この方法により、3[a2[c]]のような多層のネスト構造を処理することができます。\n完全なコード # import java.util.Stack; class Solution { public String decodeString(String s) { StringBuilder sb = new StringBuilder(); Stack\u0026lt;Integer\u0026gt; stNum = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;StringBuilder\u0026gt; stStr = new Stack\u0026lt;\u0026gt;(); int n = 0; for (int i = 0; i \u0026lt; s.length(); i++) { if (Character.isDigit(s.charAt(i))) { n = n * 10 + (s.charAt(i) - \u0026#39;0\u0026#39;); } else if (s.charAt(i) == \u0026#39;[\u0026#39;) { stNum.push(n); n = 0; stStr.push(sb); sb = new StringBuilder(); } else if (s.charAt(i) == \u0026#39;]\u0026#39;) { int cnt = stNum.pop(); StringBuilder temp = sb; sb = stStr.pop(); while (cnt-- \u0026gt; 0) { sb.append(temp); } } else { sb.append(s.charAt(i)); } } return sb.toString(); } } ","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/posts/leetcode/medium/leetcode394/","section":"Posts","summary":"","title":"leetcode 394 - Decode String","type":"posts"},{"content":" 題目 # leetcode 394 - Decode String (題目說明請點連結)\n範例 # Example 1:\nInput: s = \u0026ldquo;3[a]2[bc]\u0026rdquo; Output: \u0026ldquo;aaabcbc\u0026rdquo; Example 2:\nInput: s = \u0026ldquo;3[a2[c]]\u0026rdquo; Output: \u0026ldquo;accaccacc\u0026rdquo; Example 3:\nInput: s = \u0026ldquo;2[abc]3[cd]ef\u0026rdquo; Output: \u0026ldquo;abcabccdcdcdef\u0026rdquo; 解題思路 # 這題要求解碼嵌套格式的字串，例如 3[a2[c]] 需要展開成 accaccacc。\n解法：使用堆疊（Stack）模擬展開過程\n數字處理：當遇到數字時，累計數字值，表示接下來的字串需要重複的次數。 左括號 [：遇到 [ 時，將當前數字與已解析的字串推入堆疊，開始處理新的子字串。 右括號 ]：遇到 ] 時，從堆疊中取出數字與之前的字串，將當前處理的子字串重複相應次數後加回。 字母處理：如果是普通字母，則直接加入當前字串。 這種方法確保能夠處理多層嵌套結構，例如 3[a2[c]]。\n完整程式碼 # import java.util.Stack; class Solution { public String decodeString(String s) { StringBuilder sb = new StringBuilder(); Stack\u0026lt;Integer\u0026gt; stNum = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;StringBuilder\u0026gt; stStr = new Stack\u0026lt;\u0026gt;(); int n = 0; for (int i = 0; i \u0026lt; s.length(); i++) { if (Character.isDigit(s.charAt(i))) { n = n * 10 + (s.charAt(i) - \u0026#39;0\u0026#39;); } else if (s.charAt(i) == \u0026#39;[\u0026#39;) { stNum.push(n); n = 0; stStr.push(sb); sb = new StringBuilder(); } else if (s.charAt(i) == \u0026#39;]\u0026#39;) { int cnt = stNum.pop(); StringBuilder temp = sb; sb = stStr.pop(); while (cnt-- \u0026gt; 0) { sb.append(temp); } } else { sb.append(s.charAt(i)); } } return sb.toString(); } } ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode394/","section":"技術文章","summary":"","title":"leetcode 394 - Decode String","type":"tech-articles"},{"content":" 問題 # leetcode 560 - Subarray Sum Equals K (問題の詳細はリンクをクリックしてください)\n例題 # 例1:\n入力: nums = [1, 1, 1], k = 2 出力: 2 例2:\n入力: nums = [1, 2, 3], k = 3 出力: 2 解法 # この問題は、配列内で和がkとなる部分配列の個数を求めます。累積和とハッシュマップを使用して効率的に解くことができ、時間複雑度はO(n)となります。\n累積和とハッシュマップとは # **累積和（Prefix Sum）**は、配列の先頭から各位置までの要素の和を計算したものです。任意の部分配列[i, j]の和はsum[j] - sum[i-1]で求められます。ここでsum[i-1]は先頭からi-1番目までの和を表します。\n目標は和がkとなる部分配列を見つけることです。各要素を累積していく際に、ハッシュマップでtotal - kが存在するかを確認します。存在する場合、その位置から現在の位置までの部分配列の和がkとなります。\nアプローチ # 各要素を累積し、現在の合計を記録します。そして、ハッシュマップでtotal - kが存在するかを確認し、存在する場合はその回数を結果に加算します。\n配列の先頭からの部分配列も考慮するため、ハッシュマップをmap = {0: 1}で初期化します。これにより、total = kの場合に直接結果に1を加算できます。\n例：nums = [3, 4, 7, 2, -3, 1, 4, 2], k = 7の場合 # 初期状態：map = {0: 1}, total = 0, result = 0 3を処理：\ntotal = 3 3 - 7 = -4を探索、なし map = {0: 1, 3: 1}に更新 4を処理：\ntotal = 7 7 - 7 = 0を探索、見つかる、result += 1 map = {0: 1, 3: 1, 7: 1}に更新 7を処理：\ntotal = 14 14 - 7 = 7を探索、見つかる、result += 1 map = {0: 1, 3: 1, 7: 1, 14: 1}に更新 2を処理：\ntotal = 16 16 - 7 = 9を探索、なし map = {0: 1, 3: 1, 7: 1, 14: 1, 16: 1}に更新 -3を処理：\ntotal = 13 13 - 7 = 6を探索、なし map = {0: 1, 3: 1, 7: 1, 14: 1, 16: 1, 13: 1}に更新 1を処理：\ntotal = 14 14 - 7 = 7を探索、見つかる、result += 1 map = {0: 1, 3: 1, 7: 1, 14: 2, 16: 1, 13: 1}に更新 4を処理：\ntotal = 18 18 - 7 = 11を探索、なし map = {0: 1, 3: 1, 7: 1, 14: 2, 16: 1, 13: 1, 18: 1}に更新 2を処理：\ntotal = 20 20 - 7 = 13を探索、見つかる、result += 1 map = {0: 1, 3: 1, 7: 1, 14: 2, 16: 1, 13: 1, 18: 1, 20: 1}に更新 最終的な結果は4となり、和が7となる部分配列が4つあることを示します。\n完全なコード # import java.util.HashMap; class Solution { public int subarraySum(int[] nums, int k) { int result = 0, total = 0; HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(0, 1); for (int num : nums) { total += num; if (map.containsKey(total - k)) { result += map.get(total - k); } map.put(total, map.getOrDefault(total, 0) + 1); } return result; } } ","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/posts/leetcode/medium/leetcode560/","section":"Posts","summary":"","title":"leetcode 560 - Subarray Sum Equals K","type":"posts"},{"content":" 題目 # leetcode 560 - Subarray Sum Equals K (題目說明請點連結)\n範例 # Example 1:\nInput: nums = [1, 1, 1], k = 2 Output: 2 Example 2:\nInput: nums = [1, 2, 3], k = 3 Output: 2 解題思路 # 這題目要求我們找出數組中和為 k 的子數組的個數。可以使用 前綴和 和 哈希表 來解決這個問題，這樣能夠高效處理，時間複雜度為 O(n)。\n什麼是前綴和與哈希表 # 前綴和（Prefix Sum） 其實就是從數組的開頭開始，累加每一個數字，直到某個位置。對於數組中的任意子數組 [i, j]，它的和其實就是 sum[j] - sum[i-1]，其中 sum[i-1] 表示從頭到 i-1 的和。\n我們的目標是找到一組子數組，使得它們的和為 k。所以每當我們累加一個數字時，我們就去查哈希表中是否存在 total - k，如果存在，則說明這個位置之前的某個地方到現在的位置的子數組和正好是 k。\n解法 # 我們需要累加每一個數字並記錄當前的總和，然後查哈希表裡面是否存在 total - k，如果存在，則這個差值表示有子數組的和為 k，我們就把對應的次數加到結果裡。\n為了避免漏掉從數組開始的子數組，我們初始化哈希表 map = {0: 1}，這樣當 total = k 時，直接把結果加一。\n例子說明：nums = [3, 4, 7, 2, -3, 1, 4, 2], k = 7 # 初始情況：map = {0: 1}, total = 0, result = 0 處理第一個數字 3：\ntotal = 3 查哈希表 map 是否有 3 - 7 = -4，沒有。 更新 map，map = {0: 1, 3: 1}。 處理第二個數字 4：\ntotal = 7 查哈希表 map 是否有 7 - 7 = 0，找到了，map.get(0) = 1，結果 result += 1，result = 1。 更新 map，map = {0: 1, 3: 1, 7: 1}。 處理第三個數字 7：\ntotal = 14 查哈希表 map 是否有 14 - 7 = 7，找到了，map.get(7) = 1，結果 result += 1，result = 2。 更新 map，map = {0: 1, 3: 1, 7: 1, 14: 1}。 處理第四個數字 2：\ntotal = 16 查哈希表 map 是否有 16 - 7 = 9，沒有找到。 更新 map，map = {0: 1, 3: 1, 7: 1, 14: 1, 16: 1}。 處理第五個數字 -3：\ntotal = 13 查哈希表 map 是否有 13 - 7 = 6，沒有找到。 更新 map，map = {0: 1, 3: 1, 7: 1, 14: 1, 16: 1, 13: 1}。 處理第六個數字 1：\ntotal = 14 查哈希表 map 是否有 14 - 7 = 7，找到了，map.get(7) = 1，結果 result += 1，result = 3。 更新 map，map = {0: 1, 3: 1, 7: 1, 14: 2, 16: 1, 13: 1}。 處理第七個數字 4：\ntotal = 18 查哈希表 map 是否有 18 - 7 = 11，沒有找到。 更新 map，map = {0: 1, 3: 1, 7: 1, 14: 2, 16: 1, 13: 1, 18: 1}。 處理第八個數字 2：\ntotal = 20 查哈希表 map 是否有 20 - 7 = 13，找到了，map.get(13) = 1，結果 result += 1，result = 4。 更新 map，map = {0: 1, 3: 1, 7: 1, 14: 2, 16: 1, 13: 1, 18: 1, 20: 1}。 最終結果是 4，即有四個子數組的和為 7。\n完整程式碼 # import java.util.HashMap; class Solution { public int subarraySum(int[] nums, int k) { int result = 0, total = 0; HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(0, 1); for (int num : nums) { total += num; if (map.containsKey(total - k)) { result += map.get(total - k); } map.put(total, map.getOrDefault(total, 0) + 1); } return result; } } ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode560/","section":"技術文章","summary":"","title":"leetcode 560 - Subarray Sum Equals K","type":"tech-articles"},{"content":" 問題 # leetcode 735 - Asteroid Collision (問題の詳細はリンクをクリックしてください)\n例題 # 例1:\n入力: asteroids = [5, 10, -5] 出力: [5, 10] 説明: 小惑星-5は10と衝突して破壊されます。 例2:\n入力: asteroids = [8, -8] 出力: [] 説明: 小惑星8と-8が衝突し、両方とも破壊されます。 例3:\n入力: asteroids = [10, 2, -5] 出力: [10] 説明: 小惑星-5は2と衝突して2を破壊し、その後10と衝突して破壊されます。 解法 # この問題は小惑星の衝突をシミュレートします。ルールは以下の通りです：\n各小惑星の値はその大きさと方向を表します： 正の値は右方向への移動 負の値は左方向への移動 小惑星が出会った時： 同じ方向の場合、そのまま進みます 反対方向の場合、衝突が発生し、小さい方が破壊されます 両方の大きさが同じ場合、両方とも破壊されます 最終的な小惑星の状態を維持する必要があります **スタック（Stack）**を使用して解決します：\nasteroids配列を順番に走査し、小惑星をスタックにプッシュします 負の値の小惑星に遭遇した場合、スタックの上部が正の値の小惑星かどうかを確認し、衝突処理を行います より小さい小惑星を連続的にポップし、適切な位置が見つかるまで続けます 最後にスタック内の小惑星を結果として返します 完全なコード # import java.util.Stack; class Solution { public int[] asteroidCollision(int[] asteroids) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; asteroids.length; i++) { if (asteroids[i] \u0026gt; 0) { stack.push(asteroids[i]); } else { while (!stack.isEmpty() \u0026amp;\u0026amp; stack.peek() \u0026gt; 0 \u0026amp;\u0026amp; stack.peek() \u0026lt; -asteroids[i]) { stack.pop(); } if (!stack.isEmpty() \u0026amp;\u0026amp; stack.peek() == -asteroids[i]) { stack.pop(); } else if (stack.isEmpty() || stack.peek() \u0026lt; 0) { stack.push(asteroids[i]); } } } int[] res = new int[stack.size()]; for (int i = res.length - 1; i \u0026gt;= 0; i--) { res[i] = stack.pop(); } return res; } } ","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/posts/leetcode/medium/leetcode735/","section":"Posts","summary":"","title":"leetcode 735 - Asteroid Collision","type":"posts"},{"content":" 題目 # leetcode 735 - Asteroid Collision (題目說明請點連結)\n範例 # Example 1:\nInput: asteroids = [5, 10, -5] Output: [5, 10] Explanation: The asteroid -5 collides with 10 and is destroyed. Example 2:\nInput: asteroids = [8, -8] Output: [] Explanation: The asteroid 8 collides with -8 and both are destroyed. Example 3:\nInput: asteroids = [10, 2, -5] Output: [10] Explanation: The asteroid -5 collides with 2 and destroys it, then collides with 10 and is destroyed. 解題思路 # 這題要求模擬行星碰撞的過程，規則如下：\n每顆行星的值代表其大小與方向： 正值表示向右移動。 負值表示向左移動。 當行星相遇時： 若方向相同，則繼續前進。 若相對方向，則發生碰撞，較小的行星被摧毀。 若兩顆行星大小相等，則都被摧毀。 需要維護行星的最終狀態。 使用 Stack（堆疊） 來解決這個問題：\n依序遍歷 asteroids 陣列，將行星推入堆疊。 若遇到負值行星，則檢查堆疊頂端是否為正值行星，並進行碰撞處理。 持續彈出較小的行星，直到找到適當的位置。 最後返回堆疊中的行星作為結果。 完整程式碼 # import java.util.Stack; class Solution { public int[] asteroidCollision(int[] asteroids) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; asteroids.length; i++) { if (asteroids[i] \u0026gt; 0) { stack.push(asteroids[i]); } else { while (!stack.isEmpty() \u0026amp;\u0026amp; stack.peek() \u0026gt; 0 \u0026amp;\u0026amp; stack.peek() \u0026lt; -asteroids[i]) { stack.pop(); } if (!stack.isEmpty() \u0026amp;\u0026amp; stack.peek() == -asteroids[i]) { stack.pop(); } else if (stack.isEmpty() || stack.peek() \u0026lt; 0) { stack.push(asteroids[i]); } } } int[] res = new int[stack.size()]; for (int i = res.length - 1; i \u0026gt;= 0; i--) { res[i] = stack.pop(); } return res; } } ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode735/","section":"技術文章","summary":"","title":"leetcode 735 - Asteroid Collision","type":"tech-articles"},{"content":" 問題 # leetcode 739 - Daily Temperatures (問題の詳細はリンクをクリックしてください)\n例題 # 例1:\n入力: temperatures = [73, 74, 75, 71, 69, 72, 76, 73] 出力: [1, 1, 4, 2, 1, 1, 0, 0] 説明: 0日目の後、1日後に気温が上昇します（74は73より高い）。 例2:\n入力: temperatures = [30, 40, 50, 60] 出力: [1, 1, 1, 0] 例3:\n入力: temperatures = [30, 60, 90] 出力: [1, 1, 0] 解法 # この問題は、各日の後何日で気温が上昇するかを求めます。\n解法：単調減少スタック（Monotonic Stack）\n温度のインデックスを格納するスタックを作成します。 temperatures配列を後ろから前に走査します。 現在の温度temperatures[i]がスタックトップの温度以上の場合、スタックからポップします。 スタックが空でない場合、スタックトップのインデックスとの差分を結果配列に格納します。 現在のインデックスをスタックにプッシュします。 このアプローチにより、スタック内のインデックスに対応する温度が減少順になり、次の高温を素早く見つけることができます。\n完全なコード # import java.util.Stack; class Solution { public int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; int[] res = new int[n]; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = n - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[i] \u0026gt;= temperatures[stack.peek()]) { stack.pop(); } if (!stack.isEmpty()) { res[i] = stack.peek() - i; } stack.push(i); } return res; } } ","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/posts/leetcode/medium/leetcode739/","section":"Posts","summary":"","title":"leetcode 739 - Daily Temperatures","type":"posts"},{"content":" 題目 # leetcode 739 - Daily Temperatures (題目說明請點連結)\n範例 # Example 1:\nInput: temperatures = [73, 74, 75, 71, 69, 72, 76, 73] Output: [1, 1, 4, 2, 1, 1, 0, 0] Explanation: 在第 0 天後的 1 天內會變暖（74 比 73 高）。 Example 2:\nInput: temperatures = [30, 40, 50, 60] Output: [1, 1, 1, 0] Example 3:\nInput: temperatures = [30, 60, 90] Output: [1, 1, 0] 解題思路 # 這題要求找到每一天之後幾天會出現更高的溫度。\n解法：單調遞減堆疊（Monotonic Stack）\n建立一個 Stack 來存儲溫度的索引。 從後往前遍歷 temperatures 陣列。 如果當前溫度 temperatures[i] 大於等於堆疊頂端對應的溫度，則彈出堆疊。 如果堆疊非空，則計算與堆疊頂端的索引相差的天數，存入結果陣列。 將當前索引推入堆疊。 這種方法確保堆疊內的索引對應的溫度是遞減的，從而能夠快速找到下一個更高的溫度。\n完整程式碼 # import java.util.Stack; class Solution { public int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; int[] res = new int[n]; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = n - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[i] \u0026gt;= temperatures[stack.peek()]) { stack.pop(); } if (!stack.isEmpty()) { res[i] = stack.peek() - i; } stack.push(i); } return res; } } ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode739/","section":"技術文章","summary":"","title":"leetcode 739 - Daily Temperatures","type":"tech-articles"},{"content":"","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/tags/leetcode-easy/","section":"Tags","summary":"","title":"Leetcode Easy","type":"tags"},{"content":"","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/tags/leetcode-hard/","section":"Tags","summary":"","title":"Leetcode Hard","type":"tags"},{"content":"","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/tags/leetcode-medium/","section":"Tags","summary":"","title":"Leetcode Medium","type":"tags"},{"content":"","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/tags/stack-problem/","section":"Tags","summary":"","title":"Stack Problem","type":"tags"},{"content":"","date":"2025年2月3日","externalUrl":null,"permalink":"/ja/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"過年正好有回台灣，就看到高雄港有展出巨型吉依卡哇的消息，就開車前往順便跟家人去高雄玩。\n高雄港 # 抵達附近停車場，停好車出來遠處就看到小八的屁股 全家也剛好有聯名活動，飲料杯是吉依卡哇的圖案 三隻分別在高雄港的不同位置，不過都是走路能到的距離，順便逛高雄港。 烏薩奇 # 只有烏薩奇在陸地上，而且最小隻。 吉伊卡哇 # 小八 # ","date":"2025年1月28日","externalUrl":null,"permalink":"/daily-notes/daily-life/kaohsiung-chiikawa/","section":"Daily-Notes","summary":"","title":"高雄 | 吉伊卡哇燈會","type":"daily-notes"},{"content":"","date":"2025年1月28日","externalUrl":null,"permalink":"/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/","section":"Categories","summary":"","title":"日常生活","type":"categories"},{"content":"","date":"2025年1月20日","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"","date":"2025年1月20日","externalUrl":null,"permalink":"/categories/hugo%E7%B6%B2%E7%AB%99%E7%9B%B8%E9%97%9C/","section":"Categories","summary":"","title":"Hugo網站相關","type":"categories"},{"content":"在 Hugo 網站中加入 Disqus 評論系統，讓你的部落格文章下方可以顯示留言區，提升讀者互動。\n1.建立 Disqus 帳號並取得 shortname # 前往 Disqus 官網 註冊帳號。 建立一個新的網站，取得你的 shortname 2.新增 Disqus partial 檔案 # 建立好專案後，點擊左上角Installation，因為選項沒有Hugo，所以選擇下方的Universal Code install instructions。 接著將代碼複製起來，在 layouts/partials/ 目錄下建立 disqus.html，內容如下：\n\u0026lt;div style=\u0026#34;margin-top: 4rem;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;hr style=\u0026#34;margin-bottom: 2rem; border-top: 1.5px solid #ccc;\u0026#34; /\u0026gt; \u0026lt;div id=\u0026#34;disqus_thread\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var disqus_config = function () { this.page.url = \u0026#39;{{ .Permalink }}\u0026#39;; this.page.identifier = \u0026#39;{{ .File.Path }}\u0026#39;; }; (function() { var d = document, s = d.createElement(\u0026#39;script\u0026#39;); s.src = \u0026#39;https://你的-shortname.disqus.com/embed.js\u0026#39;; s.setAttribute(\u0026#39;data-timestamp\u0026#39;, +new Date()); (d.head || d.body).appendChild(s); })(); \u0026lt;/script\u0026gt; \u0026lt;noscript\u0026gt; 請啟用 JavaScript 以檢視 \u0026lt;a href=\u0026#34;https://disqus.com/?ref_noscript\u0026#34;\u0026gt;由 Disqus 提供的評論\u0026lt;/a\u0026gt; \u0026lt;/noscript\u0026gt; 記得將 你的-shortname 替換成你自己的 Disqus shortname。\n3.在文章模板插入 partial # 打開 layouts/_default/single.html，在文章內容（{{ .Content }}）之後插入：\n{{ partial \u0026#34;disqus.html\u0026#34; . }} 4.設定 config.toml # 在網站根目錄的 config.toml 加入：\ndisqusShortname = \u0026#34;你的-shortname\u0026#34; 5.重啟Hugo查看顯示效果 # 完成上述步驟後，重新啟動 Hugo 網站，文章下方就會出現 Disqus 留言區。\n注意事項 # 若要自訂顯示條件，可用 if 判斷只在特定文章顯示。 若留言區未顯示，請檢查 shortname 是否正確、網路是否可連 Disqus。 ","date":"2025年1月20日","externalUrl":null,"permalink":"/tech-articles/hugo-website/add-disqus/","section":"技術文章","summary":"","title":"在 Hugo 網站加入 Disqus ","type":"tech-articles"},{"content":"前幾天終於搶到 吉伊卡哇郎拉麵的整理卷，之前在名古屋PARCO的郎拉麵， 終於大阪也開張了地點就位在大阪 心齋橋 PARCO B2。\n預約、點餐 # 需事先在LivePocket-Ticket購入整理卷。 到現場之後，出示整理卷上的 QR Code 給工作人員掃，等待入場的期間，線上進行點餐。 郎拉麵 # 點完餐後，店員會直接帶入座，在座位上等待拉麵上來。 座位上會擺著所選的餐點立牌，可以先拍照。 為了烏薩奇點了大碗的，味道是不錯， 不過麵太多吃到後面有點膩，沒有什麼轉味的元素。 ","date":"2025年1月17日","externalUrl":null,"permalink":"/daily-notes/japan-life/chiikawa-ramen/","section":"Daily-Notes","summary":"","title":"大阪 | 心齋橋 PARCO 吉伊卡哇郎拉麵","type":"daily-notes"},{"content":"","date":"2025年1月10日","externalUrl":null,"permalink":"/ja/tags/binary-search-problem/","section":"Tags","summary":"","title":"Binary Search Problem","type":"tags"},{"content":" 問題 # leetcode 1231 - Divide Chocolate(問題の詳細はリンクをクリックしてください)\n例1:\n入力: sweetness = [1,2,3,4,5,6,7,8,9], K = 5\n出力: 6\n説明: チョコレートを[1,2,3], [4,5], [6], [7], [8], [9]のように分割できます。\n例2:\n入力: sweetness = [5,6,7,8,9,1,2,3,4], K = 8\n出力: 1\n説明: チョコレートを9つに分割する方法は1通りしかありません。\n例3:\n入力: sweetness = [1,2,2,1,2,2,1,2,2], K = 2\n出力: 5\n説明: チョコレートを[1,2,2], [1,2,2], [1,2,2]のように分割できます。\n解法 # 入力は甘さの配列sweetnessとK人の友人（自分を含む）に分配する数、\n出力はチョコレートをk+1個に分割した時の各部分の甘さの最小値の最大値です。\nこの問題のアプローチは leetcode410 と似ていますが、探索目標が異なります。\nLeetcode 410とLeetcode 1231の比較 # Leetcode 410：最大値の最小化\n更新ロジック：実行可能な解が見つかった場合、より小さい最大値を試すため、右境界をright=midに更新。\nより小さい範囲を試す必要があるため、中間値は切り下げを使用。\nLeetcode 1231：最小値の最大化\n更新ロジック：実行可能な解が見つかった場合、より大きい最小値を試すため、左境界をleft=midに更新。\nより大きい範囲を試す必要があるため、中間値は切り上げを使用。\nここでは最小値の最大化のための二分探索の範囲を以下のように設定します：\n左境界（min）：配列内の最小の甘さ。\nmin=min(sweetness) 右境界（max）：すべての甘さの合計。\nmax=∑(sweetness) 二分探索のプロセス：\n二分範囲を[min,max]で初期化。 中間値mid=(min+max+1)/2を計算。 canSplitメソッドでmidが実行可能かを検証： 実行可能な場合、より大きい甘さを試すため左境界をmin=midに更新。 実行不可能な場合、右境界をmax=mid-1に更新。 最後にmin(left)==max(right)となったら、答えが見つかります。 完全なコード # class Solution { public int maximizeSweetness(int [] sweetness, int k) { int left = Integer.MAX_VALUE; int right = 0; for (int sweet:sweetness){ if (sweet \u0026lt; left){ left = sweet; } right+=sweet; } while (left \u0026lt; right){ int mid = left + (right - left+1)/2; if(canSplit(sweetness,k,mid)){ left = mid; }else { right = mid-1; } } return left; } public boolean canSplit(int [] sweetness, int k,int minSweetness) { int count = 0; int sum = 0; for(int sweet:sweetness){ sum+=sweet; if(sum\u0026gt;=minSweetness){ sum = 0; count++; } } if(count\u0026gt;=k+1){ return true; } return false; } } ","date":"2025年1月10日","externalUrl":null,"permalink":"/ja/posts/leetcode/medium/leetcode1231/","section":"Posts","summary":"","title":"leetcode 1231 - Divide Chocolate","type":"posts"},{"content":" 題目 # leetcode 1231 - Divide Chocolate(題目說明請點連結)\nExample 1:\nInput: sweetness = [1,2,3,4,5,6,7,8,9], K = 5\nOutput: 6\nExplanation: You can divide the chocolate to [1,2,3], [4,5], [6], [7], [8], [9]\nExample 2:\nInput: sweetness = [5,6,7,8,9,1,2,3,4], K = 8\nOutput: 1\nExplanation: There is only one way to cut the bar into 9 pieces.\nExample 3:\nInput: sweetness = [1,2,2,1,2,2,1,2,2], K = 2\nOutput: 5\nExplanation: You can divide the chocolate to [1,2,2], [1,2,2], [1,2,2]\n解題思路 # 輸入為一個sweetness的甜度陣列，與需要分給k個朋友(要包含自己)，\n輸出為將巧克力切成 k+1 塊的所有人能得到甜度中的最小值。\n此題思路與 leetcode410 類似，但要搜尋目標的不同。 比較Leetcode 410 與 Leetcode 1231 # Leetcode 410：最小化最大值\n更新邏輯：當找到可行解時，我們嘗試更小的最大值，右邊界 right=mid。\n因為需要試探更小的範圍，用 下取中間值。\nLeetcode 1231：最大化最小值\n更新邏輯：當找到可行解時，我們嘗試更大的最小值，左邊界 left=mid。\n因為需要試探更大的範圍，用 上取中間值。\n這裡搜尋最大化最小值將二分法設定範圍如下：\n左邊界（min）：陣列之中的最小甜度。\nmin=min(sweetness) 右邊界（max）：所有甜度的總和。\nmax=∑(sweetness) 二分搜索過程：\n初始化二分範圍為 [min,max]。 計算中間值 mid=(min+max+1)/2。 建立canSplit方法驗證 mid 是否可行： 如果可行，更新左邊界 min=mid，嘗試更大甜度。 如果不可行，更新右邊界 max=mid-1。 最後當 min(left)==max(right)，找到答案 完整程式碼 # class Solution { public int maximizeSweetness(int [] sweetness, int k) { int left = Integer.MAX_VALUE; int right = 0; for (int sweet:sweetness){ if (sweet \u0026lt; left){ left = sweet; } right+=sweet; } while (left \u0026lt; right){ int mid = left + (right - left+1)/2; if(canSplit(sweetness,k,mid)){ left = mid; }else { right = mid-1; } } return left; } public boolean canSplit(int [] sweetness, int k,int minSweetness) { int count = 0; int sum = 0; for(int sweet:sweetness){ sum+=sweet; if(sum\u0026gt;=minSweetness){ sum = 0; count++; } } if(count\u0026gt;=k+1){ return true; } return false; } } ","date":"2025年1月10日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode1231/","section":"技術文章","summary":"","title":"leetcode 1231 - Divide Chocolate","type":"tech-articles"},{"content":" 問題 # leetcode 141 - Linked List Cycle(問題の詳細はリンクをクリック)\nExample 1:\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\n説明: 連結リストにサイクルが存在し、末尾が1番目のノード（0-indexed）に接続しています。\nExample 2:\nInput: head = [1,2], pos = 0\nOutput: true\n説明: 連結リストにサイクルが存在し、末尾が0番目のノードに接続しています。\nExample 3:\nInput: head = [1], pos = -1\nOutput: false\n説明: 連結リストにサイクルは存在しません。\n解法のアプローチ # この問題は連結リストにサイクルが存在するかどうかを確認し、true/falseを返します。\n高速・低速ポインタを使用してサイクルを検出できます：\n低速ポインタは1ノードずつ、高速ポインタは2ノードずつ移動し、高速ポインタが低速ポインタに追いついた場合、サイクルが存在することになります。\n完全なコード # public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; // 高速ポインタの初期化 ListNode slow = head; // 低速ポインタの初期化 while(fast!=null\u0026amp;\u0026amp;fast.next!=null){ // 高速ポインタと次のノードがnullでない間 fast = fast.next.next; // 高速ポインタを2ノード進める slow = slow.next; // 低速ポインタを1ノード進める if(fast == slow){ // 高速ポインタと低速ポインタが一致した場合 return true; // サイクルが存在する } } return false; // サイクルは存在しない } } ","date":"2025年1月10日","externalUrl":null,"permalink":"/ja/posts/leetcode/easy/leetcode141/","section":"Posts","summary":"","title":"leetcode 141 - Linked List Cycle","type":"posts"},{"content":" 題目 # leetcode 141 - Linked List Cycle(題目說明請點連結)\nExample 1:\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\nExample 2:\nInput: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\nExample 3:\nInput: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list.\n解題思路 # 這題確認 Linked List 是否有 Cycle ，回傳true、flase。\n可以用上快慢指針確認是否有Cycle：\nslow 一次走1個節點，fast 一次走2個節點，只要 fast 與 slow 相遇即是有Cycle。\n完整程式碼 # public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; // 初始化快指針 ListNode slow = head; // 初始化慢指針 while(fast!=null\u0026amp;\u0026amp;fast.next!=null){ // 當快指針和快指針的下一個節點不為空時 fast = fast.next.next; // 快指針每次移動兩步 slow = slow.next; // 慢指針每次移動一步 if(fast == slow){ // 如果快指針和慢指針相遇 return true; // 有環 } } return false; // 無環 } } ","date":"2025年1月10日","externalUrl":null,"permalink":"/tech-articles/leetcode/easy/leetcode141/","section":"技術文章","summary":"","title":"leetcode 141 - Linked List Cycle","type":"tech-articles"},{"content":" 問題 # leetcode 237 - Delete Node in a Linked List(問題の詳細はリンクをクリックしてください)\n例1:\n入力: head = [4,5,1,9], node = 5\n出力: [4,1,9]\n説明: 値5を持つ2番目のノードが与えられ、\n連結リストは関数呼び出し後に 4 -\u0026gt; 1 -\u0026gt; 9 となります。\n例2:\n入力: head = [4,5,1,9], node = 1\n出力: [4,5,9]\n説明: 値1を持つ3番目のノードが与えられ、\n連結リストは関数呼び出し後に 4 -\u0026gt; 5 -\u0026gt; 9 となります。\n解法 # この問題は連結リストのDelete Node機能を実装します。\n完全なコード # class Solution { public void deleteNode(ListNode node) { node.val=node.next.val; node.next=node.next.next; } } ","date":"2025年1月10日","externalUrl":null,"permalink":"/ja/posts/leetcode/medium/leetcode237/","section":"Posts","summary":"","title":"leetcode 237 - Delete Node in a Linked List","type":"posts"},{"content":" 題目 # leetcode 237 - Delete Node in a Linked List(題目說明請點連結)\nExample 1:\nInput: head = [4,5,1,9], node = 5\nOutput: [4,1,9]\nExplanation: You are given the second node with value 5,\nthe linked list should become 4 -\u0026gt; 1 -\u0026gt; 9 after calling your function.\nExample 2:\nInput: head = [4,5,1,9], node = 1\nOutput: [4,5,9]\nExplanation: You are given the third node with value 1,\nthe linked list should become 4 -\u0026gt; 5 -\u0026gt; 9 after calling your function.\n解題思路 # 這題就是實作Linked List 的 Delete Node Function。\n完整程式碼 # class Solution { public void deleteNode(ListNode node) { node.val=node.next.val; node.next=node.next.next; } } ","date":"2025年1月10日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode237/","section":"技術文章","summary":"","title":"leetcode 237 - Delete Node in a Linked List","type":"tech-articles"},{"content":" 題目 # leetcode 1062 - Split Array Largest Sum(題目說明請點連結)\nExample 1:\nInput: nums = [7,2,5,10,8], k = 2\nOutput: 18\nExplanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\nExample 2:\nInput: nums = [1,2,3,4,5], k = 2\nOutput: 9\nExplanation: There are four ways to split nums into two subarrays. The best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.\n解題思路 # 輸入為一個字串，輸出為能切成的K群數內子集合其中最大的總和，舉例：\nnums = [7,2,5,10,8] 可以被分成 k = 2 群數的子集合，\n[7,2,5] 和 [10,8]，其中最大的和為18(10+8)。\n我們的目標是最小化子結合的最大和（即答案），這是一個 有序範圍問題，因為：\n當分割數 k 增加時，每個子集合的和會減小（子集合更短）。\n當分割數 k 減少時，每個子集合的和會增大（子集合更長）。\n而問題可以轉化為判斷 sum 是否滿足條件，將數組劃分為 k 個子集合，且每個子集合的和都不超過 sum。\n而其單調性也符合使用二分搜索的條件，二分法範圍如下：\n左邊界（min）：陣列中的最大值，因為任何子集合的和都至少等於其陣列當中的最大值。\nmin=max(nums) 右邊界（max）：所有數字的總和，因為當 k=1 時，所有數字都在一個子集合中。\nmax=∑(nums) 二分搜索過程：\n初始化二分範圍為 [min,max]。 計算中間值 mid=(min+max)/2。 建立canSplit方法驗證 mid 是否可行(其最大值mid是否能分成k群)： 如果可行，更新右邊界 max=mid，嘗試更小的最大和。 如果不可行，更新左邊界 min=mid+1。 最後當 min(left)==max(right)，找到答案 完整程式碼 # class Solution { public int splitArray(int[] nums, int k) { int left = 0; int right = 0; for(int num:nums){ if(num\u0026gt;left){ left = num; } right+=num; } while(left\u0026lt;right){ int mid = left + (right - left)/2; if(canSplit(nums,k,mid)){ right = mid; }else{ left = mid+1; } } return left; } public boolean canSplit(int nums[],int k,int maxValue) { int sum = 0; int count = 1; for(int num:nums){ if(sum+num\u0026gt;maxValue){ count++; sum = num; if(count\u0026gt;k){ return false; } }else { sum+=num; } } return true; } } ","date":"2025年1月10日","externalUrl":null,"permalink":"/ja/posts/leetcode/hard/leetcode410/","section":"Posts","summary":"","title":"leetcode 410 - Split Array Largest Sum","type":"posts"},{"content":" 題目 # leetcode 1062 - Split Array Largest Sum(題目說明請點連結)\nExample 1:\nInput: nums = [7,2,5,10,8], k = 2\nOutput: 18\nExplanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\nExample 2:\nInput: nums = [1,2,3,4,5], k = 2\nOutput: 9\nExplanation: There are four ways to split nums into two subarrays. The best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.\n解題思路 # 輸入為一個字串，輸出為能切成的K群數內子集合其中最大的總和，舉例：\nnums = [7,2,5,10,8] 可以被分成 k = 2 群數的子集合，\n[7,2,5] 和 [10,8]，其中最大的和為18(10+8)。\n我們的目標是最小化子結合的最大和（即答案），這是一個 有序範圍問題，因為：\n當分割數 k 增加時，每個子集合的和會減小（子集合更短）。\n當分割數 k 減少時，每個子集合的和會增大（子集合更長）。\n而問題可以轉化為判斷 sum 是否滿足條件，將數組劃分為 k 個子集合，且每個子集合的和都不超過 sum。\n而其單調性也符合使用二分搜索的條件，二分法範圍如下：\n左邊界（min）：陣列中的最大值，因為任何子集合的和都至少等於其陣列當中的最大值。\nmin=max(nums) 右邊界（max）：所有數字的總和，因為當 k=1 時，所有數字都在一個子集合中。\nmax=∑(nums) 二分搜索過程：\n初始化二分範圍為 [min,max]。 計算中間值 mid=(min+max)/2。 建立canSplit方法驗證 mid 是否可行(其最大值mid是否能分成k群)： 如果可行，更新右邊界 max=mid，嘗試更小的最大和。 如果不可行，更新左邊界 min=mid+1。 最後當 min(left)==max(right)，找到答案 完整程式碼 # class Solution { public int splitArray(int[] nums, int k) { int left = 0; int right = 0; for(int num:nums){ if(num\u0026gt;left){ left = num; } right+=num; } while(left\u0026lt;right){ int mid = left + (right - left)/2; if(canSplit(nums,k,mid)){ right = mid; }else{ left = mid+1; } } return left; } public boolean canSplit(int nums[],int k,int maxValue) { int sum = 0; int count = 1; for(int num:nums){ if(sum+num\u0026gt;maxValue){ count++; sum = num; if(count\u0026gt;k){ return false; } }else { sum+=num; } } return true; } } ","date":"2025年1月10日","externalUrl":null,"permalink":"/tech-articles/leetcode/hard/leetcode410/","section":"技術文章","summary":"","title":"leetcode 410 - Split Array Largest Sum","type":"tech-articles"},{"content":" 問題 # leetcode 237 - Reverse Linked List II(問題の詳細はリンクをクリックしてください)\n例1:\n入力: head = [1,2,3,4,5], left = 2, right = 4\n出力: [1,4,3,2,5]\n例2:\n入力: head = [5], left = 1, right = 1\n出力: [5]\n解法 # この問題では、連結リストとleft、rightが与えられます。\nleftからrightまでを反転した連結リストを返します。\n例えば 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5 で left = 2, right = 4 の場合、\n返す答えは 1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5 となります。\nこの問題では、各反転を段階的に交換していきます。\nまず、headが反転されて最初のノードを指すものがなくなる状況を避けるためにdummyを作成し、\n次にprevをdummyから始めて探索を開始します：\nD-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5\np 次にprevからleftの反転開始位置の前のノードを探し、currentとtempをそれぞれ次の2つのノードとして設定します：\nD-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5\np c t\nそして交換を実行します：\nt.next : 3-\u0026gt;4 から 3-\u0026gt;2 に変更\nc.next : 2-\u0026gt;3 から 2-\u0026gt;4 に変更\np.next : 1-\u0026gt;2 から 1-\u0026gt;3 に変更\nこの時点での連結リストは D-\u0026gt;1-\u0026gt;3-\u0026gt;2-\u0026gt;4-\u0026gt;5 となります\n次の交換を実行します：\nD-\u0026gt;1-\u0026gt;3-\u0026gt;2-\u0026gt;4-\u0026gt;5\np c t\nそして交換を実行します：\nt.next : 4-\u0026gt;5 から 4-\u0026gt;3 に変更\nc.next : 2-\u0026gt;4 から 2-\u0026gt;5 に変更\np.next : 1-\u0026gt;3 から 1-\u0026gt;4 に変更\nこの時点での連結リストは D-\u0026gt;1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5 となります\nDummy.nextを返すと答えが得られます。\n完全なコード # /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { if (head == null || left == right) { return head; } ListNode dummy = new ListNode(0); dummy.next = head; ListNode prev = dummy; for(int i=1;i\u0026lt;left;i++){ prev = prev.next; } ListNode cur = prev.next; for(int i=0;i\u0026lt;right-left;i++){ ListNode temp = cur.next; cur.next = temp.next; temp.next = prev.next; prev.next = temp; } return dummy.next; } } ","date":"2025年1月10日","externalUrl":null,"permalink":"/ja/posts/leetcode/medium/leetcode92/","section":"Posts","summary":"","title":"leetcode 92 - Reverse Linked List II","type":"posts"},{"content":" 題目 # leetcode 237 - Reverse Linked List II(題目說明請點連結)\nExample 1:\nInput: head = [1,2,3,4,5], left = 2, right = 4\nOutput: [1,4,3,2,5]\nExample 2:\nInput: head = [5], left = 1, right = 1\nOutput: [5]\n解題思路 # 這題給定一個 linked list 與 left、right。\n回傳從left到right reverse 後的 linked list。\n比如 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5 left = 2 , right = 4\n回傳的答案就是 1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5\n這題我們將每一次的反轉進行逐步交換即可。\n首先建立一個 dummy 作為避免 head 被反轉找不到沒有人指向第一個節點的情況，\n接著讓建立 perv 從 dummy 開始找起，然後會得到：\nD-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5\np 接著從 prev 會開始找到 left 開始反轉的前一個節點，然後建立 current 與 temp 分別為下二個節點 ：\nD-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5\np c t\n接著就進行交換：\nt.next : 從 3-\u0026gt;4 變成 3-\u0026gt;2\nc.next : 從 2-\u0026gt;3 變成 2-\u0026gt;4\np.next : 從 1-\u0026gt;2 變成 1-\u0026gt;3\n此時的 linked list 為 D-\u0026gt;1-\u0026gt;3-\u0026gt;2-\u0026gt;4-\u0026gt;5\n接著進行下一次的交換:\nD-\u0026gt;1-\u0026gt;3-\u0026gt;2-\u0026gt;4-\u0026gt;5\np c t\n接著就進行交換：\nt.next : 從 4-\u0026gt;5 變成 4-\u0026gt;3\nc.next : 從 2-\u0026gt;4 變成 2-\u0026gt;5\np.next : 從 1-\u0026gt;3 變成 1-\u0026gt;4\n此時的 linked list 為 D-\u0026gt;1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5\n回傳 Dummy.next 即為答案。\n完整程式碼 # /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { if (head == null || left == right) { return head; } ListNode dummy = new ListNode(0); dummy.next = head; ListNode prev = dummy; for(int i=1;i\u0026lt;left;i++){ prev = prev.next; } ListNode cur = prev.next; for(int i=0;i\u0026lt;right-left;i++){ ListNode temp = cur.next; cur.next = temp.next; temp.next = prev.next; prev.next = temp; } return dummy.next; } } ","date":"2025年1月10日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode92/","section":"技術文章","summary":"","title":"leetcode 92 - Reverse Linked List II","type":"tech-articles"},{"content":"","date":"2025年1月10日","externalUrl":null,"permalink":"/ja/tags/linked-list-problem/","section":"Tags","summary":"","title":"Linked List Problem","type":"tags"},{"content":"在日本，新年的首次參拜被稱為初詣（はつもうで）。每到新年，許多日本人會前往神社或寺廟，祈求新的一年平安順利、身體健康。 初詣通常會在1/1到1/3之間進行，有些人則會選擇在元旦當天凌晨就前往參拜。\n1/4 和朋友相約到奈良春日大社進行初詣，這天人潮比較少，順便去奈良看路。\n春日大社 # 從難波搭乘近鐵奈良線，到近鐵奈良站後，轉搭巴士到春日大社，大概1小時左右。 就這樣一路往上走到春日大社。\n1/4來初詣的人潮還是蠻多的。 買了一個鹿造型的籤。 東大寺三月堂 # 參拜結束後，就順便來觀光，一路走到東大寺這邊。 東大寺二月堂 # 剛好看到有人在寫生。\n東大寺鐘樓 # 這個鐘超大的! 東大寺 # 奈良公園 # 太多人在餵仙貝，鹿都不吃了。 興福寺 # 奈良東向通店 # 然後就一路走回商店街，買了中古堂的艾草麻糬。 找了間叫做文楽的店吃午餐，味道還行。 奈良限定鑰匙圈入手！ ","date":"2025年1月4日","externalUrl":null,"permalink":"/daily-notes/japan-life/japanese-new-year-visit/","section":"Daily-Notes","summary":"","title":"奈良 | 日本新年參拜紀錄","type":"daily-notes"},{"content":"","date":"2025年1月4日","externalUrl":null,"permalink":"/tags/%E5%A5%88%E8%89%AF%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"奈良旅遊","type":"tags"},{"content":"","date":"2025年1月4日","externalUrl":null,"permalink":"/tags/%E6%97%A5%E6%9C%AC%E6%B4%BB%E5%8B%95/","section":"Tags","summary":"","title":"日本活動","type":"tags"},{"content":"這天與朋友相約在本願寺跨年，在日本比較少像台灣會這樣放煙火慶祝。大部分日本人會選擇前往寺廟或神社參拜，迎接新的一年。12月31日在日本被稱為大晦日，這天晚上許多寺廟會舉行除夜の鐘活動，敲響108下鐘聲，象徵去除人們一年的煩惱與不安，並祈求新的一年平安順利。\n難波駅 # 約在難波站集合，這天一路上都非常熱鬧，我們就一路走路前往本願寺。 本願寺津村別院（北御堂） # 抵達時已接近晚上11點，敲鐘的整理卷是22:15開始發放，還好還有拿到。 不過是拿到H排的整理卷，應該是蠻後面的。 除夜會 # 除夜の鐘 # 除夜會結束後，所有人就到廣場，等待住持敲響108下鐘聲。 跨年倒數 # 接近0點的時候，階梯上出現投影開始倒數。\n2025新年快樂！ 敲鐘體驗 # 接著會讓有領取整理卷的人，依照上面的字母編號A開始依序上去敲鐘。\n12點過後的日本街道 # 我們每個人都敲完中後就離開本願寺了，沿路走路回去，已經12點多都沒有電車了。 跨年敲鐘12點過後左右的心齋橋還是非常多人。 ラウンドワンスタジアム 千日前店 # 因為朋友都住比較遠，半夜之後就沒有電車能回去了。 所以決定找個能待到早上的地方，發現 Round One 有有跨年活動， 到早上9點之前都可以用裡面的設施，就決定去那邊等到有首班電車了。\n到早上9點前，只要憑卷都可以無限出入，中間想去外面也可以。 非常多設施可以玩，還有漫畫跟卡拉OK。 然後我們就一路待到早上5點有首班車才離開，好久沒有通宵了。\n","date":"2025年1月1日","externalUrl":null,"permalink":"/daily-notes/japan-life/japanese-new-year/","section":"Daily-Notes","summary":"","title":"大阪 | 日本跨年紀錄","type":"daily-notes"},{"content":"","date":"2025年1月1日","externalUrl":null,"permalink":"/tech-articles/","section":"技術文章","summary":"","title":"技術文章","type":"page"},{"content":" 問題 # leetcode 1047 - Remove All Adjacent Duplicates In String(問題の詳細はリンクをクリック)\nExample 1:\nInput: s = \u0026ldquo;abbaca\u0026rdquo;\nOutput: \u0026ldquo;ca\u0026rdquo;\n説明: 例えば、\u0026ldquo;abbaca\u0026quot;では、隣接する文字が同じ\u0026quot;bb\u0026quot;を削除できます。これが唯一の可能な操作です。\nこの操作の結果、文字列は\u0026quot;aaca\u0026quot;となり、そこからさらに\u0026quot;aa\u0026quot;を削除できるので、最終的な文字列は\u0026quot;ca\u0026quot;となります。\nExample 2:\nInput: s = \u0026ldquo;azxxzy\u0026rdquo;\nOutput: \u0026ldquo;ay\u0026rdquo;\n解法のアプローチ # 入力は文字列で、出力は隣接する重複文字を削除した後の文字列です。\nこの問題は2つのポインタを使用して実装できます。\n以下の例で説明します：\niとjという2つのポインタを使用し、iは新しい文字を走査するポインタ、jは条件判定と解答の検索に使用します。\ni -\u0026gt;\nabbaca\nj -\u0026gt;\naabbaca\n同時に前進して上書きし、jの現在位置とj-1の位置に重複する隣接文字がある場合、jはその位置から-2（この2つの重複文字を削除）します。\ni -\u0026gt;\nabbbbaca\nj \u0026lt;- (-2)\nabbaca\njは位置0に戻ります\nabbaca\n引き続き同時に上書きを続けます\ni -\u0026gt;\nabbaca\nj -\u0026gt;\naabaca\nこの時点でj、j-1の位置が再び重複するため、jは-1の位置に戻ります\nj\naabaca\n上書きを続けます\ni-\u0026gt;\nabbaca\nj -\u0026gt;\ncabaca\n2つのポインタは、iが最後の位置に到達するまで同時に前進し続けます\ni\nabbaca\nj\ncabaca\n完全なコード # class Solution { public String removeDuplicates(String s) { int j=0; // ポインタjの初期化 char[] res = s.toCharArray(); // 文字列を文字配列に変換 for(int i=0;i\u0026lt;s.length();++i,++j){ // 文字配列を走査 res[j] = res[i]; // 現在の文字をj位置に代入 if(j\u0026gt;0 \u0026amp;\u0026amp; res[j]==res[j-1]){ // 現在の文字と前の文字が同じ場合 j-=2; // jポインタを2つ戻す } } return new String(res,0,j); // 重複を削除した文字列を返す } } スタックを使用した解法 # 実は最初の直感としてスタックを使用して解くことを考えました。\nLIFO（Last In First Out）の仕組みを利用して、各文字をスタックに入れて比較します。\n毎回、隣接する2つの値が一致するかどうかを確認します：\n1.スタックに入れる値\n2.スタック内の一番上の値\nStack : ab\nPut in : baca\n同じ場合はスタックからpopし、異なる場合は入れて比較を続けます。\n終了後、重複を削除した文字のスタックが得られ、それを文字列に変換すれば答えとなります。\nclass Solution { public String removeDuplicates(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // スタックの初期化 char[] chars = s.toCharArray(); // 文字列を文字配列に変換 for(char c : chars){ // 文字配列を走査 if(!stack.isEmpty() \u0026amp;\u0026amp; stack.peek() == c){ // スタックが空でなく、スタックトップの文字が現在の文字と同じ場合 stack.pop(); // スタックトップの文字を削除 }else { stack.push(c); // そうでない場合、現在の文字をスタックに追加 } } StringBuilder result = new StringBuilder(); // 結果文字列の初期化 for (char c : stack) { // スタックを走査 result.append(c); // 文字を結果文字列に追加 } return result.toString(); // 結果文字列を返す } } ","date":"2024年12月30日","externalUrl":null,"permalink":"/ja/posts/leetcode/easy/leetcode1047/","section":"Posts","summary":"","title":"leetcode 1047 - Remove All Adjacent Duplicates In String","type":"posts"},{"content":" 題目 # leetcode 1047 - Remove All Adjacent Duplicates In String(題目說明請點連結)\nExample 1:\nInput: s = \u0026ldquo;abbaca\u0026rdquo;\nOutput: \u0026ldquo;ca\u0026rdquo;\nExplanation: For example, in \u0026ldquo;abbaca\u0026rdquo; we could remove \u0026ldquo;bb\u0026rdquo; since the letters are adjacent and equal, and this is the only possible move.\nThe result of this move is that the string is \u0026ldquo;aaca\u0026rdquo;, of which only \u0026ldquo;aa\u0026rdquo; is possible, so the final string is \u0026ldquo;ca\u0026rdquo;.\nExample 2:\nInput: s = \u0026ldquo;azxxzy\u0026rdquo;\nOutput: \u0026ldquo;ay\u0026rdquo;\n解題思路 # 輸入為一個字串，輸入為一個去除相鄰重複字元後的字串。\n這題可以用Two pointors 的解法去實作。\n以下面為例子：\n分別用i、j二個指針，i為遍歷新字元的指針，j為判斷條件與搜索的答案。\ni -\u0026gt;\nabbaca\nj -\u0026gt;\naabbaca\n同時前進覆蓋，只要遇到j當前位置與j-1的位置有重複相鄰位置，j就往其位置-2(去除此二個重複的字元)，\ni -\u0026gt;\nabbbbaca\nj \u0026lt;- (-2)\nabbaca\nj退回到0這個位置\nabbaca\n繼續同時往下覆蓋\ni -\u0026gt;\nabbaca\nj -\u0026gt;\naabaca\n此時j、j-1位置又重複，j退回到-1這個位置\nj\naabaca\n繼續覆蓋\ni-\u0026gt;\nabbaca\nj -\u0026gt;\ncabaca\n二指針就繼續同時前進直到i跑到最後一個位置\ni\nabbaca\nj\ncabaca\n完整程式碼 # class Solution { public String removeDuplicates(String s) { int j=0; // 初始化指針 j char[] res = s.toCharArray(); // 將字串轉換為字符數組 for(int i=0;i\u0026lt;s.length();++i,++j){ // 遍歷字符數組 res[j] = res[i]; // 將當前字符賦值給 j 指針位置 if(j\u0026gt;0 \u0026amp;\u0026amp; res[j]==res[j-1]){ // 如果當前字符和前一個字符相同 j-=2; // j 指針回退兩步 } } return new String(res,0,j); // 返回去重後的字串 } } Stack解法 # 其實最一開始的直覺是想到用 stack 去解這道題，\n運用LIFO(Last In First Out)到機制，把給個字元分別放到Stack去做比較，\n每次就檢查相鄰的二個值是否一致;\n1.要放進Stack的值\n2.Stack中最上面的那個值\nStack : ab\nPut in : baca\n相同就Stock pop出去，不相同就放進去繼續比較。\n結束後就能拿到去除重複的字元Stack，在組成字串即為答案。\nclass Solution { public String removeDuplicates(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 初始化一個棧 char[] chars = s.toCharArray(); // 將字串轉換為字符數組 for(char c : chars){ // 遍歷字符數組 if(!stack.isEmpty() \u0026amp;\u0026amp; stack.peek() == c){ // 如果棧不為空且棧頂字符與當前字符相同 stack.pop(); // 彈出棧頂字符 }else { stack.push(c); // 否則將當前字符壓入棧 } } StringBuilder result = new StringBuilder(); // 初始化結果字串 for (char c : stack) { // 遍歷棧 result.append(c); // 將字符添加到結果字串 } return result.toString(); // 返回結果字串 } } ","date":"2024年12月30日","externalUrl":null,"permalink":"/tech-articles/leetcode/easy/leetcode1047/","section":"技術文章","summary":"","title":"leetcode 1047 - Remove All Adjacent Duplicates In String","type":"tech-articles"},{"content":" 問題 # leetcode 1062 - Longest Repeating Substring(問題の詳細はリンクをクリックしてください)\n例1:\n入力: \u0026ldquo;abcd\u0026rdquo;\n出力: 0\n説明: 繰り返される部分文字列はありません。\n例2:\n入力: \u0026ldquo;abbaba\u0026rdquo;\n出力: 2\n説明: 最長の繰り返し部分文字列は\u0026quot;ab\u0026quot;と\u0026quot;ba\u0026quot;で、それぞれ2回出現します。\n例3:\n入力: \u0026ldquo;aabcaabdaab\u0026rdquo;\n出力: 3\n説明: 最長の繰り返し部分文字列は\u0026quot;aab\u0026quot;で、3回出現します。\n例4:\n入力: \u0026ldquo;aaaaa\u0026rdquo;\n出力: 4\n説明: 最長の繰り返し部分文字列は\u0026quot;aaaa\u0026quot;で、2回出現します。\n解法 # 入力は文字列で、出力は文字列内で最も多く繰り返される部分文字列の長さです。\nこの問題は順序区間と単調性の特性を利用して解くことができます：\n入力文字列を S = \u0026ldquo;aabcaabdaab\u0026rdquo; とした場合、異なる部分文字列の長さに対して重複があるかどうかを確認します。\n部分文字列の長さと重複性： 部分文字列の長さ L (aabcaabdaab)\nL 重複の有無 重複部分 1 あり \u0026ldquo;a\u0026quot;のような単一文字が複数回 2 あり \u0026ldquo;aa\u0026quot;や\u0026quot;ab\u0026quot;が重複 3 あり \u0026ldquo;aab\u0026quot;が重複 4 なし 長さ4の重複する部分文字列なし 5 なし 長さ5の重複する部分文字列なし 6 なし 長さ6の重複する部分文字列なし 順序区間：1から6（部分文字列の長さ）は順序付けられており、重複の有無は規則に従います。\n単調性：\nL≤3の場合、重複する部分文字列が存在します。\nL≥4の場合、重複する部分文字列は存在しません。\n二分探索を使用してこの順序配列の中から最大の重複する長さを見つけ、\n別のメソッドでHashSetを使用して重複値の有無を判定します。\n完全なコード # class Solution { public int longestRepeatingSubstring(String s) { int left = 1, right = s.length(); while(left \u0026lt; right) { int mid = left + (right - left + 1) / 2; if(hasRepeatingSubstring(s, mid)) { left = mid ; }else { right = mid -1; } } return left; } public boolean hasRepeatingSubstring(String s,int length) { HashSet\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt;= s.length()-length; i++) { if(set.contains(s.substring(i,i+length))) { return true; }else{ set.add(s.substring(i,i+length)); } } return false; } } ","date":"2024年12月30日","externalUrl":null,"permalink":"/ja/posts/leetcode/medium/leetcode1062/","section":"Posts","summary":"","title":"leetcode 1062 - Longest Repeating Substring","type":"posts"},{"content":" 題目 # leetcode 1062 - Longest Repeating Substring(題目說明請點連結)\nExample 1:\nInput: \u0026ldquo;abcd\u0026rdquo;\nOutput: 0\nExplanation: There is no repeating substring.\nExample 2:\nInput: \u0026ldquo;abbaba\u0026rdquo;\nOutput: 2\nExplanation: The longest repeating substrings are \u0026ldquo;ab\u0026rdquo; and \u0026ldquo;ba\u0026rdquo;, each of which occurs twice.\nExample 3:\nInput: \u0026ldquo;aabcaabdaab\u0026rdquo;\nOutput: 3\nExplanation: The longest repeating substring is \u0026ldquo;aab\u0026rdquo;, which occurs 3 times.\nExample 4:\nInput: \u0026ldquo;aaaaa\u0026rdquo;\nOutput: 4\nExplanation: The longest repeating substring is \u0026ldquo;aaaa\u0026rdquo;, which occurs twice.\n解題思路 # 輸入為一個字串，輸出為字串內重複最多的子字串的次數。\n這題的思路可以利用有序區間和單調性特性：\n假設輸入字符串為 S = \u0026ldquo;aabcaabdaab\u0026rdquo;，我們嘗試檢查不同的子串長度是否有重複。\n子串長度和重複性： 子串長度 𝐿 (aabcaabdaab)\nL 是否有重複子串 重複部分 1 有 單字符如 \u0026ldquo;a\u0026rdquo; 重複多次 2 有 如 \u0026ldquo;aa\u0026rdquo; 或 \u0026ldquo;ab\u0026rdquo; 重複 3 有 如 \u0026ldquo;aab\u0026rdquo; 重複 4 無 沒有重複長度 4 的子串 5 無 沒有重複長度 5 的子串 6 無 沒有重複長度 6 的子串 有序區間：從 1 到 6（子串長度）是有序的，因為是否有重複子串隨著長度變化而遵守規律。\n單調性：\n當 𝐿≤3 時，存在重複子串。\n當 L≥4 時，不存在重複子串。\n透過 Binary search 在這個有序陣列當中找到最大重複的那個數字，\n並寫另外寫一個方法用HashSet來判斷是否有重複值。\n完整程式碼 # class Solution { public int longestRepeatingSubstring(String s) { int left = 1, right = s.length(); while(left \u0026lt; right) { int mid = left + (right - left + 1) / 2; if(hasRepeatingSubstring(s, mid)) { left = mid ; }else { right = mid -1; } } return left; } public boolean hasRepeatingSubstring(String s,int length) { HashSet\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt;= s.length()-length; i++) { if(set.contains(s.substring(i,i+length))) { return true; }else{ set.add(s.substring(i,i+length)); } } return false; } } ","date":"2024年12月30日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode1062/","section":"技術文章","summary":"","title":"leetcode 1062 - Longest Repeating Substring","type":"tech-articles"},{"content":" 題目 # leetcode 26 - Remove Duplicates from Sorted Array\nExample 1:\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n解題思路 # 輸入為一個排序好的陣列，將nums陣列內容的前k的去除重複的數字由小到大排出。\n首先初始化二個index作為比較的指針i、j，\ni為到結束前作為遍歷指針直到最後一項結束，\nj為判斷有是否有新的重複指針，就會將j所在的直放到該位置，\n因為是排序好的陣列，只要與j位置陣列，判斷有相異就放上新的內容\nStep 1 : i index 從1開始，因為第一個數字不管有沒有重複第0位置的值都不會改變，與前一個數字相比(j-1)的值相同所以不做任何事，i繼續往下一個遍歷。\n[0,0,1,1,1,2,2,3,3,4]\ni\nj\n[0,_,_,_,_,_,_,_,_,_]\nStep 2 : i=2 ，與前一個數字相比(j-1)的值有相異所以，將i位置的直放入j，此時j的位置也跟著i同時往下+1。\n[0,0,1,1,1,2,2,3,3,4]\ni\nj\n[0,1,_,_,_,_,_,_,_,_]\nStep 3 : i=3 ，與前一個數字相比(j-1)的值相同所以不做任何事，i繼續往下一個遍歷。\n[0,0,1,1,1,2,2,3,3,4]\ni\nj\n[0,1,_,_,_,_,_,_,_,_]\nStep 4 : 直到i都遍歷完成會得到一個前K的相異數字排序好的陣列\n[0,1,2,3,4,2,2,3,3,4]\nFunction 只要回傳相異的K即可。\n完整程式碼 # class Solution { public int removeDuplicates(int[] nums) { int j = 1; // 初始化第二個指針 for (int i = 1; i \u0026lt; nums.length; i++) { // 從第二個元素開始 if (nums[i] != nums[j - 1]) { // 如果當前元素不是重複的 nums[j] = nums[i]; // 將其移動到數組的下一個位置 j++; // 增加第二個指針 } } return j; // 返回沒有重複元素的數組長度 } } ","date":"2024年12月30日","externalUrl":null,"permalink":"/tech-articles/leetcode/easy/leetcode26/","section":"技術文章","summary":"","title":"leetcode 26 - Remove Duplicates from Sorted Array","type":"tech-articles"},{"content":" 問題 # leetcode 26 - Remove Duplicates from Sorted Array\nExample 1:\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\n説明: 関数は k = 2 を返し、配列の最初の2つの要素は1と2になります。\n返された k 以降の要素は何でもよいため、アンダースコアで表しています。\nExample 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\n説明: 関数は k = 5 を返し、配列の最初の5つの要素は0, 1, 2, 3, 4になります。\n返された k 以降の要素は何でもよいため、アンダースコアで表しています。\n解法のアプローチ # 入力はソート済みの配列で、nums配列の先頭k個の要素を重複なしで昇順に並べ替えます。\nまず、比較用の2つのインデックスiとjを初期化します。\niは配列の最後まで走査するポインタとして機能し、\njは新しい重複のない要素を配置するポインタとして機能します。\n配列はソート済みなので、j位置の配列と比較して異なる値が見つかった場合、その値を新しい位置に配置します。\nStep 1: インデックスiは1から開始します。最初の数字は重複に関係なく0番目の位置は変更されません。前の数字（j-1）と比較して同じなので何もせず、iは次の要素に進みます。\n[0,0,1,1,1,2,2,3,3,4]\ni\nj\n[0,_,_,_,_,_,_,_,_,_]\nStep 2: i=2の位置で、前の数字（j-1）と比較して異なるため、i位置の値をj位置に配置し、jもiと共に1つ進みます。\n[0,0,1,1,1,2,2,3,3,4]\ni\nj\n[0,1,_,_,_,_,_,_,_,_]\nStep 3: i=3の位置で、前の数字（j-1）と比較して同じなので何もせず、iは次の要素に進みます。\n[0,0,1,1,1,2,2,3,3,4]\ni\nj\n[0,1,_,_,_,_,_,_,_,_]\nStep 4: iが配列を完全に走査し終わると、先頭K個の要素が重複なく昇順に並んだ配列が得られます。\n[0,1,2,3,4,2,2,3,3,4]\n関数は重複のないK要素の数を返します。\n完全なコード # class Solution { public int removeDuplicates(int[] nums) { int j = 1; // 2番目のポインタを初期化 for (int i = 1; i \u0026lt; nums.length; i++) { // 2番目の要素から開始 if (nums[i] != nums[j - 1]) { // 現在の要素が重複していない場合 nums[j] = nums[i]; // 新しい位置に要素を移動 j++; // 2番目のポインタを進める } } return j; // 重複のない配列の長さを返す } } ","date":"2024年12月30日","externalUrl":null,"permalink":"/ja/posts/leetcode/easy/leetcode26/","section":"Posts","summary":"","title":"leetcode 26 - Remove Duplicates from Sorted Array ","type":"posts"},{"content":" 問題 # leetcode 344 - Rrevese String(問題の詳細はリンクをクリック)\nExample 1:\nInput: s = [\u0026ldquo;h\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;o\u0026rdquo;]\nOutput: [\u0026ldquo;o\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;h\u0026rdquo;]\nExample 2:\nInput: s = [\u0026ldquo;H\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;h\u0026rdquo;]\nOutput: [\u0026ldquo;h\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;H\u0026rdquo;]\n解法のアプローチ # 入力は配列で、出力はその内容を反転させた配列です。この過程で追加のメモリ空間を使用してはいけません。\nインデックスiを0、jを配列の長さ-1に設定します。\nループを繰り返すごとにiは増加し、jは減少します。終了条件はi\u0026gt;jとなった時、つまり中央で交換が完了した時です。\n完全なコード # class Solution { public char[] reverseString(char[] s) { // 初期化 int i = 0; int j = s.length-1; while(i\u0026lt;j){ char tmp = s[i]; s[i] = s[j]; s[j] = tmp; i++; j--; } return s; } } ","date":"2024年12月30日","externalUrl":null,"permalink":"/ja/posts/leetcode/easy/leetcode334/","section":"Posts","summary":"","title":"leetcode 344 - Rrevese String","type":"posts"},{"content":" 題目 # leetcode 344 - Reverse String(題目說明請點連結)\nExample 1:\nInput: s = [\u0026ldquo;h\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;o\u0026rdquo;]\nOutput: [\u0026ldquo;o\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;h\u0026rdquo;]\nExample 2:\nInput: s = [\u0026ldquo;H\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;h\u0026rdquo;]\nOutput: [\u0026ldquo;h\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;H\u0026rdquo;]\n解題思路 # 輸入為一個陣列，輸入為一個反方向陣列的內容，過程中不能建立額外的空間。\n給定index i為0、j陣列長度-1。\n隨著迴圈次數，i逐漸遞增，j逐漸遞減，中止條件當i\u0026gt;j，也就是到中間時交換完畢。\n完整程式碼 # class Solution { public char[] reverseString(char[] s) { // initialize int i = 0; int j = s.length-1; while(i\u0026lt;j){ char tmp = s[i]; s[i] = s[j]; s[j] = tmp; i++; j--; } return s; } } ","date":"2024年12月30日","externalUrl":null,"permalink":"/tech-articles/leetcode/easy/leetcode334/","section":"技術文章","summary":"","title":"leetcode 344 - Rrevese String","type":"tech-articles"},{"content":" 問題 # leetcode 42 - Trapping Rain Water (問題の詳細はリンクをクリックしてください)\n例1:\n入力: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n出力: 6\n説明: 上記の高度マップ（黒い部分）は配列[0,1,0,2,1,0,1,3,2,1,2,1]で表されます。\nこの場合、6単位の雨水（青い部分）が溜まります。\n例2:\n入力: height = [4,2,0,3,2,5]\n出力: 9\n解法 # 入力として与えられた壁の高さの配列から、図のように溜まる総水量を計算します。\nこの問題は双方向ポインタの概念を使用し、leftとrightの位置をそれぞれ記録します。 水は低い方に流れるため、maxLeftとmaxRightで両側のポインタが外から内側に向かう最高位置を記録し、\n各位置で両側の最高高さから現在の高さを引くことで、その位置での貯水量が得られます。 例として、\nleftがその位置に来た時：\n現在の貯水量は maxLeft - current、つまり記録された1 - 現在の高さ0 = 1\nrightがその位置に来た時：\n現在の貯水量は maxLeft - current、つまり記録された2 - 現在の高さ1 = 1 最後にleftとrightが出会うとプログラムが終了し、総水量を出力します。 完全なコード # class Solution { public int trap(int[] height) { int left = 0,right = height.length -1; int maxLeft = height[left],maxRight = height[right]; int water = 0; while(left\u0026lt;right){ if(maxLeft\u0026lt;maxRight){ left++; maxLeft = Math.max(maxLeft,height[left]); water+=maxLeft - height[left]; }else{ right--; maxRight = Math.max(maxRight,height[right]); water+=maxRight - height[right]; } } return water; } } ","date":"2024年12月30日","externalUrl":null,"permalink":"/ja/posts/leetcode/hard/leetcode42/","section":"Posts","summary":"","title":"leetcode 42 - Trapping Rain Water","type":"posts"},{"content":" 題目 # leetcode 42 - Trapping Rain Water (題目說明請點連結)\nExample 1:\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1].\nIn this case, 6 units of rain water (blue section) are being trapped.\nExample 2:\nInput: height = [4,2,0,3,2,5]\nOutput: 9\n解題思路 # 輸入給定一個牆壁高度的陣列如上圖所示，算出此牆面能累積的總水量。\n此題能使用雙向指針的概念，分別紀錄left與right的位置。 因為水往低處流，分別以maxLeft 與 maxRight 紀錄二側指針由外向內的最高位\n置，每走到一個地方就由二側的最高高度-當前高度，即會得該處的蓄水量。 以圖例為例，\n當left走到該處:\n當前蓄水量為 maxLeft - current，也就是之前紀錄的1 - 當前的高0 = 1\n當right走到該處:\n當前蓄水量為 maxLeft - current，也就是之前紀錄的2 - 當前的高1 = 1 最後left與right 相會結束程式，輸出總水量即可 完整程式碼 # class Solution { public int trap(int[] height) { int left = 0,right = height.length -1; int maxLeft = height[left],maxRight = height[right]; int water = 0; while(left\u0026lt;right){ if(maxLeft\u0026lt;maxRight){ left++; maxLeft = Math.max(maxLeft,height[left]); water+=maxLeft - height[left]; }else{ right--; maxRight = Math.max(maxRight,height[right]); water+=maxRight - height[right]; } } return water; } } ","date":"2024年12月30日","externalUrl":null,"permalink":"/tech-articles/leetcode/hard/leetcode42/","section":"技術文章","summary":"","title":"leetcode 42 - Trapping Rain Water","type":"tech-articles"},{"content":" 問題 # leetcode 80 - Remove Duplicates from Sorted Array II (問題の詳細はリンクをクリックしてください)\n例1:\n入力: nums = [1,1,1,2,2,3] 出力: 5, nums = [1,1,2,2,3,_] 説明: 関数は k = 5 を返し、配列の最初の5つの要素は1、1、2、2、3となります。 返された k 以降の要素は何でもよいため、アンダースコアで表しています。\n例2:\n入力: nums = [0,0,1,1,1,1,2,3,3] 出力: 7, nums = [0,0,1,1,2,3,3,,] 説明: 関数は k = 7 を返し、配列の最初の7つの要素は0、0、1、1、2、3、3となります。 返された k 以降の要素は何でもよいため、アンダースコアで表しています。\n解法 # この問題は leetcode 26 の変形で、同じくTwo Pointersの方法で解くことができます。出力配列は、最初のK個のソートされた数字で、2回以上の重複を許可しません。\nこの問題のアプローチは26と同様で、iとjをそれぞれ走査と置換のポインタとして指定します。2回以上の重複を許可するため、インデックスは2から開始します。 iは走査を実行し、現在のデータがj-2の位置にある値と異なる場合に置換を行います。 入力は既にソートされているため、最初の2つの数字は置換する必要はありません。\n最初の置換判定が発生した時、iの位置は2で、j-2の位置にある値1と一致しないため、最初の置換を行います。 この時点で nums = [1,1,2,2,2,3]\n最後の置換まで実行すると、nums = [1,1,2,2,3,3] が得られます。\n完全なコード # class Solution { public int removeDuplicates(int[] nums) { int j = 2; for (int i = 2; i \u0026lt; nums.length; i++) { if (nums[i] != nums[j - 2]) { nums[j] = nums[i]; j++; } } return j; } } ","date":"2024年12月30日","externalUrl":null,"permalink":"/ja/posts/leetcode/medium/leetcode80/","section":"Posts","summary":"","title":"leetcode 80 - Remove Duplicates from Sorted Array II","type":"posts"},{"content":" 題目 # leetcode 80 - Remove Duplicates from Sorted Array II (題目說明請點連結)\nExample 1:\nInput: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3,_] Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\nInput: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3,,] Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores).\n解題思路 # 此題為 leetcode 26 的變形，一樣能用Two pointor的方式去解，輸出的陣列為，前K的排序好的數字且不能重複二次以上。\n此題思路我們採取與26相同，指定i、j分別為遍歷跟取代的指針，因為是重複二次以上，所以index以2為開始點， i會執行遍歷，直到遇到當前資料與j-2所在位置不同時進行覆蓋， 因為輸入已是排序好的，最前面的二個數字不用進行覆蓋。\n當發生第一次判斷交換點，此時i所在的直為2，與j-2所在的值1不一致，進行第一次的交換。 此時 nums = [1,1,2,2,2,3]\n直到執行到最後一次覆蓋，得到nums = [1,1,2,2,3,3]\n完整程式碼 # class Solution { public int removeDuplicates(int[] nums) { int j = 2; for (int i = 2; i \u0026lt; nums.length; i++) { if (nums[i] != nums[j - 2]) { nums[j] = nums[i]; j++; } } return j; } } ","date":"2024年12月30日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode80/","section":"技術文章","summary":"","title":"leetcode 80 - Remove Duplicates from Sorted Array II","type":"tech-articles"},{"content":"","date":"2024年12月30日","externalUrl":null,"permalink":"/ja/tags/two-pointers-problem/","section":"Tags","summary":"","title":"Two Pointers Problem","type":"tags"},{"content":" Day 1 # 大阪出發 - 名門大洋フェリー # 搭乘晚上7:50分的渡輪從大阪出發，在船上住一晚，早上醒來就會到門司港了。 從大阪市區搭地鐵到渡船大樓(フェリーターミナル)站，走路5分鐘就會到大阪南港的乘船點。 船舶介紹 # 事先在網路上訂票，或是現場買票也可以，但是建議如果想要有個室的話，還是先預訂比較好，現場都只剩開放式的那種，只有簾子拉起來。 船上設施還蠻多的，除了淋浴間還有展望浴室，能邊欣賞海景邊泡澡。基本上就跟飯店差不多，只是廁所跟浴室都在外面而已。\n船內設施 # 登船 船內大廳 個室 預約的時候都只剩單人個室了，還蠻多家庭跟情侶來的，雙人房以上的房間數量並不多。 單人房大概長這樣，簡單的床、電視、書桌、洗手台。 電視能看的頻道不多，而且船如果離陸地太遠畫面訊號會不太好，然後有頻道能看船行進中所在位置。 娛樂間 販賣部、販賣機\n大廳櫃檯旁邊就是販賣部，避免拍到人就沒拍了，圖為官網照片。 基本上販賣部、販賣機賣的東西都比外面貴，可以先在外面買好再帶進來。 展望浴室、淋浴間 淋浴間與澡堂都在7樓。 外面會寫著目前入浴中的人數。 避免拍到人就沒拍了，圖為官網照片。 餐廳 船上有餐廳是要另外付費的，2000日圓我覺得有點貴，可以吃飽再來或自己外帶便當過來。 船外看台 # 有寫每個橋預計會通過的時段，時間差不多的時候可以出來看 明石海峽大橋 # 瀨戶大橋 # Day 2 # 前一天其實沒有睡得很好，畢竟在船上還是會晃，出來甲板看看早上的風景。\n門司港駅 # 到改港口後有免費的接駁車，可以做到門司港站。 藍翼橋 # 剛好遇到開橋時間。 門司港懷舊展望室 # 可以看到整個門司港的景色，還能看到關門橋。 這裡的建築都有很特別的風格。 香蕉人像 # 午餐 - 世界にひとつだけの焼きカレー プリンセスピピ門司港 # 人非常多開店前10分鐘到先登記候位，在寒風中等了快一小時才入場。 點了めんたい焼きカレー，額外加點了炸雞， 就是味道還行的焗烤咖喱飯，我覺得沒有值得等那麼久。 小倉祇園 八坂神社 # 往小倉城的路上，沿路會經過八坂神社。 小倉城 # 小倉城在全部天守閣中`高度排第6`，最高的是大阪城，長知識了。 上去可以看到小倉市區的風景。 北九州河畔步行街 # 到飯店Check In前還有時間，就到小倉城旁邊的步行街逛逛。 旁邊有蠻多百貨的，正好是接近聖誕節。 而這個時候正好是ちいかわ一番賞開抽的時候，沒想到這個地方還有！就抽了三抽！ 1B 2D還算不錯，D賞能自己選，還好烏薩奇跟吉伊還有。 晚餐 - 小倉鉄なべ 総本店 # 來這邊了就來吃看看有名的鐵鍋煎餃，煎到非常脆，味道還不錯， 但肉餡不多都在吃皮的感覺，2人份要1500日幣，份量也不多其實不便宜。\nDay 3 # 博多駅 # 早上飯店Check Out後，從小倉站出發搭乘JR前往福岡博多站。 博多マルイ # Pokémon Center FUKUOKA # 福岡的寶可夢中心就位在博多在旁邊的百貨內。 ラブライブ！サンシャイン! Aqours CLUB 出張所 # 剛好是Aqours 9周年來博多展出的時間，不過水團後來就沒什麼在追了，但聲優都認識當初剛出來台灣辦Live也有去看，進來逛一下回憶湧上心頭。 午餐 - 博多水たき 濱田屋 くうてん # 來福岡一定要吃的就是這裡的雞肉，午餐選了一間水坎雞肉鍋，點了博多水炊きコース。\n東西是一道一道上來，柚子醋配上雞肉還蠻搭的。 結束後會把蛋跟飯加進去變成雜炊。 櫛田神社 # 午餐結束後前往櫛田神社，只有地鐵一站的距離，就用走的當作飯後散步。 牛頭都被摸到發亮了。 抽了張中吉籤。 伊都きんぐ 天神店 # 前往警固神社的路上，經過一間甜點店，點了草莓香草奶油銅鑼燒，非常好吃，但一顆不便宜含稅要658日幣。 後來又經過買了一顆培茶口味的來吃也很讚。 警固神社 # 然後就一路走到了警固神社。 福岡タワー # 下午在飯店Check In完行李後，就搭公車接著前往福岡塔，沿路會經過福岡PayPay巨蛋。\n福岡タワー南口站下車後走一小段路就會抵達。 上去的電梯是透明的，塔的外面都是玻璃窗戶。\n有卡片每個幾度都能集章。 福岡塔在日本排第3高，又長知識了。\n晚餐 - 元祖博多めんたい重 # 晚餐回來天神這邊吃，有名的明太子飯。 這間的沾麵好像也很有名，加上很餓就點了套餐飯麺セット。 麵條很Q彈，明太子沾麵湯很濃厚，飯配湯也很讚， 我覺得麵比飯還好吃，飯只有明太子跟海苔在上面稍嫌不足，還好有點飯麵的套餐。 天神中央公園 # 飯後來到天神中央公園，感受聖誕節的氣氛。\n福岡PARCO # 接著又跑到福岡PARCO，逛アニメイト跟ちいかわ，看有沒有福岡限定的周邊，都在這棟的8F。 Day 4 # 太宰府 # 早上從天神站搭西鐵福岡-西鐵天神大牟田線，在西鐵二日市站轉西鐵福岡-太宰府線，大概半小時左右就會到。\n太宰府駅 # 太宰府前表参道 # 梅枝餅 かさの家 # 有名的梅枝餅其實就是紅豆麻糬，還不錯吃不會太甜，有內用區。 太宰府天滿宮 # 同樣被摸到發亮的牛頭。 星巴克 # 這裡的星巴克造型好特別。 一蘭 太宰府參道店 # 這裡的一蘭拉麵比較特別是六角形的碗，麵的長度是59公分(取自日文合格ゴウカク的諧音)，`象徵祈求合格。 柳川 # 從太宰府站過來搭西鐵福岡-太宰府線，同樣在西鐵二日市站轉西鐵福岡-西鐵天神大牟田線就會到西鐵柳川站。 柳川運河 # 三柱神社 # kuyurucoffee # 當天真的走蠻多路的，就找了間咖啡廳稍作休息。 晚餐 - 博多シーフードうお田 # 柳川行程結束後回到了博多，找了一間有名的明太子丼飯店。 點了招牌的明太いくら卵焼き丼，味道還不錯明太子、鮭魚卵蠻新鮮的，還有一張貼紙。 博多運河城 # 吃完就到走到隔壁的博多運河城，欣賞欣賞聖誕節水舞表演。\n宵夜 - かわ屋 警固店 # 逛完有點餓了，來吃福岡有名的烤雞皮，外脆內Ｑ會讓人一串接著一串。 要結帳的時候，老闆會給收尾的雞湯。 Day 5 # 午餐 - めんたい料理 博多 椒房庵 # 最後一天在飯店待到快11點才出來，就直接去吃午餐了，找了間博多車站有名的明太子鯛魚丼飯。 選了一半炙燒的吃法，炙燒過後的明太子非常香。 一樣有著三吃的吃法，原味、加入蛋黃醬、做成茶泡飯，都非常好吃。 天神地下街 # 吃飽吃後來逛天神地下街，一樣有著聖誕節氣氛。\n其實大部分都是餐廳跟服飾店，從天神南站開始走，走到底會到ミーナ天神購物中心， 在 Seria 入手睡衣版本的吉伊卡哇。\n在 Gigo 獲得戰利品太陽伊布、月亮伊布。 真言宗 東長寺 # もち吉　博多本店 # 參觀完來旁邊稍作休息，點了豆皮麻糬，稻荷壽司的外皮裡面包麻糬，意外還不錯吃。 晚餐 - 博多一幸舍 # 最後以福岡的一幸舍拉麵當作收尾，豚骨的豬骨味道偏重，味道還行。 福岡機場 # 晚上搭國內線飛機回大阪，隨身行李差點超重。 結束了北九州的美食之旅。\n","date":"2024年12月19日","externalUrl":null,"permalink":"/daily-notes/japan-travel/kitakyushu-trip/","section":"Daily-Notes","summary":"","title":"北九州｜福岡、小倉、門司港 五天四夜自由行","type":"daily-notes"},{"content":" 交通方式 # 這一趟預計把京都的楓葉全部看過一遍，但因為京都賞楓的人潮一直都很可怕， 所以起了個大早從人朝最多的清水寺開始看起， 大阪市區搭首班地鐵到清水寺最快也要1小時50分，抵達時已接近7點。 清水寺 # 清水寺6點就開門了，7點左右到人潮外面的沒有想像中這麼多。 一入場才發現我錯了，清水寺的對面的賞楓舞台早已擠滿人。 清水寺舞台 # 實際走過來才知道人會什麼都擠在這裡了，真的很美！\n三重塔 # 走下來到三重塔的拍照地點。 八重塔 # 從清水坂一路走下來接到三年坂 沿路會看到八重塔，這裡是拍八重塔的好地點！ 早上這一路上都沒有什麼人，走起來很舒服。 八坂神社 # 一路走到八坂神社已經快8點，早已有來參拜的人。\n永觀堂 # 本來想進永觀堂看的，但是9點才開放，離入場還有一個小時，在外面拍拍照就走了。 真如堂 # 然後就沿路慢慢走到了真如堂，其實一路上都有楓葉，進來也接近9點開園的時間，不過已經提早開放給大家入場了。 這裡的楓葉都紅的差不多了！ 銀閣寺 # 早上最後的時間來銀閣寺這裡走走，楓葉雖然不多，但也蠻漂亮的。 午餐 - 麵屋優光 河原町 # 中午坐巴士回到了京都河原町附近，找了一間拉麵店當作午餐，有點餓點了スペシャルらーめん，肉多到滿出來，湯頭是貝類醬油湯底。 ちいかわもぐもぐ本舗 伏見店 # 下午預計去伏見稻荷走走，都來了一樣要去在旁邊的 ちいかわ 伏見店 這裡有伏見稻荷限定的商品！\n伏見稻荷大社 # 買完就沿著商店街走到了伏見稻荷大社。 抽了張吉籤。 拿出剛買的稻荷烏薩奇出來拍照🤣 下午茶 - THE Lower East Nine cafe -LE9- # 今天走一早就都在走路，下午決定來點輕鬆的行程，找個咖啡廳休息。 最後在太陽下山前就離開京都了。 ","date":"2024年12月9日","externalUrl":null,"permalink":"/daily-notes/japan-travel/kyoto-autumn-leaves/","section":"Daily-Notes","summary":"","title":"京都｜賞楓行","type":"daily-notes"},{"content":"","date":"2024年12月9日","externalUrl":null,"permalink":"/tags/%E4%BA%AC%E9%83%BD%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"京都旅遊","type":"tags"},{"content":" Day1 # 難波租車 # 一早跟大家約好在難波的日産レンタカー租車公司集合。 取我們未來二天要開的車。 第一次開在日本的高速公路上!\n天橋立 # 直接開了2個小時的車抵達天橋立。\n天橋立纜車 # 接著到了天橋立ビューランド リフト・モノレール山麓駅 搭纜車上去展望台，買了來回票。 不敢坐リフト的人，可以選坐モノレール 不過是來回的車廂，等待時間就比較久，我們同行的友人就不坐，敢坐的人就線上去展望台等了。 リフト 速度並不快，可以欣賞上山的風景。\n下山的時候風景比較美，可以看到剛剛我們剛剛逛的天橋立。\n天橋立展望台 # 抵達展望台後，可以看到整個天橋立的風景。\n午餐 - 龍宮そば # 午餐就找了天橋立附近的蕎麥麵，味道普通，隨便找的就沒有抱太大得期待。 伊根舟屋 # 吃完午餐便繼續開車前往伊根舟屋，附近停好車後直接下來逛。 有點難想像這裡還是京都🤣\n晚餐 - 焼鳥とジンギスカン 北の大地 # 接著我們就一路開到鳥取的飯店，抵達時已經是晚上7點， 各自先回飯店放行李後再出來吃飯，找了一間居酒屋餐廳。 其實我們沒有點很多，回程的路上就在超商買了一些東西回飯店吃， 看到ちいかわ出新的和菓子就買來吃了🤣 Day2 # 青山剛昌ふるさと館 # 都來鳥取了當然要去柯南作者的故鄉博物館！ 裡面非常多東西，非常值得一來！而且附近很好停車。\n館外拍照景點 # 館內設施 # 入場有送聖誕節的特典，拿到和葉跟平次。 今天我代班啦！ 柯南的滑板遊戲體驗。 每一年的劇場版海報。 小劇場動畫，不能錄影就只拍照了。 把門票放上去會有立體投影！ 還有解謎遊戲，回答完可以拿到一張認定証。\n走之前打了一顆紀念幣。 コナンの家 米花商店街 # 第二天時間有限，這裡拍拍照逛一下，就前往下一個景點了。\n鳥取砂丘 # 接著開車前往鳥取沙丘。\n這裡真得超遼闊，然後風超大超冷！ 上來之後會看到日本海。\n午餐 - 天下一品 # 附近沒有什麼吃的就選了間連鎖拉麵，豚骨拉麵加點了一塊雞皮，味道還不錯，中上水準的好吃。 神戸市 - 摩耶山 展望デッキ # 下午都在開車，因為要趕在租車公司關門前回到大阪， 結果到神戶的時候比預期的時間還早，臨時起意去看神戶的百萬夜景 - 摩耶山掬星台夜景。 在停車場停好車後，再走一小段山路後，抵達展望台。 最後回到大阪還完車後，就就地解散了，結束這二天一夜的行程。\n","date":"2024年12月4日","externalUrl":null,"permalink":"/daily-notes/japan-travel/tottori-kyoto-road-trip/","section":"Daily-Notes","summary":"","title":"鳥取、水之京都｜二天一夜自駕旅行","type":"daily-notes"},{"content":"","date":"2024年12月4日","externalUrl":null,"permalink":"/tags/%E9%B3%A5%E5%8F%96%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"鳥取旅遊","type":"tags"},{"content":" 交通方式 # 中午跟朋友約在京都車站碰面，從京都搭 JR 過去大概50分鐘。 午餐 - 京都車站 # 午餐在京都車站的美食街解決，找了一間叫 京だし茶漬け専門店 京都おぶや，點了招牌海鮮茶泡飯。 彥根城 # 彥根車站下車後，發現過去彥根城的巴士班次不多，索性用走的站前直直走1.5公里就會到。 附近的楓葉還沒完全紅透。 天守閣上的景色。 玄宮園 # 就位在彥根城的隔壁，雖然楓葉都還沒完全紅透，但是已經夠漂亮了。 ","date":"2024年12月2日","externalUrl":null,"permalink":"/daily-notes/japan-travel/shiga-hikone-castle/","section":"Daily-Notes","summary":"","title":"滋賀｜彥根城、玄宮園","type":"daily-notes"},{"content":"","date":"2024年12月2日","externalUrl":null,"permalink":"/tags/%E6%BB%8B%E8%B3%80%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"滋賀旅遊","type":"tags"},{"content":"沒錯今天是吉伊卡哇一番賞開抽的日子。 先說結果總計29抽有3個A賞算是蠻歐的，還好不用這張圖支援了🤣 10連抽的特典送的都是同一張桌布，所以抽過10連之後，其實單抽或是10連抽都可以。 一番賞結果 # 這邊是自己抽加上，幫朋友代抽，總計29抽，幫自己抽的是有拿到1A算還行。\n獎品配送 # 預計2025年2月下旬會開始寄送，要開始煩惱要怎麼把A賞寄回去台灣了😂\n","date":"2024年10月15日","externalUrl":null,"permalink":"/daily-notes/japan-life/usagi-ichiban-kuji/","section":"Daily-Notes","summary":"","title":"烏薩奇一番賞 開抽","type":"daily-notes"},{"content":"","date":"2024年9月30日","externalUrl":null,"permalink":"/tags/%E7%92%B0%E7%90%83%E6%94%BB%E7%95%A5/","section":"Tags","summary":"","title":"環球攻略","type":"tags"},{"content":" 交通方式 # 從大阪市區搭車的話，推薦從搭JR環狀線過去，從新今宮搭到西九条站轉JR櫻島線，到環球城站大概20分鐘就到了。 環球站一出來就是周圍的商店街、美食街，跟著人潮走就會走到大門口了。 門票資訊 # 一般購票 # 可以透過台灣購票網站(Klook、KKday)、或是環球官網購買，每天的票價與開園時間都不固定，建議先在官網查看。\n年票制度 # 販售的年票有二種，分別是グランロイヤル(Grand Royal)與スタンダード(Standard)，差別是在特定日期的除外日(約90天)是否能入場，價格也差了一倍多。 購買 Grand Royal 的年票主要享有的福利： 一年內不限時間次數入園 獲得該年グランロイヤル會員胸針 隔年續約年票享有折扣 能搶先購買特殊活動、期間限定票卷 園區內餐廳打9折 同行者打95折 (需在官網提前購票，最多五名) 生日月同行者打85折 (需在官網提前購票，最多五名) 官方停車場折扣 1000 日圓 購買/換票流程： 加入環球會員 選擇要購買得年票種類グランロイヤル(Grand Royal)或是スタンダード(Standard) 進入付款流程：線上刷卡/超商付款 領取方式：現場領取/宅配 這裡我選現場領取，會有一個領取的 QR Code，到現場給售票口的工作人員掃就能領到年票了。 快速通關券 # 如果只規劃一天，想要有一定要玩到的設施的話，這個部分建議在事先買好，因為當天9點入園的時候，現場販售的快速通關幾乎的沒了。 環球App # 這個 App 可以說是必載，很多功能都在裡面，主要就是拿來：\n查看地圖：園區真的很大，有即時定位功能用來找設施真的很方便，還能看每個設施的等待時間。 看活動表演時間 : 上面會寫當天活動表演的時間與地點。 抽特別區域(如瑪利歐園區)的入場卷: 要先登錄已購買的門票(上面的QR Code)，綁定後才能抽選 當天遊玩的設施 # 我們其實沒有玩太多設施，主要是看表演跟拍照而已，畢竟有買年票，一些固定的設施之後都可以再來玩。\n鬼滅の刃 XRライド ～刀鍛冶の里を疾走せよ～ # 一入園就搶先衝去這個設施，人還是很多，大概排1個半小時才排到。 遊玩體驗算還行吧，就是帶著VR頭盔，坐不會很刺激的雲霄飛車(只有左右晃的程度)，整個過程大概5分鐘而已。 進去前有個拍照的區域，結束出來的時候，有販賣部可以看拍出來的照片決定要不要另外買。 スーパーマリオ・ランド～ # 有手環的話可以玩裡面的金幣小遊戲。 - マリオカート ～クッパの挑戦状～ 這裡有個小插曲，就是女友玩的時候VR頭盔是沒有畫面的，事後跟工作人員反應，就讓我們二個不用排隊重新搭一次，我自己就跟著女友又多玩到一場。 表演節目 # 寶可夢遊行 # 剛好是萬聖節遊行的活動，蠻可愛蠻Ｑ的，穿那麼大件的布偶衣還這麼靈活，真的很強🤣\n小小兵遊行 # 剛入園就遇到小小兵在遊行，還能上去拍照。\n侏羅紀恐龍秀 # 經過的時候剛好看到，還蠻逼真的。\n萬聖節遊行 # 我們出來的時候剛好是萬聖節遊行接近尾聲，蠻歡樂的沒有嚇人的環節，大家都在跳舞🤣\n美食餐廳 # 我們真的在環球吃了不少東西，園區內餐廳年票還有打折，基本上餐點除了好拍照，味道也都還行，但就是貴了點🤣\n寶可夢萬聖節餐點 # 還蠻漂亮的很好拍照，不過味道就有點普通。 海賊王餐點 # 航海王的餐點意外蠻好吃的🤣 Shake Shack 環球影城店 # 這間在園區外就沒有9折了，我們玩到快關園才出來，基本上吃的都關了，看到 Shake Shack 還有開就決定來補充一下能量。 ","date":"2024年9月30日","externalUrl":null,"permalink":"/daily-notes/japan-travel/osaka-universal-studios/","section":"Daily-Notes","summary":"","title":"大阪｜環球影城","type":"daily-notes"},{"content":" 交通方式 # 從大阪市區搭車的話，可以搭乘大阪地鐵坂筋線，到山田站轉單軌列車到萬博紀念公園站，大概抓1小時左右的時間。 單軌列車 万博記念公園 # 一下來就會看到知名地標太陽の塔，真的沒有很好看，加上陰陰的天氣感覺怪陰森的😂 LaLaport EXPOCITY # 隔壁就是 LaLaport EXPOCITY 我們決定先去逛。 路上看到Dippin' Dots 冰淇淋 覺得很新奇就買來吃了，還蠻好吃的口感很特別。 接著就直衝柯南的快閃店　名探偵コナンラン，我們來的時候剛好是最後一天 9/29。 然後還剛好看到咒術迴戰的快閃店。\n接著下午快4點到美食街吃午晚餐，今天的作息很不正常🤣 OSAKA WHEEL オオサカホイール # LaLaport EXPOCITY 旁邊就是日本最高的摩天輪，想說都來了就上去坐看看。 轉一圈的時間是18分鐘，票價一人1000日幣，車廂是透明的，為了看夜景等到晚上才來坐。\n從上面可以看到整個萬博紀念公園，晚上會開燈。 摩天輪去跟回來的路上裝飾得蠻漂亮的很好拍照。 ","date":"2024年9月29日","externalUrl":null,"permalink":"/daily-notes/japan-travel/osaka-expo-commemorative-park/","section":"Daily-Notes","summary":"","title":"大阪｜萬博紀念公園 ＆ LaLaport EXPOCITY ","type":"daily-notes"},{"content":"在梅田ロフト4樓 期間限定展出，難得是自己跟女友以前都有看過的戀愛動畫，15周年記念特展就想說來參觀看看。\n門口展示 # 漫畫 # 畫展 # 渡狸、反ノ塚雕像 # 周邊紀念品區 # 展逛完最後面有個周邊紀念品區，女友忍不住買了一些東西🤣 ","date":"2024年9月28日","externalUrl":null,"permalink":"/daily-notes/japan-life/inu-x-boku-ss-exhibition/","section":"Daily-Notes","summary":"","title":"大阪 | 梅田ロフト 妖狐×僕SS・藤原ここあ 15周年記念展 ","type":"daily-notes"},{"content":" 預約餐廳 # 要去寶可夢咖啡廳建議一個月前就要預約了，而且幾乎都是開放的一個月前的秒滿。 平日的話可以賭看看現場入場。 寶可夢咖啡廳 # 等待的時間先在門口拍這二隻皮卡丘。 點了一份主餐、甜點、二杯飲料。\n表演活動 # 用餐到一半，皮卡丘會出來打招呼。\n離開前跟旁邊得客人打招呼打招呼🤣 ","date":"2024年9月27日","externalUrl":null,"permalink":"/daily-notes/japan-life/osaka-pokemon-cafe/","section":"Daily-Notes","summary":"","title":"大阪 | 心齋橋 PARCO 寶可夢咖啡廳 開箱","type":"daily-notes"},{"content":" 交通方式 # 從新今宮附近前往，需要轉三次車才會到。 渡月橋 # 從渡月橋一路往嵐山商店街的方向走\n午餐 - 嵐山よしむら 蕎麥麵 # 嵐山這裡的蕎麥麵名店，候位1小時才吃到，候位的時間可以去旁邊的嵐山商店街逛， 很多人都為了二樓的透明玻璃窗戶邊吃邊看外面風景，但運氣不好坐到沒靠窗的座位 吃的方面點了天ざる膳 2480日幣 蠻貴的，完全不值得，蕎麥麵也不好吃。\n嵐山商店街 # 這裡賣蠻多京都的伴手禮跟周邊，不過沒買什麼，只有因為天氣熱買了冰淇淋來吃。 竹林小徑 # 嵐山商店街一直往下走就會到竹林小徑，夏天過來人沒有到很多。 晚餐 - 京の焼肉処 弘 京都駅前店 # 晚餐回到京都，選了一間燒肉店，肉的品質還不錯。 京都塔 # 吃完晚餐就在京都車站附近逛，準備回大阪。 ","date":"2024年9月16日","externalUrl":null,"permalink":"/daily-notes/japan-travel/kyoto-arashiyama-day-trip/","section":"Daily-Notes","summary":"","title":"京都 | 嵐山一日遊","type":"daily-notes"},{"content":" 交通方式 # 去程直接搭JR從大阪梅田站到姬路站，差不多一小時就會到，回程同樣搭JR停靠神戶站下車，最後再回大阪。 姫路駅 # 到姬路站後出來旁邊就有公車站，大概搭10分鐘左右就會到姬路城 姫路城 # 公車到姬路城大手門前下車，然後就一路走到姫路城內。\n天守閣上的風景還蠻不錯的，只可惜天氣沒有到太好。 午餐 ーメン・ギョーザ 新生軒 # 從姫路城沿路慢慢走回車站，路上挑了一間拉麵店來吃。 算是清爽系的鹽味拉麵，味道還不錯。 神戸ハーバーランドumie # JR 神戶站下來旁邊就是，非常大的一間購物中心， 購入了 ちいかわ 姫路、神戶限定的鑰匙圈。 神戸ポートタワー # 一路逛下去就會走到神戶塔，再過去就是神戶港。 元町、南京町商店街 # 8月底的天氣還是太熱，下午就前往元町、南京町商店街隨處走走。 三宮神社 # 晚餐 - 神戸牛 炭火焼肉 石田屋 # 晚餐選了這裡神戸牛有名石田屋，選了 特上石田屋コース 7000日圓的套餐。 肉的品質不錯，不過還是吃不慣冷盤的生牛肉，量不多CP值不高嚐鮮即可。\n前菜 主餐 甜點 ","date":"2024年8月24日","externalUrl":null,"permalink":"/daily-notes/japan-travel/himeji-kobe-day-trip/","section":"Daily-Notes","summary":"","title":"姬路、神戶 | 一日遊","type":"daily-notes"},{"content":"","date":"2024年8月24日","externalUrl":null,"permalink":"/tags/%E5%A7%AC%E8%B7%AF%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"姬路旅遊","type":"tags"},{"content":"","date":"2024年8月24日","externalUrl":null,"permalink":"/tags/%E7%A5%9E%E6%88%B6%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"神戶旅遊","type":"tags"},{"content":"","date":"2024年8月20日","externalUrl":null,"permalink":"/tags/%E6%97%A5%E6%9C%AC%E8%87%AA%E7%94%B1%E8%A1%8C/","section":"Tags","summary":"","title":"日本自由行","type":"tags"},{"content":" Day 1 # 名古屋車站 # 早上8點從大阪搭乘 近鐵Hinotori 出發去名古屋，2個小時就到了 ，不過加特急卷要快5000日幣，有時間的搭高速巴士會比較便宜一些。 一到車站先去遊客中心購買犬山城的來回套票(1680日幣)，套票內容包含:\n犬山城門票 名鉄名古屋\u0026lt;-\u0026gt;犬山站/犬山遊園站來回車票各一張 有楽苑門票折扣卷 犬山城下町商店的折價卷 套票非常划算，光是來回車票+門票就超過套票的價格了。 午餐 - 飛騨牛一頭家 馬喰一代 # 午餐吃車站附近的飛騨牛一頭家 馬喰一代 名古屋WEST 套餐12000日幣，真的蠻貴的，不過想說來都來了就給他點下去。不過吃完的感想是嚐鮮一次就好，CP值不高。 前菜是飛騨牛的生肉盤口感蠻像在吃鮪魚的，最好吃的是壽司。 主餐是飛騨牛涮涮鍋跟牛舌肉盤。 肉片涮個8-10秒就起鍋了不想浪費這麼好的肉，真的是入口即化。\n甜點是咖啡香草冰淇淋。 犬山城下町 # 接著就搭 名古屋鉄道 從名古屋站出發去犬山城 在犬山站下車，走一小段路會到犬山城下町，計劃是一路逛上去到犬山城， 然後再從犬山遊園站搭回去名古屋站，這樣就不用走重複的路線。 針綱神社、三光稻荷神社 # 沿路會經過 針綱神社 與 三光稻荷神社 犬山城 # 然後就到了犬山城，要脫鞋入場，因為國寶城裡面都是木造的。 從最高樓看下去的景色非常遼闊。\n名古屋PARCO # 結束犬山城的行程就先去飯店check in，然後出來逛附近的 PARCO。 剛好是ちいかわラーメン豚期間販售的時間，但是沒事先做功課抽整理卷沒辦法入場QQ 不過可以逛 B1 ちいかわらんど，買名古屋限定的商品! 晚餐 - 矢場丼 矢場町本店 # 來名古屋一定要來吃矢場丼的創始店，在日本其他地方都會看到的味增豬排連鎖店，都來住附近了一定要來光顧一下， 算是蠻早就來吃的，沒有排什麼隊就吃到了，口味是偏鹹的豬排，整理來說算不錯！ 吃飽又去附近的Jump Shop 逛了一下🤣 雖然沒買什麼東西就是了。 綠洲21、中部電力 Mirai Tower # 吃飽當作散步就去逛逛綠洲21、中部電力 Mirai Tower都在附近，晚上開燈拍起來非常漂亮。 白天跟晚上的中部電力塔是完全不同的感覺！\nDay 2 # 早餐 - コメダ珈琲店 錦伊勢町通店 # 隔天一早，要來驗證名古屋這裡的是不是點飲料送早餐，找了一間連鎖咖啡店來測試，結果是真的🤣 名古屋城 # 名古屋城因為天守閣目前還在整修，沒辦法走上去看。 三輪神社、大須観音 # 接著就前往位在大須商店街旁邊的三輪神社、大須観音，因為還沒到午餐時間就來參拜一下。 午餐 - 大須商店街 # 午餐走商店街小吃路線，在事先做功課的時候發現這裡很多吃的！還剛好跟 BanG Dream 聯名辦活動。 コンパル 大須本店 : 炸蝦三明治 手羽先むすめ 大須店 : 炸雞翅 御手洗糰子 新雀本店 : 烤糰子 覚王山フルーツ大福弁才天 大須店 : 草莓、水蜜桃大福 最後太熱決定先回飯店避暑，一開電視才知道當天最高溫竟然有到38度，真的像烤箱。 晚餐 - あつた蓬莱軒 松坂屋店 # 點了鰻魚飯套餐，果然名不虛傳，真的蠻好吃的。 旁邊寫著鰻魚三吃的吃法，不過我覺得第二吃(加上芥末、蔥花、海苔)、第三吃，只差在有沒有把茶泡飯的湯淋上去而已。 Day 3 # 早餐 - ブルーボトルコーヒー 名古屋栄カフェ # 去了名古屋的藍瓶咖啡，不過這間就沒有點飲料送早餐了，還另外點了水果布丁。 名古屋港水族館 # 接著前往名古屋港水族館，觀看這裡有名的海豚表演。 午餐 - 名古屋辛麵 鯱輪 # 這間算是剛好路過看到有人在排隊久想說吃看看，味道是不錯沒有視覺上的那麼辣，但還是吃到滿身汗。 下午茶 - HARBS 榮本店 # 都來名古屋了一定要朝聖一下 HARBS 的創始店，不過現場人帶多就外帶回飯店吃了。 熱田神宮 # 接著就去了熱田神宮參拜，抽了張半吉籤。\n晚餐 - 世界の山ちゃん 錦三大津店 # 可能是有吃下午茶的關係，不怎麼餓，就外帶這間有名的雞翅與雞皮回飯店吃，味道非常重適合下酒，但我只有買茶來配🤣 Day 4 # 中部電力 Mirai Tower - 眺望塔 # 蠻晚才從飯店 Check Out ，就略過早餐，直接去逛名古屋電力塔了，前幾天都只有遠拍沒有上去。 還剛好遇到哥吉拉70週年的活動，留一顆頭在塔下🤣 付了門票上去，票價算蠻貴的。 午餐 - もうもう亭 広小路店 # 點了 もうもう牛まぶし 的燒肉套餐，還有茶泡飯的吃法，非常好吃😋 名古屋市科學館 # 下午茶 - 和栗モンブラン専門店 栗りん # 天氣實在熱到受不了，大須商店街逛到一半跑進來避暑，看到刨冰蒙布朗覺得很新奇，就跑進來吃了。 還會在你面前做，錄下了整個製作過程。\n晚餐 - カツレツMATUMURA 豬排 # 晚餐就在名古屋車站附近吃了，晚上要回大阪就在附近逛，然後順便等車。 豬排非常軟嫩好吃，大概7、8分熟，還單點了炸雞柳也很好吃。 名古屋車站 # 最後在車站的紀念品店，挑了一盒餅該當作給同學們的伴手禮，就搭車回大阪了。 ","date":"2024年8月20日","externalUrl":null,"permalink":"/daily-notes/japan-travel/nagoya-trip/","section":"Daily-Notes","summary":"","title":"名古屋 | 四天三夜自由行","type":"daily-notes"},{"content":"","date":"2024年8月20日","externalUrl":null,"permalink":"/tags/%E5%90%8D%E5%8F%A4%E5%B1%8B%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"名古屋旅遊","type":"tags"},{"content":"這個星期六和語言學校同學約好在パームガーデン舞洲烤肉與看煙火，這應該是這個夏天最後參加的煙火活動了吧。 下午約在西九條站集合，採買食材後，再搭公車過去烤肉的地點，大概30分鐘。 訂位/收費方式 # 採線上預約制，然後這裡的可以選擇自己帶食材過來考的方案， 一個人頭收1300円的場地費，然後加上座位費(一般桌椅300円/沙發椅600円)， 烤肉器具等等都會幫你準備，只要帶食材過來就好。\n食材採買 # 日本的超市自己買肉來烤真的都蠻便宜的，一大盒才1000日元。 パームガーデン舞洲 # 我們蠻早就到烤肉的地點了，加上天氣很熱現在附近的吊床區坐一下，然後買飲料來喝。 台灣同學又拿出了義美小泡芙來做台灣外交🤣\n烤肉活動 # 時間接近傍晚，我們也開始備料跟生火，準備烤肉了。 煙火表演 # 晚上的7:45分開始煙火表演\n心得 # 這是第一次在日本戶外自己烤肉，算是很不錯的體驗，而且只要帶食材就好蠻輕鬆的，烤肉器具、生火材料都是店家會幫忙準備好，結束時把桌面整理乾淨就好。 煙火雖然沒有大阪淀川煙火來的漂亮，但現場只放給幾組烤肉的人在看也別有一番風味。\n","date":"2024年8月10日","externalUrl":null,"permalink":"/daily-notes/japan-life/osaka-maishima/","section":"Daily-Notes","summary":"","title":"大阪 | 舞洲ロングラン花火 \u0026 烤肉活動","type":"daily-notes"},{"content":"這次的柯南30週年展在大阪大丸梅田店15樓舉辦，需事前購入電子票， 購買後期限之內選一天憑電子票卷入場。 到現場後會依照當天的人數發放入場整理卷，當天人不是非常多，拿到約20分鐘後的入場卷。 購買的票卷有包含特典。 進來首先看到的是這30年內出版的漫畫，全部展示出來。\n然後是柯南雕像與畫作的展示。 還有清水寺為背景的場景。 犯人大集合。 博士的發明跟犯案工具。 基德雕像與畫作展示 漫畫家簽名專區 30週年等身大立牌。\n結束後會拿到物販的入場卷，可以到樓下13樓去購買相關物販。 ","date":"2024年8月6日","externalUrl":null,"permalink":"/daily-notes/japan-life/conan-30th-exhibition/","section":"Daily-Notes","summary":"","title":"大阪 ｜ 大丸梅田店 柯南30週年展","type":"daily-notes"},{"content":"","date":"2024年8月3日","externalUrl":null,"permalink":"/tags/%E8%8A%B1%E7%81%AB%E5%A4%A7%E6%9C%83/","section":"Tags","summary":"","title":"花火大會","type":"tags"},{"content":" 大阪淀川煙火 # 大阪淀川煙火大會（なにわ淀川花火大会）是大阪夏天最大的煙火之一，每年8月初在淀川河畔舉辦。這場煙火大會自1989年開始舉辦，至今已經成為大阪代表性的夏日活動，每年都吸引超過數十萬人前來觀賞。\n有了上一次參加大阪天神祭的經驗，加上這次有日本老師的私藏景點推薦，這次的煙毀大會也特地提前和同學約好一起提早去卡位！ 交通方式 # 從大阪梅田站搭阪神本線到姬島站下車，走10分鐘左右就會到岸邊。 梅田午餐 - 炸牛排 # 午餐跟同學約在梅田，吃這間 牛かつもと村，肉的品質很好一咬就化開，是我吃過連鎖炸牛排店中最好吃的一間，韓國同學真的蠻會推薦吃的🤣 花火大會 # 然後就是提早去搶位子啦，不過真的不愧是日本老師推薦的景點，完全看到觀光客，都是日本人。\n隨著天色逐漸暗下來，煙火也開始施放，真的非常漂亮煙火的種類很多，從岸邊看沒有遮蔽物真的非常壯觀！\n心得 # 這次的煙火大會真的非常慶幸有來！現場真的非常震撼，這次去的觀賞地點也沒有上次天神祭那樣擠滿人， 下次有機會想在梅田展望台上看，聽說從上面角度看的景色更厲害！\n","date":"2024年8月3日","externalUrl":null,"permalink":"/daily-notes/japan-travel/osaka-yodogawa-fireworks/","section":"Daily-Notes","summary":"","title":"大阪 | 淀川煙火","type":"daily-notes"},{"content":"メモを取らないとすぐに忘れてしまうエンジニアです。ここでは、自分の学習メモや日常の出来事を記録しています。\n","date":"2024年7月30日","externalUrl":null,"permalink":"/ja/posts/about/","section":"Posts","summary":"","title":"私について","type":"posts"},{"content":" 前言 # 封面照片是入境當晚拍的通天閣照片，塔上寫著「社会に貢献する」，而我也即將在這裡貢獻我一年的時間了🤣\n抵達日本入境後，有一些手續要處理，這篇文章做個紀錄。\n日本住處 # 因為是自己租房，入境時當然要先打理好未來一年的落腳處。 入境後的隔天一早，就去就找之前在台灣已經線上找好的房仲，簽訂房子的入住契約。\n因為事先已線上對過了就大致再核對一下就快速簽約完成了。 房仲還事先幫我處理好水電的開通，省去很多麻煩，拿到鑰匙後就前往租屋處啦！\n房間的格局是1K，但實際上比想像中還要大！ 瓦斯必須要本人在場才能開通，房仲也幫我預約了當天進行開通。 區役所辦理手續 # 確認日本的地址後，必須在14天內到區役所進行登錄， 而我已經事先找好住宿，確認好房屋狀況後，房仲的人非常好說可以帶我跑一遍流程， 當天下午跟房仲約在附近的浪速區區役所，有人帶著真的順利很多！ 住址登錄+住民票 # 領取號碼牌，並填寫住民異動屇申請表，櫃檯人員會跟你收取填寫好的住民異動屇與在留卡，等待一段時間後，就會拿到背面印有你新住址的在留卡，以及住民票。\n國民健康保險 # 拿到有住址在留卡後，櫃檯人員會給你國民健康保險窗口的號碼牌，叫你到那邊去等叫號，叫號後會在窗口跟你說明健康保險流程，以及是每個人都必須都要加入的，然後會寄一整年份的繳費單到你的住址，每個月就拿該月的繳費單到超商或指定機構繳納。完成手續後就拿到了健康保險證。\n國民年金免除 # 接著是國民年金的部分，窗口人員是說必須要先加入再進行免除的申請，而這裡的窗口能夠當天同時進行申請(有人分享是要後續再跑一趟免除，還是要依照該區的實際流程為主)，然後之後免除結果後續會再寄通知到住址，一樣會寄一整年份的繳費單到你的住址，在免除結果通知下來前都先不要去繳納。\nMy Number Card # 最後是 My Number Card 的部分，同個窗口的人員有問到，就一起辦理了，需繳交1000日圓的費用，等待一段時間就能拿到印有自己照片的 My Number Card 卡了！這張卡就相當於你的身份數位證明，後續不管是要看醫生或是查詢保險繳費紀錄等等的行政程序，都可以透過這張卡進行。\n租屋處的整理 # 之前提到日本租屋大部分是不帶傢俱的，所以都得自己想辦法生出來，房仲之前有推薦給我一個台灣人在大阪開的二手傢俱商，我在台灣就先跟他訂了一些二手傢俱，約好入住當天下午搬進來，省去不少麻煩。\n我只買了床、冰箱、洗衣機、客廳大燈等大型必要傢俱，確保當天能順利住下來，傢俱商也有提供幫忙搬運與安裝的服務，蠻讚的。 之後幾天又陸續在Amazon上訂購桌椅來自己組裝，還有到附近的宜得利與超市採買生活用品。 最終房間終於變成理想的模樣！ 申辦日本門號 # 本來房仲要跟著我去辦電話的，但因為當天下午有搬傢俱的行程，就在區役所跟房仲就地解散了。\n隔天就自己去辦了樂天的門號，還好承辦人員很親切，也沒有用到太困難的日文，都還算是聽得懂，之前有做過功課，方案的部分都已經有事先了解。\n選擇樂天的原因： 第一個是能刷卡繳費，然後都是電子帳單，對我來說非常方便。 第二就是依照你的用量收費，3G、20G 分段收費，超過20G後都是收一樣的價格，因為房間就有Wi-Fi了，這點對我來說非常彈性。 不過缺點就是有些地方的收訊真的蠻差的。 日本郵局開戶 # 到 App Store 下載 ゆうちょ手続き 的 App，線上進行開戶填寫資料，日後郵局會把銀行卡以簽收的方式直接寄到你的住址，不需要親自跑一趟。\n收到銀行卡後，後續為了房租能透過郵局自動扣款，必續親自帶著印章親自跑一趟郵局進行印鑑登錄，然後順便確認其他相關手續是否已經完成。\n結語 # 以上就是入境之後要做的事情啦，區役所的部分還好有房中帶著我，雖然已經有一點日文基礎，但是實際上日本人講話的語速非常的快！有些地方真的會聽不太懂，還好有房仲的輔助講解，才讓我的流程跑得很順利！\n","date":"2024年7月30日","externalUrl":null,"permalink":"/daily-notes/japan-life/working-holiday-arrival/","section":"Daily-Notes","summary":"","title":"日本打工度假｜入境後要做的事情","type":"daily-notes"},{"content":"一個不做筆記就容易忘記的工程師，這裡主要紀錄自己的學習筆記、以及日常的生活分享。\n","date":"2024年7月30日","externalUrl":null,"permalink":"/about/","section":"Eason的部落格","summary":"","title":"關於我","type":"page"},{"content":" 大阪天神祭 # 大阪天神祭（天神祭り）是日本三大祭典之一，每年7月24日、25日在大阪天滿宮及其周邊舉辦。祭典已有超過千年歷史，最有名的就是船渡御和奉納花火，每年都吸引超過百萬人潮參加。 難得這個時候在大阪，就跟語言學校的同學相約參加7月25日的本宮祭，感受一下日本祭典的氣氛！ 交通方式 # 有事先聽說過當天會非常多人，所以下午就約好在大阪天滿站集合，再走路過去天神祭的地點。 一出車站就看到天神祭的工作人員在發扇子與交通管制，不愧是25日的本宮祭，有種全大阪人當天都擠在這裡的感覺，人潮非常多！ 我們就一路跟著人潮，走到晚上看煙火的地方。 天滿橋大川沿岸 # 當了現場人潮真的非常多，真的非常建議早點到現場卡位，我們到的時候河邊的位子已經所剩不多了。 好險我們還是有看到零星的位子，就先放了野餐墊佔好位子。 沿路旁邊都是攤販，從下午就開始營業了。 天氣實在太熱，附近 Lowson 買冰、飲料結帳的人潮，從店內一路排到外面。 我們也買了些攤販的小吃當作晚餐，還有台灣同學帶了義美小泡芙，要跟外國同學做文化交流🤣 船渡御 # 接近傍晚時分，花船陸續出發，河岸兩邊擠滿了人。每艘船上都有表演和音樂，現場氣氛很歡樂。\n花火大會 # 晚上7點半左右開始放煙火，不過太晚佔位子，加上沒有事先研究觀賞煙火的地點，煙火有點被樹擋到😅\n心得 # 第一次參加天神祭，人真的非常多，現場氣氛真的很震撼！不管是花船還是煙火都很有日本夏日祭典的感覺，非常多人穿著浴衣前來，不過人真的很多加上天氣非常熱，真的很佩服他們🤣 推薦有機會的話一定要來體驗一次！真的要事先研究好觀賞煙火的位置，還有可能一早就要來搶位子😂\n","date":"2024年7月25日","externalUrl":null,"permalink":"/daily-notes/japan-travel/osaka-tenjin-matsuri/","section":"Daily-Notes","summary":"","title":"大阪 | 天神祭","type":"daily-notes"},{"content":" 交通方式 # 地鐵坐到大阪港，再走10分鐘就會到 週六早上10點，和語言學校同學們約在大阪海遊館門口集合買票入場。 人潮算普通，大概排20分鐘左右就能買到票。 開館時間與票價是浮動的，可以事先在官網上查看。 海遊館周圍還有其他設施像是觀光船、樂高樂園，有計劃一起前往的話，買套票的話應該會比較划算。 館內參觀動線 # 參觀路線就如官網上所介紹的環太平洋的動線，中間圍繞著有鯨鯊的太平洋水族區。 館內設計是繞著主水槽一圈一圈往下走，每一層都能從不同角度欣賞到。 餵食結束就滾回去的海豹🤣\n蒙特瑞灣的海獅，引導一下就會跟你轉圈圈🤣\n南極大陸館的企鵝。\n太平洋館的水槽真的非常大，裡面有二隻鯨鯊在遊，可以從每層樓的不同角度觀賞。\n智利海岸的日本沙丁魚，一直圍繞的石頭轉。\n海月銀河館水母，看著蠻療癒的🤣\n最後是福克蘭群島的南跳岩企鵝，這裡是半開放空間，所以味道還蠻重的😂\n午餐在隔壁天保山購物中心的美食街，點了鮭魚親子丼，看了那麼多魚也餓了🤤 然後下午的行程附近的點都沒有買票，加上天氣又非常熱，就跑去卡拉OK避暑唱歌了。 心得 # 整體來說大阪海遊館蠻值得來的，館內動線規劃很好，裡面冷氣非常涼，是夏天避暑的好地方。 整個逛下來大概2-3小時，可以在這邊規劃早上的時間，然後接這邊美食街的午餐行程還蠻推薦的。\n","date":"2024年7月20日","externalUrl":null,"permalink":"/daily-notes/japan-travel/osaka-aquarium/","section":"Daily-Notes","summary":"","title":"大阪 | 海遊館","type":"daily-notes"},{"content":"這次的聯名活動同時有 快閃咖啡廳 \u0026amp; POP UP STORE 分別位在6樓與9樓。\n6樓 快閃咖啡廳 # 平日中午沒什麼人，不用排隊就能入場了。 店員會先跟你確認餐點，入場就直接入座，低消至少要點餐點或飲料， 然後都會送隨機杯墊特典。 點了隊長的義大利麵跟副隊長的飲料，亞白隊長立牌只能拍照，吃完要還給餐廳不能帶走。 味道算是普通吧，畢竟是聯名餐點，沒有抱太大的期待期待😂 特典杯墊拿到Q版的レノ跟キコル。 吃飽後要離開前，才能拍店內的擺設與裝潢。 9樓 POP UP STORE # 6樓咖啡廳吃飽後，就接著去9樓逛。 裡面有等身大小的立牌，還蠻帥的，不過カフカ是變身前的狀態，應該是還沒被發現🤣 還有能製作姓名貼的機器，一次300日幣。 ","date":"2024年7月4日","externalUrl":null,"permalink":"/daily-notes/japan-life/kaiju-no-8-popup-store/","section":"Daily-Notes","summary":"","title":"大阪 | 心齋橋 PARCO 怪獸8號 聯名快閃咖啡廳 \u0026 POP UP STORE","type":"daily-notes"},{"content":"","date":"2024年7月3日","externalUrl":null,"permalink":"/tags/google-analytics/","section":"Tags","summary":"","title":"Google Analytics","type":"tags"},{"content":"","date":"2024年7月3日","externalUrl":null,"permalink":"/tags/google-search-console/","section":"Tags","summary":"","title":"Google Search Console","type":"tags"},{"content":" 前言 # SEO（搜尋引擎優化）對於任何網站來說都是非常重要的，這裡簡單記錄一下 Hugo 網站是如何進行 SEO 優化，以及如何新建 Google Search Console、Google Analytics。讓自己的 GitHub Pages 能在 Google 搜尋結果中被看見，並以 Google Analytics 進行分析。\nHugo 的 SEO 優化 # Meta 標籤優化 # 在 Hugo 中，我們可以通過以下方式優化 meta 標籤： 把網頁 head 標籤中的 meta 訊息設定好，例如 title, description, categories, author, tags 等等。 有任何想新增的欄位，也可以加在 YAML Front Matter 中，如下：\n--- title: \u0026#34;Hugo 網站的 SEO 優化與 Google 分析\u0026#34; date: 2024-07-03T14:36:11+09:00 description: \u0026#34;Hugo 網站的 SEO 優化介紹，以及 Google Search Console 提交，讓自己的 GitHub Pages 能在 google 搜尋結果 被看見，並以 Google Analytics進行分析。\u0026#34; tags: [\u0026#34;SEO\u0026#34;,\u0026#34;hugo\u0026#34;,\u0026#34;Google Search Console\u0026#34;,\u0026#34;Google Analytics\u0026#34;] categories: [\u0026#34;hugo網站架設\u0026#34;] draft: false author: \u0026#34;Eason\u0026#34; slug: hugo-website-seo-optimization --- 結構化資料 # 為文章添加結構化資料，幫助搜尋引擎更好地理解內容。在 Hugo 中，可以在 schema.html 中設定：\n\u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;Article\u0026#34;, \u0026#34;headline\u0026#34;: \u0026#34;{{ .Title }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Description }}\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;{{ .Site.Params.author }}\u0026#34; }, \u0026#34;datePublished\u0026#34;: \u0026#34;{{ .Date.Format \u0026#34;2006-01-02T15:04:05Z07:00\u0026#34; }}\u0026#34;, \u0026#34;dateModified\u0026#34;: \u0026#34;{{ .Lastmod.Format \u0026#34;2006-01-02T15:04:05Z07:00\u0026#34; }}\u0026#34;, \u0026#34;publisher\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Organization\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;{{ .Site.Title }}\u0026#34; } } \u0026lt;/script\u0026gt; 網站地圖 (Sitemap) # Hugo 內建自動生成 sitemap.xml的服務，可以透過修改 hugo.toml 去設置關於 Sitemap 的配置參數：\n# Sitemap 配置 [sitemap] changefreq = \u0026#34;daily\u0026#34; priority = 0.5 filename = \u0026#34;sitemap.xml\u0026#34; [languages] [languages.zh-TW] languageCode = \u0026#34;zh-TW\u0026#34; languageName = \u0026#34;繁體中文\u0026#34; weight = 1 title = \u0026#34;Eason的部落格\u0026#34; contentDir = \u0026#34;content/posts\u0026#34; robots.txt 優化 # 創建或優化 static/robots.txt：\nUser-agent: * Allow: / # 網站地圖 Sitemap: https://yourdomain.com/sitemap.xml # 禁止爬取管理頁面 Disallow: /admin/ Disallow: /private/ Google Search Console # 註冊 Google Search Console # 前往 Google Search Console\n點左上角新增資源，點選「網址前置」，輸入網域。 選擇驗證方式：下載 HTML 檔案 直接將下載下來的 HTML 檔放到 Hugo 網站的 /static 目錄下(根目錄)。 重新部署 Hugo 網站\n等待幾分鐘後，按下驗證，成功會顯示提示如圖。 提交 Sitemap。 # 在 Search Console 的左側選單點選 Sitemap。 添加 sitemap.xml URL：https:/eason0614.github.io/zh-tw/sitemap.xml 提交後，Google 會開始爬取你的網站 剛提交應該會顯示資料處理中，過幾天再回來看成效。 Google Analytics # 前往 Google Analytics\n點擊左上「建立」，新增資源，並填入網址與名稱。 將 Google 代碼 ID 複製下來，貼到 hugo.toml 的 googleAnalytics 參數設定中。 # hugo.toml googleAnalytics = \u0026#34;G-XXXXXXX\u0026#34; 重新部署 Hugo 網站，並回到新增頁面按下測試，成功後就能使用 Google Analytics 的功能了。 總結 # Hugo 網站的本身已有提供一些 SEO 優化的方法，通過這些優化措施，特別是對於使用 Hugo 建立的靜態網站，做好 SEO 優化才能讓你的文章被更多人看見。\n","date":"2024年7月3日","externalUrl":null,"permalink":"/tech-articles/hugo-website/seo/","section":"技術文章","summary":"","title":"Hugo 網站的 SEO 優化與 Google 分析","type":"tech-articles"},{"content":"","date":"2024年7月3日","externalUrl":null,"permalink":"/tags/seo/","section":"Tags","summary":"","title":"SEO","type":"tags"},{"content":" 前言 # 已經成功抵達日本了，記錄一下當初打工度假簽證從申請到入境前的準備！ 為什麼想打工度假？ 從以前就很喜歡日本，主要是想彌補學生時代沒出國留學的遺憾吧！ 人生就這麼一次能申請日本打工度假機會，加上已經出社會工作一段時間了\n年齡也接近30歲(打工度假的年齡限制)，當初抱著申請看看有上就出發的念頭，沒想到就順利申請上了。\n這邊列一下要準備的東西與大概的時程。\n從得知結果到領證，有半年的時間，然後領證後一年內要出發， 結果發表到出發最晚有一年半的時間，所以準備的時間算是滿充裕的。\n時程 事項 約10天 簽證申請 (每年4月、10月各一次，以實際公告為主) 準備項目：赴日簽證申請表、白底彩色證件照1張、護照影本、計畫書、存款證明、台灣身分證影本、履歷書、其他自我推薦之文件影本（非必要） 6 個月 領證時間 (公告結果起算) 準備項目：護照正本、受理領證憑單、保險相關證明 1年 簽證有效時間 (領證後起算) 準備項目：在日租屋、學校申請、傢俱家電、找打工 1. 簽證申請 # 每年公告的時間都不太一樣，不過大概會落在4月、10月。 開放的時間大概10天左右，只有平日工作時間可以去提交申請。 這部分如果有意前往可以提前準備。\n所需要的文件可以到 日台交流協會的網站下載\n赴日簽證申請表 : 照實填寫就行。 白底彩色證件照1張: 要求6個月內的大頭照，實際上不要跟本人差太多就可以。 護照影本 : 黑白複印照片那頁就行，如果履歷書有寫去過日本，建議也附上之前簽證張的那頁。 履歷書 : 照實填寫就行。 計畫書 : 打工度假期間的規劃，寫作文，沒有想法的話交給ChatGPT，內容不要太誇張應該是沒問題。 存款證明 : 到銀行櫃檯申請證明，要有等值8萬台幣以上的存款證明，一張大概50元。 台灣身分證影本 : 黑白複印正反面。 其他自我推薦之文件影本（非必要）: 有通過JLPT檢定可以附上。 上述都準備好就可以挑一天去交流協會提交資料了，現場人員不會幫你檢查資料缺漏，建議要事先檢查好，以免因為資料有缺漏而沒有申請上。\n繳交完資料會給你一張紅色的受理領證憑單，有申請上的話到時要拿這張去領證。 2. 領取簽證 # 等待交流學會發布合格者名單，上了就可以開始準備領證囉！ 後來聽說其實備齊文件都蠻好上的，通過率算是很高的樣子。 從名單上找看看有沒有受理領證憑單上的號碼。\n護照正本 : 要注意不要出發的時候護照不要過期。 受理領證憑單 : 當初提交申請拿到的小紅單。 保險相關證明 : 要有在日期間的保險證明，投保項目必須要包含生病、受傷及死亡，領證的時候承辦人員會看投保項目！若本身已有壽險且這些項目也可以，我就是用壽險證明去領證的，就沒有額外花錢去投保了。 東西都提交檢查通過，就順利拿到簽證啦！承辦人會把簽證貼到你的護照內頁上，上面會標示一年內有效，以領證當天起算。\n3. 出發前準備 # 這部分就看各人的規劃了，如果有租屋或是上語言學校的話，建議是先在台灣先找好，\n打工的話有些代辦會有一些能在台灣先面試的職缺，有的會包含住宿。\n這部分就看每個人的需求了，不過在日本當地找一定是有非常多的選擇！\n在日住處 : 看自己的預算、需求。\n金額：Airbnb \u0026gt; 自己租屋 \u0026gt; Share House 方便性： Airbnb \u0026gt;＝ Share House \u0026gt; 自己租屋 生活機能： 自己租屋 \u0026gt;＝ Airbnb \u0026gt; Share House 如果不想綁在一個地方的話，推薦 Airbnb、Share House，不過這二個建議要問過房東是否能夠在區役所登記地址，國民年金、健保之類的通知繳交信件之後會寄到你登記的地址，之後要搬走前也記得要去區役所辦理遷出。\n綜合考量後，最後決定自己租屋了，地點選在大阪，租金相對東京便宜，去周邊的縣市交通也很方便。\n不過自己租屋的話就會有蠻多手續要處理的，找房仲簽訂契約、添購傢俱(日本租屋都常空屋給你)、自己開通水電瓦斯等。\n語言學校 : 這部分蠻推薦透過代辦去申請的，因為通常代辦是跟學校收取費用的，只要教學費給代辦就可以，省去很多手續流程代辦也會依照你的需求推薦學校， 當然自己找好也可以，當初是直接跟代辦問自己做好功課的學校是否能幫忙申請，大部分的學校代辦都有在合作，他們都知道每間學校的招生狀況。\n打工 ： 我是預計語言學校上一段時間再開始找打工，選擇也比較多，不過缺點是前期可能會比較燒錢，要多備一些存款。\n出發機票 ：主要就是學校上課時間跟住宿入住日期都確定之後，就可以訂機票了，時間大概落在一個月前訂，租屋太早找房仲通常不太會理你 XD\n提款卡國外提款 ：提款卡預設都是不允許國外提款的，預計會在日本提款的話記得事先去辦理國外提款權限的開通。永豐外幣卡在日本每個月有三次免費提款還不錯(公告到2024年底)。\n海外信用卡刷卡 ：建議辦一張JCB的信用卡，在日本有些地方VISA都刷不太過，自己是辦玉山的熊本熊卡，回饋的部分還不錯。\n日幣現金 ： 依照個人需求，可以先換好帶去，但要注意入境不能攜帶超過100萬日圓。通常試算一下大概抓1~2個月的租金與租屋前期費用，這部分通常只能付現，其他部分可以靠刷卡或是 PayPay 解決。\n訂購飯店 ：自己租屋的話，租屋入住時通常是空屋的狀態，看個人之後的時程規劃入境後要住的天數，訂購到實際入住前需要的天數。\n我是中午的飛機，入境當天到大阪都已經接近晚上了，已經規劃好隔天入住跟搬傢俱到租屋處，就只多住了一天飯店。\n購買網卡或eSIM ： 落地沒有網路是非常不方便的，事先購買大概3-7天的網路，時間自己估算一下，日本門號開戶前的過渡期。\n台灣門號轉eSIM ： 因為目前在用的Iphone是實體卡只有單卡插孔，日本的電信都常都是實體卡，為了台灣門號還能接收簡訊，就先去中華電信把實體卡轉eSIM了。\nApp ：乗換案内、Yahoo防災通報，這二個算是我覺得最實用的，可以再找找其他人的推薦，iphone 的話交通卡可以先在 Apple Pay 申請一張，儲值透過刷卡非常方便。\n駕照日文譯本 : 如果有在日本自駕的需求，可以先申請起來。\n結語 # 以上是打工度假從申請到入境前的紀錄啦！在機場入境時也順利提交簽證領到在留卡了！\n","date":"2024年7月1日","externalUrl":null,"permalink":"/daily-notes/japan-life/working-holiday-departure/","section":"Daily-Notes","summary":"","title":"日本打工度假｜從申請到出發前的準備","type":"daily-notes"},{"content":"","date":"2024年6月3日","externalUrl":null,"permalink":"/tags/crontab/","section":"Tags","summary":"","title":"Crontab","type":"tags"},{"content":"","date":"2024年6月3日","externalUrl":null,"permalink":"/tags/macos/","section":"Tags","summary":"","title":"MacOS","type":"tags"},{"content":"","date":"2024年6月3日","externalUrl":null,"permalink":"/categories/macos/","section":"Categories","summary":"","title":"MacOS","type":"categories"},{"content":" 前言 # 本文將紀錄如何在 macOS 上使用 crontab 設定，將已經完成的程式或腳本用 macOC 中的 crontab 實行自動化執行，設定定時任務自動執行。\n前置準備 # 1. 確認 deploy.sh 腳本可執行 # 首先確認你的 deploy.sh 腳本具有執行權限：\nls -la deploy.sh 如果沒有執行權限，請執行：\nchmod +x deploy.sh 2. 測試腳本是否正常運行 # 在設定 crontab 之前，建議先手動執行一次確認腳本可以正常運行：\n./deploy.sh crontab 基本操作 # 1. 查看現有的 crontab 任務 # crontab -l 如果沒有設定過，會顯示 crontab: no crontab for [username]\n2. 編輯 crontab（新增任務） # crontab -e 這會開啟預設的編輯器（通常是 vim 或 nano）\n3. 新增自動部署任務 # 在 crontab 編輯器中，新增以下這一行：\n0 0 * * * /Users/eason/Desktop/project/blog/deploy.sh \u0026gt;\u0026gt; /Users/eason/Desktop/project/blog/deploy.log 2\u0026gt;\u0026amp;1 說明:\n0 0 * * * = 每天晚上 12:00 執行 \u0026gt;\u0026gt; /Users/eason/Desktop/project/blog/deploy.log 2\u0026gt;\u0026amp;1 = 將輸出記錄到 deploy.log 檔案 2\u0026gt;\u0026amp;1 = 將錯誤訊息也導向到同一個日誌檔案 常用的 crontab 時間格式 # # 每天凌晨 2 點 0 2 * * * # 每週日凌晨 3 點 0 3 * * 0 # 每月 1 號凌晨 4 點 0 4 1 * * # 每小時執行 0 * * * * # 每 30 分鐘執行 */30 * * * * # 每週一至週五晚上 11 點 0 23 * * 1-5 如果想要在一天內執行多次，可以設定多個時間點：\n# 每天早上 6 點和晚上 12 點執行 0 6,0 * * * /Users/eason/Desktop/project/blog/deploy.sh \u0026gt;\u0026gt; /Users/eason/Desktop/project/blog/deploy.log 2\u0026gt;\u0026amp;1 管理 crontab 任務 # 1. 檢查 crontab 是否設定成功 # crontab -l 2. 查看執行日誌 # # 查看最新的日誌 tail -f /Users/eason/Desktop/project/blog/deploy.log # 查看所有日誌 cat /Users/eason/Desktop/project/blog/deploy.log 3. 刪除 crontab 任務 # 刪除所有任務：\ncrontab -r 編輯 crontab 手動刪除特定行：\ncrontab -e macOS 權限問題 # macOS 可能會要求你授權 cron 的執行權限，這邊記錄一下解決的方式：\n1. 權限設定 # 前往「系統偏好設定」\u0026gt;「安全性與隱私」 找到選擇「完整磁碟存取權」 解鎖並進入編輯模式 在「完整磁碟存取權」中加入cron，路徑應該會在 /usr/sbin/ 底下： 2. 環境變數 # crontab 執行時的環境變數可能與你的終端機不同。如果遇到路徑問題，可以在 crontab 中設定環境變數：\nPATH=/usr/local/bin:/usr/bin:/bin 0 0 * * * /Users/eason/Desktop/project/blog/deploy.sh \u0026gt;\u0026gt; /Users/eason/Desktop/project/blog/deploy.log 2\u0026gt;\u0026amp;1 結語 # 透過設定 crontab 自動化部署，就省去每次都要手動執行的麻煩。\n不過要記得：\n先測試腳本是否正常運行 注意 macOS 的權限設定 定期去檢查日誌確保都正常執行 確保設定的自動化流程都有如期正常在運行。\n","date":"2024年6月3日","externalUrl":null,"permalink":"/tech-articles/macos/crontab-setup-tutorial/","section":"技術文章","summary":"","title":"macOS 如何設定 crontab","type":"tech-articles"},{"content":"","date":"2024年6月1日","externalUrl":null,"permalink":"/tags/github/","section":"Tags","summary":"","title":"Github","type":"tags"},{"content":" 為什麼選擇 Hugo？ # 相信有在使用 Github 的各位，應該知道 Github Page 這個功能，它可以讓我們免費架設靜態網頁，不過因為是靜態網頁的關係，所以不支援像是登入、資料庫等動態功能，那麼要如何快速建立一個好看又實用的個人部落格呢？這時候 Hugo 這個強大的靜態網站生成器就派上用場了。 Hugo 生成 HTML 的速度非常快，幾秒內就能把 Markdown 跟你使用的 Hugo 主題結合在一起，變成 HTML 網頁，雖然使 Markdown 語法可能要稍微熟悉一下，剛從 Medium 的筆者可能會有些陣痛期，但是如果本身已有網頁開發經驗，相信上手是非常快的。\n快速建立 Hugo # 1. 安裝 Hugo # 依照各作業系統 進行下載\nMacOS：\nbrew install hugo 安裝完成後輸入：\nhugo --version 並且有出現版本訊息，代表安裝成功。\n2. 建立 Hugo 網站 # 到 Hugo主題頁 挑選自己喜歡的主題下載下來。\n# 建立新網站 hugo new site my-blog cd my-blog # 安裝主題（以 Blowfish 為例） git init git submodule add https://github.com/nunocoracao/blowfish.git themes/blowfish 3. 寫第一篇文章 # hugo new posts/hello-world.md 編輯 content/posts/hello-world.md：\n--- title: \u0026#34;Hello World\u0026#34; date: 2024-06-01 draft: false --- 這是我的第一篇文章！ 4. 本地預覽 # hugo server 打開 http://localhost 就能看到你的網站了！\n頁面應該會是套用所安裝 Hugo 主題的文章內容。\n5. 常用指令 # # 文章與頁面相關 hugo new posts/文章標題.md # 建立新文章 hugo new about.md # 建立新頁面 hugo new posts/資料夾/文章.md # 建立子資料夾下的新文章 # 本地開發與預覽 hugo server # 啟動本地伺服器（不含草稿） hugo server -D # 啟動本地伺服器（包含草稿） hugo server --port 1314 # 指定埠號啟動本地伺服器 hugo server --disableFastRender # 停用快取，適合除錯 # 文章發佈與草稿管理 hugo list drafts # 列出所有草稿 hugo undraft content/posts/xxx.md # 取消草稿狀態 # 網站建置 hugo # 建置網站（預設輸出到 public 資料夾） hugo --minify # 建置並壓縮 HTML/CSS/JS hugo -d ./dist # 指定輸出資料夾 # 其他常用指令 hugo version # 查看 Hugo 版本 hugo help # 查看所有指令說明 部署到 Github Pages # 1. 到個人的 Github 主頁，並且在右上角點選「New Repository」 # 2. Repository Name 填寫「使用者名稱.github.io」 # 因為已經有建立過了，所以不允許重複。\n記得要設定為 Public 3. 回推上傳至 Github # 先前在本地端 hugo server 後所需要的靜態檔案會生成到 public/ 的目錄。\n將剛才建立好的 Github Repository Clone 下來 :\ngit clone https://github.com/使用者名稱/使用者名稱.github.io 此時 git 會建立一個資料夾，把 public/ 下的檔案都放到該資料夾內。\n將檔案透過 git指令 回推到 Github 上。\ngit add . \u0026amp;\u0026amp; git commit -m \u0026#34;auto build\u0026#34; \u0026amp;\u0026amp; git push 稍微等待一段時間後，打開 https://使用者名稱.github.io/ 有看到自己的網站就代表成功囉！\n建立自動部署流程 # 每次要更新文章到網站上都需要執行上述步驟，透過 Crontab + Script 可以把上面手動的工作流程自動化。\n1.首先建立一支 deploy.sh 的檔案: # 點擊展開 deploy.sh 腳本內容 #!/usr/bin/env bash # 自動建置 Hugo 靜態站，輸出到目標資料夾，並自動 git commit \u0026amp; push。 # 使用：在專案根目錄執行 `./deploy.sh` # ------------------------------------------- # 設定錯誤處理：遇到錯誤時立即停止執行 set -euo pipefail # 1. 變數設定 # 檢查參數數量 if [ $# -ne 2 ]; then echo \u0026#34;[ERROR] 參數數量錯誤\u0026#34; echo \u0026#34;[ERROR] 使用方式: $0 [專案根目錄] [目標路徑]\u0026#34; echo \u0026#34;[ERROR] 範例: $0 /path/to/blog /path/to/target\u0026#34; exit 1 fi # 兩個參數：提供專案根目錄和目標路徑 BLOG_ROOT=\u0026#34;$1\u0026#34; # 從第一個參數取得專案根目錄 TARGET_DIR=\u0026#34;$2\u0026#34; # 從第二個參數取得目標路徑 echo \u0026#34;[INFO] 開始時間: $(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;)\u0026#34; echo \u0026#34;[INFO] 專案根目錄: $BLOG_ROOT\u0026#34; echo \u0026#34;[INFO] 目標路徑: $TARGET_DIR\u0026#34; # 2. 產生靜態檔 cd \u0026#34;$BLOG_ROOT\u0026#34; echo \u0026#34;[INFO] Building site with Hugo...\u0026#34; /opt/homebrew/bin/hugo --cleanDestinationDir --minify -d \u0026#34;$TARGET_DIR\u0026#34; echo \u0026#34;[INFO] Build finished. Files generated at $TARGET_DIR\u0026#34; # 3. Push 到 GitHub Pages 倉庫 if [ -d \u0026#34;$TARGET_DIR/.git\u0026#34; ]; then cd \u0026#34;$TARGET_DIR\u0026#34; git add -A if git diff --cached --quiet; then echo \u0026#34;[INFO] No changes to commit.\u0026#34; else echo \u0026#34;[INFO] Committing and pushing changes...\u0026#34; git commit -m \u0026#34;auto build\u0026#34; git push fi else echo \u0026#34;[ERROR] $TARGET_DIR 不是一個 Git 倉庫，請先手動初始化 (git init) 並設定遠端。\u0026#34; exit 1 fi echo \u0026#34;[SUCCESS] Deployment completed at $(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;)!\u0026#34; 2.接著測試 deploy.sh 是否能正確執行 # 帶入二個路徑的參數，分別為：\nhugo的專案路徑\n本地端 Github 的目錄 (上面提到 public/ 產生靜態檔放置的地方)\ndeploy.sh \u0026#34;hugo的專案路徑\u0026#34; \u0026#34;本地端 Github 的目錄\u0026#34; 3.設定 crontab # crontab 的詳細設定方式請參考這篇教學。\n打開終端機並輸入\ncrontab -e 將 crontab 設定每天晚上 12 點自動執行 deploy.sh\n＃編輯 crontab -e 0 0 * * * /bin/bash deploy.sh \u0026#34;hugo的專案路徑\u0026#34; \u0026#34;本地端 Github 的目錄\u0026#34; \u0026gt;\u0026gt; deploy.log 2\u0026gt;\u0026amp;1 結語 # 利用 Hugo + Github Pages 是建立個人部落格，只要幾分鐘就能架好網站，熟悉Hugo 語法後，也有很高的彈性能再額外擴展自己想要的 UI 設計 / 擴充功能。\n而且還是免費的！也不用額外再租用主機與購買網域，省去很多時間，剩下的時間可以專注在內容創作上。\n","date":"2024年6月1日","externalUrl":null,"permalink":"/tech-articles/hugo-website/github-page/","section":"技術文章","summary":"","title":"Hugo + Github Page 快速建立自己的部落格網站","type":"tech-articles"},{"content":"","date":"2024年2月3日","externalUrl":null,"permalink":"/tags/fabricjs/","section":"Tags","summary":"","title":"Fabricjs","type":"tags"},{"content":"","date":"2024年2月3日","externalUrl":null,"permalink":"/tags/html2canvas/","section":"Tags","summary":"","title":"Html2canvas","type":"tags"},{"content":" 前言 # 之前在專案上有需要在前端上用 Canvas 開發一些功能，發現了二個好用的工具Html2canvas、Fabricjs。\n在這裡做個紀錄整理一下，安裝參照Github 執行command即可，也可以用CND的方式 Include 進來。\nHtml2canvas 使用 # Html2canvas : 功能如其名，能夠將在定義好的區域內(如div) 渲染成Canvas 的畫布，能夠製作將網頁其中一個區塊截圖下來。\n使用時將 html2canvas 透過 CDN 方式 include 進來\n\u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Fabricjs 使用 # Fabricjs : 能夠在canvas 上實現如拖曳、旋轉和變形等等的互動效果。\n使用時將 Fabricjs 透過 CDN 方式 include 進來\n\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/fabric@6.4.3/dist/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 文字圖片的拖拉移動的範例 # 首先定義一個 Canvas\n\u0026lt;canvas id=\u0026#34;canvas\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; 並在js內設定參數\nconst canvas = new fabric.Canvas(\u0026#39;canvas\u0026#39;, { backgroundColor: \u0026#39;black\u0026#39; // 畫布背景色 }); canvas.setWidth(500); // Width canvas.setHeight(500); // Height 新增三角形圖案至畫布\nconst triangle = new fabric.Triangle({ width: 100, height: 100, fill: \u0026#39;blue\u0026#39;, left: 50, top: 50 }); canvas.add(triangle); 新增文字至畫布\nconst editText = new fabric.IText(\u0026#39;Signature\u0026#39;, { top: 100, left: 250, width: 150, fontSize: 36, // 字體大小 fontWeight: 800, // 字體粗細 fill: \u0026#39;red\u0026#39;, // 字體顏色 fontStyle: \u0026#39;italic\u0026#39;, // 斜體 fontFamily: \u0026#39;Calibri\u0026#39;, // 字型 hasControls: true, borderColor: \u0026#39;white\u0026#39;, editingBorderColor: \u0026#39;blue\u0026#39; }); canvas.add(editText); 新增圖片至畫布\nfabric.Image.fromURL(\u0026#39;https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png\u0026#39;, (img) =\u0026gt; { img.set({ top: 250, left: 50, width: 560, //原圖大小 height: 560, // opacity: 0.85, hasControls: true, borderColor: \u0026#39;orange\u0026#39;, scaleX: 0.3, //放大倍率 scaleY: 0.3 }); canvas.add(img); }); 實際執行效果： See the Pen Fabricjs example by easin0614 (@easin0614) on CodePen. 簡易小畫家範例 # See the Pen Fabricjs example2 by easin0614 (@easin0614) on CodePen. 結語 # 官方也提供其他 Demo 有空可以動手玩看看! ","date":"2024年2月3日","externalUrl":null,"permalink":"/tech-articles/frontend/html2canvas-and-fabricjs/","section":"技術文章","summary":"","title":"Html2canvas + Fabricjs 應用","type":"tech-articles"},{"content":"","date":"2024年2月3日","externalUrl":null,"permalink":"/categories/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC/","section":"Categories","summary":"","title":"前端開發","type":"categories"},{"content":"","date":"2024年1月20日","externalUrl":null,"permalink":"/tags/codepen/","section":"Tags","summary":"","title":"Codepen","type":"tags"},{"content":" 前言 # 之前在 Medium 上直接貼上 Codepen 連結就會直接顯示出來，但是Hugo需要多一些步驟，這裡做個紀錄。\n1. 新增 codepen.html shortcode # 在Hugo的 /layouts/shortcodes/ 目錄下新增 codepen.html 的檔案\ncodepen.html內容如下：\n// codepen.html {{ $height := .Get \u0026#34;height\u0026#34; | default \u0026#34;300\u0026#34; }} {{ $defaultTab := .Get \u0026#34;defaultTab\u0026#34; | default \u0026#34;result\u0026#34; }} {{ $slugHash := .Get \u0026#34;slugHash\u0026#34; }} {{ $penTitle := .Get \u0026#34;penTitle\u0026#34; }} {{ $user := .Get \u0026#34;user\u0026#34; }} \u0026lt;div class=\u0026#34;codepen\u0026#34; data-height=\u0026#34;{{ $height }}\u0026#34; data-default-tab=\u0026#34;{{ $defaultTab }}\u0026#34; data-slug-hash=\u0026#34;{{ $slugHash }}\u0026#34; data-pen-title=\u0026#34;{{ $penTitle }}\u0026#34; data-user=\u0026#34;{{ $user }}\u0026#34; style=\u0026#34;height: {{ $height }}px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;\u0026#34;\u0026gt; \u0026lt;span\u0026gt;See the Pen \u0026lt;a href=\u0026#34;https://codepen.io/{{ $user }}/pen/{{ $slugHash }}\u0026#34;\u0026gt; {{ $penTitle }}\u0026lt;/a\u0026gt; by {{ $user }} (\u0026lt;a href=\u0026#34;https://codepen.io/{{ $user }}\u0026#34;\u0026gt;@{{ $user }}\u0026lt;/a\u0026gt;) on \u0026lt;a href=\u0026#34;https://codepen.io\u0026#34;\u0026gt;CodePen\u0026lt;/a\u0026gt;.\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script async src=\u0026#34;https://public.codepenassets.com/embed/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 2. 到 codepen 作品頁面取得 ID # 打開你想要嵌入文章的 codepen 作品畫面，點擊右下角 Embed 按鈕， 然後將 HTML Code 中的 ID 等資訊複製起來。\n在 Hugo 中 的 markdown 文章中嵌入以下代碼，並將 ID 等資訊帶入。\n// 複製後將 { { 中間的空格拿掉，才會正確被Hugo轉譯 { {\u0026lt; codepen height=\u0026#34;500\u0026#34; defaultTab=\u0026#34;result\u0026#34; slugHash=\u0026#34;NWymLWP\u0026#34; penTitle=\u0026#34;Fabricjs example2\u0026#34; user=\u0026#34;easin0614\u0026#34; \u0026gt;} } 成功會 會看到文章的 CodePen 呈現結果如下： See the Pen Fabricjs example2 by easin0614 (@easin0614) on CodePen. ","date":"2024年1月20日","externalUrl":null,"permalink":"/tech-articles/hugo-website/use-codepen/","section":"技術文章","summary":"","title":"把 Codepen 嵌入 Hugo文章上","type":"tech-articles"},{"content":"","date":"2024年1月3日","externalUrl":null,"permalink":"/tags/browser/","section":"Tags","summary":"","title":"Browser","type":"tags"},{"content":" 前言 # 在開發網頁日常，常會去搜尋語法來實現自己想要的某個功能，但很多時候查到的文件或技術文章沒告訴你，這個語法在各個瀏覽器的相容性。\n在 Chrome 上能成功執行，就很開心地繼續開發下去了，結果到最後系統要上線前，瀏覽器測試才發現 IE 執行有問題，就要再花時間回去改 code …\n什麼是 Can I use？ # Can I use 是一個專門用來查詢各種前端技術（HTML、CSS、JavaScript API 等）在不同瀏覽器上的支援度的網站。\n它會用圖表的方式，清楚地顯示各大主流瀏覽器（Chrome、Firefox、Safari、Edge、IE…）對於某個語法或功能的支援狀況。\n為什麼要用 Can I use？ # 避免踩雷：有些新語法或新功能，並不是所有瀏覽器都支援，直接用在專案裡可能會造成部分用戶無法正常瀏覽。 快速查詢：不用再自己去查官方文件或測試，直接輸入關鍵字就能看到支援狀況。 支援度一目了然：用顏色區分支援（綠色）、不支援（紅色）、部分支援（黃色），非常直觀。 如何使用 Can I use？ # 進入網站\n打開 https://caniuse.com/\n輸入你想查詢的語法或功能\n例如：include、grid、fetch等。 支援度圖表\n綠色：完全支援 黃色：部分支援或有 bug 紅色：不支援 灰色：不知道 查看結果\n搜尋結果有更詳細的說明、各瀏覽器版本的支援狀況、已知問題、參考連結等。 每個版本瀏覽器有 released 的時間，以及 user 使用的比例，useage的資料來源為 StatCounter\n再來看 CSS 的 Grid Layout，這邊會列出在IE 10、11 使用要加上的前綴詞。 結語 # 在開發時要用上查到的語法，不妨先花個幾秒鐘在這個網站查查相容性吧!\n","date":"2024年1月3日","externalUrl":null,"permalink":"/tech-articles/frontend/can-i-use/","section":"技術文章","summary":"","title":"使用Can I Use 檢查瀏覽器相容性","type":"tech-articles"},{"content":"","externalUrl":null,"permalink":"/ja/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/ja/series/","section":"Series","summary":"","title":"Series","type":"series"}]
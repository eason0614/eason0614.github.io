[{"content":"","date":"2025年7月10日","externalUrl":null,"permalink":"/daily-notes/","section":"Daily-Notes","summary":"","title":"Daily-Notes","type":"daily-notes"},{"content":"","date":"2025年7月10日","externalUrl":null,"permalink":"/tags/%E6%89%93%E5%B7%A5%E5%BA%A6%E5%81%87/","section":"Tags","summary":"","title":"打工度假","type":"tags"},{"content":"","date":"2025年7月10日","externalUrl":null,"permalink":"/categories/%E6%97%A5%E6%9C%AC%E7%94%9F%E6%B4%BB/","section":"Categories","summary":"","title":"日本生活","type":"categories"},{"content":" 前言 # 隨著打工度假的簽證的到期，回國前有一些手續需要處理，這邊做個記錄。\n1. 租屋解約 # 每個管理公司的合約不同，日本租屋通常簽訂的是二年契約，當初簽訂的契約同樣是二年約，但在租滿一年後解約不需付違約金，而且解約日需在一個月前向管理公司提出申請。\n承租物件負責的管理公司有App，可以線上提出申請。 提出解約申請後，管理公司會再打電話來確認實際要退房的日期與時間，並且需要在退房日前完成房屋清空、水電瓦斯解約。 2. 回國機票 # 解約日、退房日一確定下來就可以先訂回程的機票啦。 3. 租屋處清空 # 當初簽約時怎麼樣，離開也要是一樣的空屋狀態歸還。 比較麻煩的就是大型傢俱的處理，與無法直接丟棄的大型垃圾。\n大型傢俱的處理 : 找不用品回收業者來處理，很多業者雖然廣告狀況良好的傢俱買取、無料回收，但其實你東西本身不多，就算狀況保持的再好，不但買取回收很困難，甚至還不能無料回收，要額外付回收的費用。因為業者會出車載也是需要車馬費的。 無法直接丟棄的大型物件 : 購買大件垃圾處理券貼紙：在指定商店依照垃圾的種類、尺寸，購買正確金額的處理卷貼紙，通常超商會有賣。 聯絡居住區域的大型垃圾受理中心(粗大ゴミ受付センター)：可以網路線上預約或是電話預約，預約申請完成後，於預約好的時間，將貼好貼紙的大型垃圾放到指定地點即可。 到社群轉讓、出售 : 最後我選擇這個方式，雖然要花點時間個別聯絡約時間，考慮到只用1年東西狀況都還不錯，還能回收點錢回來。 最後終於把房子清空了，剩下行李箱裝不下的，用郵局海運的方式寄回台灣。 4. 水電瓦斯解約 # 建議是在確認好退房日期時，就提前去申請解約(遇到搬家尖峰期，日期可能會不好喬)，通常能透過網路預約、電話聯絡的方式申請解約。 身為I人的我當然是想透過網路預約的方式解決，無奈我遇到的狀況是大阪的水電瓦斯，網路解約都要必填搬家住址，而且限定日本住址，只好硬著頭皮打電話預約，最後還是順利聯絡好解約日，還好這一年日文沒白學。\n5. 房屋保險解約 # 這個其實很多人都會忘記去解約，其實放著不管時間一到保險契約也就失效了，在網路申請填一下資料就完成解約的申請了，最後還退了1/4的保費回來。\n6. 區役所 - 住民票轉出、年金健保退出 # 住民票轉出: 可以在要離開的14天前提出申請，到區役所直接跟櫃檯人員說要歸國，並填寫住民票轉出申請表就好了，依照指示填寫住址、轉出地寫上歸國的國家、預計歸國的日期，就完成了。\n年金退保: 接著就到年金櫃檯，因為國民年金已申請免除，就只剩下健康保險的部分要確認，當初寄來的繳費單還少最後二個月份的(應該4月份寄整年份的樣子，當初6月底入境只有收到8個月份的繳費單)，所以進行補繳的動作，繳完就結束了。\n7. 銀行帳戶解約 # 因為太晚才申請保險解約，需等待讓房屋退保的款項入帳(此時已經不在日本了)，所以我就只有把錢都領出來而已，沒有進行解約的動作。 但即使銀行帳戶裡的餘額清空，也不代表帳戶已經正式關閉，建議回國前還是親自前往日本的銀行櫃檯辦理銷戶。此外，若你的帳戶有綁定手機費、電費、水費、瓦斯費、網路費或信用卡等自動扣款，請務必等所有扣款都完成後再辦理解約，否則扣款失敗會被視為欠費，留下不良紀錄，未來在日本申辦信用卡、貸款時可能會受到影響。\n8. 手機門號解約 # 看各家電信的解約流程，樂天能透過App線上提出申請。 9. 退房日前幾天 # 因為水電瓦斯退房前二天就停了，加上傢俱都清空了，所以這幾天都是住附近的飯店。\n10. 退房日當天 # 當天管理公司就派人來，進行退房手續，檢查房屋狀況，因為房子狀況保持的很好，所以沒有被多收其他費用，只有被收當初合約上寫的退房清潔費。 11. 機場在留卡注銷 # 最後到機場入海關時，跟海關確認沒有要再入國後，就會將你的在留卡打洞做註銷。\n","date":"2025年7月10日","externalUrl":null,"permalink":"/daily-notes/japan-life/leaving-working-holiday/","section":"Daily-Notes","summary":"","title":"日本打工度假｜結束回國離開前的手續","type":"daily-notes"},{"content":" Day 1 # 大阪出發 - 商船三井さんふらわあ # 從大阪搭19:05的渡輪前往別府，搭船處就位在ATC HALL的隔壁，從大阪地鐵搭到貿易中心前站(トレードセンター前駅)下車就會到。\n這次是先上網預約，再現場付款，拿到一張票券，上面的QR Code就是房間的出入鑰匙。 登船前可以逛旁邊的貿易中心，也順便買在船上吃的東西。\n船舶介紹 # 這次因為前往別府，與上次搭乘的名門大洋フェリー不同家公司。\n船內大廳 個室 這次的房間的門雖然是可以鎖，但是拉門，沒有完全封閉，所以需要注意不要吵到隔壁房間。 明石海峽大橋 # Day 2 # 早餐 - 船上Buffet # 早餐還算蠻便宜的，就選擇在船上吃了，一邊欣賞窗外風景。 吃完早餐後，就下船前往附近公車站，開啟地獄溫泉巡禮。\n地獄溫泉巡禮 # 從最上面的海地獄開始逛起，買了地獄周遊套票，全部有七個點，每個地獄大概相隔幾百公尺，最後兩個比較遠需要搭公車。\n海地獄 # 鬼石坊主地獄 # かまど地獄 # 鬼山地獄 # 白池地獄 # 血の池地獄 # 搭乘巴士從鐵輪站搭到血の池地獄前站下車。\n這裡有紀念品店，入手了限定的鑰匙圈。 龍巻地獄 # 這裡地獄是間歇泉，一段時間會噴發。\n最後終於集滿七個地獄的印章，結束了地獄溫泉巡禮。 午餐 - Furari # 午餐選了附近的拉麵名店，點了招牌的豚骨醤油ラーメン，非常好吃湯頭蠻順口的。 湯けむり展望台 # 飯後就散步到附近的展望台，可惜沒有拍到煙霧的景色。 大分香りの博物館 # 然後就沿路下山走到，大分香水博物館，順便來吹冷氣避暑一下。 別府駅 # 結束後就來到別府車站，順便去附近的飯店放行李。 車站前有溫泉手湯 やよい天狗 # 接著就來附近的商店街，順路看看巨大天狗。 竹瓦溫泉 # 商店街走到底就會到，當地有名的竹瓦溫泉。 泡澡後來一瓶阿蘇牛奶！ 世界之塔(グローバルタワー) # 回飯店Check In 稍作休息後，來到世界之塔。\n上來都沒有人，包場了！ 晚餐 - 天丼 とよ常本店 # 晚餐在逛完車站附近的百貨後，選了一間評價不錯的天丼店，食材新鮮還不錯吃。 這裡有名的炸雞天婦羅，炸得很酥脆，裡面肉很軟嫩不乾柴。 Day 3 # 九州橫斷特急 # 隔天一早從別府到熊本，搭乘九州橫斷特急，大概3個半小時。 熊本駅 # 抵達熊本站已接近中午。 午餐 - 大漁食堂 HERO海 熊本駅店 # 午餐選在熊本車站附近吃，原本找了一間叫天外天的拉麵，但人太多了， 就另外找了一間壽司店，結果還蠻好吃的。\nAMU PLAZA 熊本 # 吃飽飯後就去旁邊的百貨走走，到處都看得到海賊王，不愧是尾田老師的故鄉。 在 Kiddy Land 入手了限定的鑰匙圈。 熊本城 # 接著來到熊本城。 走了一段路後就會到天守閣。 裡面非常現代化，還有冷氣。 晚餐 - 熊本ラーメン黒亭 下通店 # 來吃一下熊本當地有名的黑亭，這裡的特色是會有生蛋黃，吃到一半再加進去，有另一種風味。 晚餐 - 酒湊 SAKASOU # 與在熊本工作的朋友約在這裡見面，吃他推薦的居酒屋。\n第一次吃生馬肉，口感跟味道有點像咬不爛的鮪魚。 生魚片都蠻新鮮的。 熊本台積電 JASM # 接著他就開車載我到他上班的熊本台積電，經過看看外面就走了，沒辦法進去🤣 索隆銅像 # 附近有索隆銅像就順路來看看了，晚上沒開燈還蠻暗的。 阿蘇山-草千里 # 朋友聽到我白天沒去阿蘇山，就開車帶我上去看看了。 不過晚上其實蠻黑的，都看不到什麼東西。 稍微看一下就載我回飯店了，隔天他還要上班，真的很感謝他抽空帶我逛逛。\nDay 4 # 熊本熊廣場(くまモンスクエア) # 隔天一早來到熊本商店街附近走走，順路來看看熊本熊的店。 午餐 - お好み焼・鉄板焼 大文字 本店 # 午餐吃位在商店街內的御好燒，需要自己DIY親手做，旁邊有教學。 魯夫銅像 # 接著來看魯夫的銅像，就位在熊本縣廳的旁邊廣場。\n博多駅 # 下午原本預計是要到佐賀的，晚上要入住佐賀的飯店。 結果搭錯班次，搭到沒有停高速基山站轉車的班次，是直達博多的班次， 就將錯就錯來博多逛了，反正車錢是差不多的，福岡也比較多東西好吃。\n博多運河城 # 接著又來運河城逛。 晚餐 - 博多やきとり処 楽がき 中洲川端店 # 晚餐找了一間評價蠻高的燒鳥店，還蠻好吃的。\n佐賀駅 # 到佐賀車站已經是晚上9點多。 Day 5 # ゆめタウン佐賀 # 佐賀市區其實沒什麼景點，加上時間有限只有半天的就決定，逛一下附近的購物中心就好。 然後在這裡的NAMCO大開殺戒，鄉下的機台真的超級佛心！兩隻都500日幣內就入手了！\n午餐 - 佐賀牛レストラン 季楽 本店 # 都來到佐賀了，一定要吃的就是佐賀牛，找了一間名店，點了午間套餐。 鐵板溫度非常高，肉能煎到外脆內軟入口即化，就像和牛一樣非常油，煎完的油可以拿來炒青菜。\n佐賀駅 - えきマチ1丁目 # 接著在車站旁邊的紀念品店，入手限定的吊飾。 晚餐 - 博多らーめんShinShin 福岡PARCO店 # 接著就搭車到福岡了，下午在天神商店街附近逛逛， 沿路會經過福岡 PARCO，就順勢在這裡吃晚餐。 排了2個人就入場了，湯頭沒有太重的豬骨味，個人覺得比一蘭還好吃。 自製的辣油還蠻香的。 宵夜 - とりかわ博多かわっこ 薬院店 # 這次來福岡的目的，其中一個就是這裡的雞皮，捲成特殊的形狀烤起來會外脆內Q！ 找了一間飯店附近評價蠻高的雞皮店，果然沒讓人失望，非常好吃。\nDay 6 # ちいかわらんど 福岡パルコ店 # 這次吉伊卡哇剛好有新品，事先抽了早上福岡店入場的整理券，然後順便入手上次沒買到的限定鑰匙圈。\n午餐 - 博多もつ鍋おおやま 福岡パルコ店 # 午餐就順勢在福岡 PARCO吃了，找了間牛腸鍋，點了午間套餐。 味噌湯底，配上比較油的牛腸還蠻搭的。 ブルーボトルコーヒー 福岡天神カフェ # 下午就在天神商店街、警固公園附近走走，逛累了加上天氣炎熱，找間附近的藍瓶咖啡休息。 小倉駅 # 接近傍晚的時候前往小倉站，晚上入住小倉這邊的飯店。 福岡的住宿其實蠻貴的，想省預算隔天又預計前往北九州的話，住小倉這邊還不錯，價格便宜一半左右，從博多搭過來差不多1個小時。 晚餐 - 資さんうどん 魚町店 # 晚餐在小倉車站附近的，魚町銀天商店街逛逛，找了一間這裡有名的連鎖烏龍麵店來吃。 點了期間限定的穴子天婦羅烏龍冷麵套餐。 Day 7 # 下關 - 唐戶市場 # 隔天前往位於下關的唐戶市場，順便在這邊吃早午餐。 這天剛好是假日，人潮蠻多的。 因為沒吃過河豚，有點擔心不合胃口，就沒有點整盤的生魚片。 分別點了炸河豚跟壽司，來嚐鮮看看。\n在外面的用餐區，一邊欣賞`關門橋`的風景，一邊享用。 龜山八幡宮 # 吃飽來到魚市場旁邊的龜山八幡宮參拜。 赤間神宮 # 沿路一直走下去會走到赤間神宮。\n大連神社、紅石稲荷神社 # 沿著赤間神宮旁邊的階梯再往上走，會走到大連神社、紅石稲荷神社。\n魚町銀天街 # 下午就回到了小倉站這邊的商店街逛逛，因為6點就要搭前往渡輪港口的接駁車，沒有時間跑太遠的地方。\nぎょらん亭 魚町店 # 因為早午餐的壽司吃太飽，一直拖到了4點才吃飯，找了一間商店街附近評分還蠻高的拉麵店。 可以自己調整豚骨跟雞湯的比例。\n福岡とりかわ 焼とり権兵衛 小倉魚町店 # 因為太想念前天宵夜的雞皮，於是附近又再找了一間解解饞，味道還不錯但還是福岡的好吃。\n名門大洋フェリー # 晚上搭乘上次搭過的名門大洋的渡輪回大阪，從小倉站有免費的接駁車可以過去。\n上次拍過船上的設施，就沒有再多拍了，不過早上有出來拍明石海峽大橋，又是不一樣的景色。 最後渡輪就抵達大阪了，結束了這趟九州之旅。\n","date":"2025年6月24日","externalUrl":null,"permalink":"/daily-notes/japan-travel/kyushu-trip/","section":"Daily-Notes","summary":"","title":"九州｜別府、熊本、佐賀、福岡、小倉 七天六夜自由行","type":"daily-notes"},{"content":"","date":"2025年6月24日","externalUrl":null,"permalink":"/tags/%E7%86%8A%E6%9C%AC%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"熊本旅遊","type":"tags"},{"content":"","date":"2025年6月24日","externalUrl":null,"permalink":"/tags/%E4%BD%90%E8%B3%80%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"佐賀旅遊","type":"tags"},{"content":"","date":"2025年6月24日","externalUrl":null,"permalink":"/tags/%E5%A4%A7%E5%88%86%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"大分旅遊","type":"tags"},{"content":"","date":"2025年6月24日","externalUrl":null,"permalink":"/categories/%E6%97%A5%E5%B8%B8%E9%9A%A8%E8%A8%98/","section":"Categories","summary":"","title":"日常隨記","type":"categories"},{"content":"","date":"2025年6月24日","externalUrl":null,"permalink":"/categories/%E6%97%A5%E6%9C%AC%E6%97%85%E9%81%8A/","section":"Categories","summary":"","title":"日本旅遊","type":"categories"},{"content":"","date":"2025年6月24日","externalUrl":null,"permalink":"/tags/%E7%A6%8F%E5%B2%A1%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"福岡旅遊","type":"tags"},{"content":"","date":"2025年6月24日","externalUrl":null,"permalink":"/tags/%E5%8C%97%E4%B9%9D%E5%B7%9E%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"北九州旅遊","type":"tags"},{"content":"","date":"2025年6月9日","externalUrl":null,"permalink":"/tags/%E5%90%89%E4%BC%8A%E5%8D%A1%E5%93%87/","section":"Tags","summary":"","title":"吉伊卡哇","type":"tags"},{"content":"梅田目前有二間吉伊卡哇的店，都在梅田站附近，分別位在阪急三番街 B1、HEP FIVE B1。\nちいかわらんど 大阪梅田店 # 位在阪急三番街 B1，梅田站1、2號出口可以直接過去。 ナガノ老師對 Kiddy Land 梅田店 55週年的祝福，原來梅田這間開這麼久了！ 新出的餅卡！ まじかるちいかわストア 梅田HEPFIVE店 # 位在HEP FIVE B1。\n烏薩奇被那孩子虎視眈眈的看著。 結帳櫃檯笑死🤣 剛好有特典活動，拿到小八的魔法棒。 ","date":"2025年6月9日","externalUrl":null,"permalink":"/daily-notes/japan-life/osaka-umeda-chiikawa/","section":"Daily-Notes","summary":"","title":"大阪梅田 | 吉伊卡哇 Land、魔法少女 HEP FIVE 店","type":"daily-notes"},{"content":"","date":"2025年6月9日","externalUrl":null,"permalink":"/tags/%E5%8B%95%E6%BC%AB/","section":"Tags","summary":"","title":"動漫","type":"tags"},{"content":" 早餐 - 木津壽司 # 早上去木津市場看看有名的 魚市食堂有沒有機會吃到，無奈8點去已經要等上一個小時， 所以就吃隔壁的木津壽司，大概10分左右就排到， 點了干貝、鮭魚、鮪魚中腹的組合丼飯，生魚片跟干貝都很新鮮很好吃。\n交通 # 飽餐一頓後就到新今宮站，搭乘南海電鐵前往和歌山市，大概1小時左右會到。 和歌山市駅 # 抵達和歌山市車站，比我想像中還要大，原本以為是個小站。 和歌山城 # 因為早餐吃得有點好，想說要運動一下順便欣賞沿路風景，就用走的走到和歌山城，大概步行半小時左右。 結果到和歌山城公園還有一小鹿山路要走，有點小後悔🤣 紀三井寺 # 接著就到紀三井寺走走。 旁邊的仏殿二樓有個展望台，上面景色非常好可以看到整個和歌山市跟和歌山灣。\n午餐 - 井出商店 # 最後回到市區吃午餐，找了一間有名的拉麵店，湯底是醬油豚骨，豚骨豬味蠻重的。 因為下午2點多才吃午餐，和歌山其他景點還要再往下，也要花不少時間，所以車站附近稍微逛一下 就回去了。\n","date":"2025年6月3日","externalUrl":null,"permalink":"/daily-notes/japan-travel/osaka-wakayama-trip/","section":"Daily-Notes","summary":"","title":"大阪 | 和歌山一日遊","type":"daily-notes"},{"content":"","date":"2025年6月3日","externalUrl":null,"permalink":"/tags/%E5%A4%A7%E9%98%AA%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"大阪旅遊","type":"tags"},{"content":" 交通 # 從大阪難波搭近鐵特急，有直達的電車，大概2個鐘頭會到伊勢車站。 伊勢神宮(外宮) # 就在伊勢車站的附近，走路10分鐘內就會到。 宮內禁止拍攝，只有鳥居跟外圍的照片。 伊勢內宮前 托福橫丁 # 接著就搭巴士前往，伊勢神宮前的商店街，由於太早到，店家大部分都尚未開門，沿路商店都是木造建築，別有風味。\n赤福 本店 # 赤福的本店就位於此處，早上人潮還不算多。 五十鈴川咖啡 # 參拜伊勢神宮參拜後，在咖啡廳享用早餐並稍作休息，一邊欣賞窗外的景色。 山村みるくがっこう 内宮前店 # 這裡有名的霜淇淋布丁店，濃厚的牛奶味蠻好吃的。 還入手了伊勢的限定吊飾 伊勢神宮 內宮 # 因為宮內禁止拍攝，只有拍攝進入神宮前跟外圍的照片。 猿田彥神社 # 午餐前的空檔前往猿田彥神社進行參拜。 午餐 - ゑびや大食堂 # 午餐找了一間評分不錯的餐廳，點了お伊勢さんのご馳走定食什麼都能吃到的套餐定食。 海鮮都算新鮮還不錯，覺得最好吃的是神戶牛的壽司。 二見興玉神社 # 下午前往二見興玉神社進行參拜，看一下有名的夫婦岩。\n伊勢觀光列車 # 回程搭乘伊勢觀光列車回大阪，票價比一般列車貴了800日幣。 觀光列車進站。\n紀念乘車證。 椅子也是比一般列車高級的沙發椅。 另一個看點是，車上有餐廳，可以一邊享用晚餐，一邊欣賞透明窗戶外的風景。 點了神戶牛咖哩飯，都只有小肉塊，味道偏鹹有點普通。 就這樣搭乘觀光列車回大阪，結束了一日三重伊勢之旅。\n","date":"2025年5月29日","externalUrl":null,"permalink":"/daily-notes/japan-travel/mie-ise-trip/","section":"Daily-Notes","summary":"","title":"三重 | 伊勢一日遊","type":"daily-notes"},{"content":"","date":"2025年5月29日","externalUrl":null,"permalink":"/tags/%E4%B8%89%E9%87%8D%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"三重旅遊","type":"tags"},{"content":"","date":"2025年4月15日","externalUrl":null,"permalink":"/tags/graph-problem/","section":"Tags","summary":"","title":"Graph Problem","type":"tags"},{"content":"","date":"2025年4月15日","externalUrl":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"Java","type":"tags"},{"content":"","date":"2025年4月15日","externalUrl":null,"permalink":"/categories/leetcode/","section":"Categories","summary":"","title":"Leetcode","type":"categories"},{"content":" 題目 # leetcode 743 - Network Delay Time (題目說明請點連結)\n範例 # Example 1:\nInput: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\nOutput: 2\nExplanation: 從節點 2 開始，所有節點都能在 2 個時間單位內收到信號\nExample 2:\nInput: times = [[1,2,1]], n = 2, k = 1 Output: 1 Explanation: 從節點 1 開始，節點 2 在 1 個時間單位內收到信號 Example 3:\nInput: times = [[1,2,1]], n = 2, k = 2 Output: -1 Explanation: 從節點 2 開始，無法到達節點 1 解題思路 # 這題要求我們找出從起始節點 k 開始，所有節點收到信號所需的最短時間。如果無法到達所有節點，則返回 -1。\n問題分析 # 給定一個有向加權圖，每個邊代表信號傳輸的時間 從起始節點 k 發送信號，需要計算所有節點收到信號的時間 如果某個節點無法到達，則返回 -1 最終答案是所有節點收到信號時間的最大值 解法：Dijkstra 演算法 # 每次選擇當前距離最小的節點進行處理 一旦確定某個節點的最短距離，它就是最終的最短距離 確保每次處理的都是當前距離最小的節點，提高效率 演算法步驟：\n建圖\n使用鄰接表表示圖 每個節點存儲其鄰居節點和邊權重 初始化\n使用優先佇列（最小堆）來選擇當前距離最小的節點 從起始節點開始，距離設為 0 執行 Dijkstra 演算法\n每次從優先佇列中取出距離最小的節點 更新該節點所有鄰居的距離 重複直到所有節點都被處理 計算結果\n檢查是否所有節點都能到達 返回所有最短路徑中的最大值 例子說明 # 輸入： times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\n步驟 1：建立圖結構\n節點 2 → 節點 1 (時間 1) 節點 2 → 節點 3 (時間 1) 節點 3 → 節點 4 (時間 1) 步驟 2：執行 Dijkstra 演算法\n處理順序 當前節點 距離 更新鄰居 優先佇列狀態 1 節點 2 0 節點 1(1), 節點 3(1) [(1,1), (3,1)] 2 節點 1 1 無鄰居 [(3,1)] 3 節點 3 1 節點 4(2) [(4,2)] 4 節點 4 2 無鄰居 [] 步驟 3：最終結果\n節點 1：距離 1 節點 2：距離 0（起始節點） 節點 3：距離 1 節點 4：距離 2 答案： 2（所有節點收到信號時間的最大值）\n完整程式碼 # import java.util.*; class Solution { public int networkDelayTime(int[][] times, int n, int k) { // 1. 建立鄰接表 graph - 用於存儲圖的結構 Map\u0026lt;Integer, List\u0026lt;int[]\u0026gt;\u0026gt; graph = new HashMap\u0026lt;\u0026gt;(); // 初始化所有節點的鄰接表，每個節點對應一個空的鄰居列表 for (int i = 1; i \u0026lt;= n; i++) { graph.put(i, new ArrayList\u0026lt;\u0026gt;()); } // 將邊的信息加入鄰接表，times[i] = [起始節點, 目標節點, 權重] for (int[] time : times) { int u = time[0], v = time[1], w = time[2]; // u: 起始節點, v: 目標節點, w: 邊權重 graph.get(u).add(new int[]{v, w}); // 將目標節點和權重加入起始節點的鄰居列表 } // 2. 使用 Dijkstra 演算法 (Min Heap) - 優先佇列確保每次處理距離最小的節點 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(Comparator.comparingInt(a -\u0026gt; a[1])); // 按距離排序的最小堆 pq.offer(new int[]{k, 0}); // 將起始節點加入佇列，距離為0 Map\u0026lt;Integer, Integer\u0026gt; dist = new HashMap\u0026lt;\u0026gt;(); // 存儲每個節點的最短距離 // 執行 Dijkstra 演算法主迴圈 while (!pq.isEmpty()) { int[] curr = pq.poll(); // 取出距離最小的節點 int node = curr[0], time = curr[1]; // node: 當前節點, time: 到當前節點的距離 if (dist.containsKey(node)) continue; // 如果已經找到該節點的最短距離，跳過（避免重複處理） dist.put(node, time); // 記錄當前節點的最短距離 // 遍歷當前節點的所有鄰居，更新它們的距離 for (int[] neighbor : graph.get(node)) { int nextNode = neighbor[0], weight = neighbor[1]; // nextNode: 鄰居節點, weight: 邊權重 if (!dist.containsKey(nextNode)) { // 如果鄰居節點還沒有找到最短距離 pq.offer(new int[]{nextNode, time + weight}); // 將鄰居節點加入佇列，距離為當前距離+邊權重 } } } // 3. 檢查是否所有節點都能到達並返回結果 if (dist.size() \u0026lt; n) return -1; // 如果有節點無法到達，返回-1 return Collections.max(dist.values()); // 返回所有節點中最短距離的最大值，即所有節點收到信號的時間 } } 時間複雜度 # 時間複雜度：O(E log V)，其中 E 是邊的數量，V 是節點的數量 空間複雜度：O(V)，用於存儲鄰接表和距離關係 ","date":"2025年4月15日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode743/","section":"技術文章","summary":"","title":"leetcode 743 - Network Delay Time","type":"tech-articles"},{"content":"","date":"2025年4月15日","externalUrl":null,"permalink":"/tags/leetcode-medium/","section":"Tags","summary":"","title":"Leetcode Medium","type":"tags"},{"content":" Docker Compose 常用指令 # 1. Docker Compose 基本操作 # - 查看 Docker Compose 版本資訊 # docker-compose version - 查看 Docker Compose 目前狀態 # docker-compose ps - 啟動所有服務 # docker-compose up - 啟動所有服務（背景執行） # docker-compose up -d - 重啟所有服務 # docker-compose restart - 停止所有服務 # docker-compose down 2. 服務管理 # - 啟動特定服務 # docker-compose up [service name] # 啟動 PostgreSQL 和 Redis 服務 docker-compose up postgres redis docker-compose up -d postgres redis - 停止特定服務 # docker-compose stop [service name] # 停止後端和前端服務 docker-compose stop backend frontend - 重啟特定服務 # docker-compose restart [service name] # 重啟後端服務 docker-compose restart backend - 查看服務日誌 # docker-compose logs [service name] # 查看後端和資料庫的日誌 docker-compose logs backend docker-compose logs postgres - 查看所有服務日誌 # docker-compose logs - 即時查看服務日誌 # docker-compose logs -f [service name] # 即時監控後端服務的日誌輸出 docker-compose logs -f backend 3. Container 操作 # - 進入服務 Container # docker-compose exec [service name] [command] # 進入 PostgreSQL Container 執行 psql 指令 docker-compose exec postgres psql -U postgres -d purchasing_agent - 進入 Container 互動模式 # docker-compose exec -it [service name] /bin/bash # 進入後端 Container 進行除錯 docker-compose exec -it backend /bin/bash - 查看 Container 狀態 # docker-compose ps - 查看 Container 詳細資訊 # docker-compose inspect [service name] # 查看 PostgreSQL Container 的詳細配置 docker-compose inspect postgres 4. 建置與 Image 管理 # - 建置服務 Image # docker-compose build [service name] # 建置後端和前端服務的 Image docker-compose build backend frontend - 強制重新建置（不使用快取） # docker-compose build --no-cache [service name] # 強制重新建置後端服務的 Image docker-compose build --no-cache backend - 建置所有服務 Image # docker-compose build - 拉取服務 Image # docker-compose pull [service name] # 拉取 PostgreSQL 和 Redis Image docker-compose pull postgres redis 5. 網路和連接 # - 查看網路列表 # docker-compose network ls - 查看網路詳細資訊 # docker-compose network inspect [network name] # 查看 purchasing-network 的詳細配置 docker-compose network inspect purchasing-network - 建立網路 # docker-compose network create [network name] # 建立自定義網路 docker-compose network create my-network 6. Volume 管理 # - 查看 Volume 列表 # docker-compose volume ls - 查看 Volume 詳細資訊 # docker-compose volume inspect [volume name] # 查看 PostgreSQL Volume 的詳細資訊 docker-compose volume inspect purchasing_postgres_data - 建立 Volume # docker-compose volume create [volume name] # 建立資料庫和快取的 Volume docker-compose volume create postgres_data docker-compose volume create redis_data 7. 環境變數和配置 # - 使用特定環境檔案 # docker-compose --env-file [file] up # 使用自定義環境變數檔案啟動服務 docker-compose --env-file .env.production up -d - 設定環境變數 # docker-compose -e [variable]=[value] up # 設定自定義環境變數啟動服務 docker-compose -e POSTGRES_PASSWORD=mypassword123 up -d 8. 服務擴展 # - 擴展服務實例數量 # docker-compose up --scale [service]=[number] # 啟動多個後端實例 docker-compose up --scale backend=3 - 查看服務擴展狀態 # docker-compose ps 9. 清理和維護 # - 停止並移除所有 Container # docker-compose down - 停止並移除 Container、網路、Image # docker-compose down --rmi all - 停止並移除 Container、網路、Image、Volume # docker-compose down --rmi all --volumes - 清理未使用的資源 # docker-compose down --remove-orphans 10. 健康檢查和監控 # - 查看服務健康狀態 # docker-compose ps # 查看所有服務的運行狀態和健康檢查結果 docker-compose ps - 等待服務就緒 # docker-compose up -d --wait # 啟動服務並等待所有健康檢查通過 docker-compose up -d --wait 11. 常用組合指令 # - 重新建置並啟動服務 # docker-compose up --build -d # 重新建置 Image 並在背景啟動所有服務 docker-compose up --build -d - 重新啟動特定服務 # docker-compose restart [service name] # 重新啟動後端服務 docker-compose restart backend - 查看服務資源使用情況 # docker-compose top # 查看所有服務的資源使用統計 docker-compose top 12. 故障排除 # - 查看服務配置 # docker-compose config # 驗證 docker-compose.yml 配置檔案的正確性 docker-compose config - 查看服務依賴關係 # docker-compose config --services # 列出所有服務名稱 docker-compose config --services - 強制重新建立 Container # docker-compose up --force-recreate # 強制重新建立所有 Container docker-compose up --force-recreate -d 13. 實用範例 # - 完整的開發環境啟動流程 # # 1. 建置所有服務 Image docker-compose build # 2. 啟動所有服務（背景執行） docker-compose up -d # 3. 查看服務狀態 docker-compose ps # 4. 查看服務日誌 docker-compose logs -f - 資料庫管理操作 # # 進入 PostgreSQL Container docker-compose exec postgres psql -U postgres -d purchasing_agent # 備份資料庫 docker-compose exec postgres pg_dump -U postgres purchasing_agent \u0026gt; backup.sql # 還原資料庫 docker-compose exec -T postgres psql -U postgres -d purchasing_agent \u0026lt; backup.sql - 應用程式除錯 # # 查看後端服務日誌 docker-compose logs -f backend # 進入後端 Container 除錯 docker-compose exec -it backend /bin/bash # 重新啟動後端服務 docker-compose restart backend - 環境變數管理 # # 建立環境變數檔案 cat \u0026gt; .env \u0026lt;\u0026lt; EOF POSTGRES_PASSWORD=secure_password_123 REDIS_PASSWORD=redis_secure_456 JWT_SECRET=my_jwt_secret_key_789 PGADMIN_PASSWORD=admin_secure_123 EOF # 使用環境變數啟動服務 docker-compose --env-file .env up -d ","date":"2025年4月8日","externalUrl":null,"permalink":"/tech-articles/backend/docker-compose-command/","section":"技術文章","summary":"","title":"Docker Compose 常用指令、操作","type":"tech-articles"},{"content":"","date":"2025年4月8日","externalUrl":null,"permalink":"/tags/docker-compose/","section":"Tags","summary":"","title":"Docker-Compose","type":"tags"},{"content":"","date":"2025年4月8日","externalUrl":null,"permalink":"/categories/%E5%BE%8C%E7%AB%AF%E9%96%8B%E7%99%BC/","section":"Categories","summary":"","title":"後端開發","type":"categories"},{"content":"","date":"2025年4月8日","externalUrl":null,"permalink":"/categories/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","section":"Categories","summary":"","title":"常用指令","type":"categories"},{"content":"","date":"2025年4月3日","externalUrl":null,"permalink":"/tags/docker/","section":"Tags","summary":"","title":"Docker","type":"tags"},{"content":" Docker 常用指令 # 1. Docker Service # - 查看 Docker 版本資訊 # docker version - 查看 Docker 目前狀態 # service docker status - 啟動 Docker Service # service docker start - 重啟 Docker Service # service docker restart - 停止 Docker Service # service docker stop 2. Image # - 拉取 image # docker pull [image name]:[image tag] 從 Docker Hub 下載 nginx 和 ubuntu 的 image docker pull nginx:latest docker pull ubuntu:20.04 - 查看已下載的 image # docker images - 搜尋 image # docker search [keyword] 搜尋與 cassandra 和 python 相關的 image docker search cassandra docker search python - 查看 image 詳細資訊 # docker inspect [image name] 查看 nginx 和 ubuntu image 的詳細資訊 docker inspect nginx docker inspect ubuntu:20.04 - 建立 image（使用 Dockerfile） # docker build -t [repository:tag] . 使用當前目錄的 Dockerfile 建立自定義 image docker build -t myapp:v1.0 . docker build -t easonimg/pythonapp3 . - 建立 image（不使用快取） # docker build --no-cache -t [repository:tag] . 強制重新建立 image，不使用快取 docker build --no-cache -t myapp:v1.0 . - 為 image 新增標籤 # docker tag [old tag] [new tag] 為現有的 image 建立新的標籤 docker tag easonimg/pythonapp3 easonimg/pythonapp3_new - 刪除 image # docker rmi [image id] 刪除不需要的 image docker rmi nginx docker rmi ubuntu:20.04 - 儲存 image # docker save -o [filename] [image name] 將 image 儲存為檔案，方便備份或傳輸 docker save -o imgFlask tiangolo/nginx_flask - 載入 image # docker load -i [filename] 從檔案載入 image docker load -i imgFlask - 上傳 image 至倉庫 # docker push [repository:tag] 將自建的 image 上傳到 Docker Hub docker push easonimg/docker.uwsgi-nginx-flask-emperor 3. Container # - 創建並運行 Container # docker run [OPTIONS] [image name]:[image tag] 建立並運行簡單的 hello-world Container 和 nginx web server docker run hello-world docker run -d -p 8080:80 --name mynginx nginx - 查看 Container 狀態 # docker ps -a - 查看運行中的 Container # docker ps - 啟動 Container # docker start [container id] 啟動已停止的 Container docker start mynginx - 停止 Container # docker stop [container id] 停止正在運行的 Container docker stop mynginx - 進入運行中的 Container # docker exec -it [container id] /bin/bash 進入 Container 內部進行操作 docker exec -it mynginx /bin/bash - 查看 Container 日誌 # docker logs [container id] 查看 Container 的輸出日誌 docker logs mynginx - 查看 Container 詳細資訊 # docker inspect [container id] 查看 Container 的詳細配置資訊 docker inspect mynginx - 刪除 Container # docker rm [container id] 刪除已停止的 Container docker rm mynginx - 匯出 Container # docker export -o [filename] [container id] 將 Container 匯出為檔案 docker export -o mycontainer.tar mynginx - 匯入 Container 為 image # cat [filename] | docker import - [repository:tag] 將匯出的 Container 檔案重新匯入為 image cat mycontainer.tar | docker import - easonimg/mycontainer - 複製檔案（Host → Container） # docker cp [host file] [container id]:[container path] 將主機的檔案複製到 Container 內部 docker cp config.yaml mynginx:/etc/config.yaml - 複製檔案（Container → Host） # docker cp [container id]:[container path] [host file] 將 Container 內的檔案複製到主機 docker cp mynginx:/etc/nginx/nginx.conf nginx.conf - 建立 Container 並設定 Port 映射 # docker run -d -p [host port]:[container port] --name [container name] [image] 建立 web server Container 並映射端口 docker run -d -p 8080:80 --name mynginx nginx docker run -d -p 8080:80 -p 8181:81 --name myapp tiangolo/nginx_flask - 建立 Container 並掛載目錄 # docker run -d --name [container name] -v [host path]:[container path] [image] 建立 Container 並掛載主機目錄，實現資料持久化 docker run -d --name myapp -v /home/app:/app tiangolo/nginx_flask - 建立 Container 並設定時區 # docker run -d -p [host port]:[container port] --name [container name] -e \u0026#34;TZ=Asia/Taipei\u0026#34; [image] 建立 Container 並設定台灣時區 docker run -d -p 8080:80 --name myapp -e \u0026#34;TZ=Asia/Taipei\u0026#34; easonimg/docker.nginx-flask-python-pandas - 建立 Container 並使用 Host 網路 # docker run -d --net=host --restart=always [image] 建立 Container 並使用主機網路模式 docker run -d --net=host --restart=always easonimg/imgID - 設定 Container 資源限制 # docker run --cpus=\u0026#34;[cpu limit]\u0026#34; -m [memory limit] [image] 限制 Container 的 CPU 和記憶體使用量 docker run --cpus=\u0026#34;1.5\u0026#34; -m 512m nginx 4. Volume # - 創建 Volume # docker volume create [volume name] 建立資料持久化的 Volume docker volume create mydata docker volume create postgres_data - 查看所有 Volume # docker volume ls - 查看 Volume 詳細資訊 # docker volume inspect [volume name] 查看 Volume 的詳細配置資訊 docker volume inspect mydata - 將 Volume 掛載到 Container # docker run -v [volume name]:[container path] [image] 將 Volume 掛載到 Container 內部，實現資料持久化 docker run -v mydata:/app/data nginx docker run -v postgres_data:/var/lib/postgresql/data postgres - 刪除 Volume # docker volume rm [volume name] 刪除不需要的 Volume docker volume rm mydata - 建立 NFS Volume # docker volume create --driver local \\ --opt type=nfs \\ --opt o=nfsvers=3,addr=[nfs server ip],rw \\ --opt device=:/[nfs folder] \\ [volume name] 建立連接到 NFS 伺服器的 Volume docker volume create --driver local \\ --opt type=nfs \\ --opt o=nfsvers=3,addr=192.168.0.55,rw \\ --opt device=:/nfsfolder \\ volume_nfs ","date":"2025年4月3日","externalUrl":null,"permalink":"/tech-articles/backend/docker-command/","section":"技術文章","summary":"","title":"Docker 常用指令、操作","type":"tech-articles"},{"content":" Day 1 # 新幹線 # 從大阪搭乘新幹線大概一個半小時就會到廣島。 廣島城 # 抵達廣島站後，轉乘巴士前往廣島城，\n從大鳥居(廣島護國神社)前往裏御門跡，往廣島天守閣的方向前進。 廣島護國神社 # 從表御門回去的沿路會經過廣島護國神社。 午餐 - 広島牡蠣と和牛ラーメン 衝青天 # 午餐找了一間評價還不錯的拉麵．點了和牛拉麵再加點單品牡蠣。 鹽系的湯底，搭配牛肉還不錯吃，牡蠣不愧是產地又大顆又鮮甜。 廣島 PARCO # 下午吃飽後去 PARCO 附近逛逛，看一下有沒有廣島限定的周邊。\nちいかわらんど 広島パルコ店 剛好是復活節蛋周邊發售的期間，人還蠻多的，這個系列只剩吉伊了。 有跟`廣島鯉魚隊`合作的周邊，轉了幾顆扭蛋。 晚餐 - お好み焼き 紀乃国屋ぶんちゃん # 在飯店Check In 完放好行李後，到附近找了一間廣島燒餐廳。 味道還不錯，份量還蠻大的，跟大阪燒比起來菜量比較偏多，麵皮跟蛋比較分離。 因為是產地，又單點了牡蠣。 廣島駅 # 吃飽飯後，就在廣島車站周圍的購物中心逛逛。 Day 2 # 從廣島駅，搭乘 JR 從宮島口站下車，之後再轉前往宮島的船，跟JR一樣直接刷閘口就能進站。\n宮島桟橋 # 船抵達宮島桟橋後，就往宮島商店街的方向走。 宮島商店街 # 這裡賣很多當地的特產周邊、特色小吃， 午餐 - 牡蠣屋 # 我們也在這邊找了一間評價還不錯的牡蠣料理，產地新鮮不用說， 點了牡蠣套餐有好幾種吃法，最好吃的還是烤牡蠣，最能吃到牡蠣本身的味道。 揚げもみじの紅葉堂 本店 # 這裡有名的炸楓葉饅頭，裡面有包餡，點了期間限定的起司火腿還不錯。 だいこん屋 # 被旁邊店家的招牌吸引到，還點了的楓葉饅頭冰淇淋來吃。 宮島咖喱麵包研究所 # 從嚴島神社回去的路上又點了咖哩麵包來吃，炸的麵包體裡面包咖哩跟牡蠣，意外還蠻搭的。 cafe Miyaji # 下午逛到腳有點酸，到一間人不多的咖啡廳稍作休息。 嚴島神社 # 這裡為了拍到白天跟黃昏二種版本的宮島神社，我們吃完午餐就先去一路走到神社那邊， 然後再回去商店街跟其他地方逛，最後快黃昏的時候再過來。\n黃昏的時候陽光灑在海面上，又是另一種不同的樣貌。\n其實周圍的海灘就拍得到嚴島神社，但想說都來了就進去本殿看一下。 宮島纜車 # 下午前往宮島纜車，沿路上會經過紅葉谷公園，這裡會看到蠻多鹿，這裡的鹿比奈良溫馴多了🤣\n之後就一路搭乘纜車，往獅子岩展望台前進。\n獅子岩展望台 # 纜車終點是獅子岩展望台，這裡可以看到廣島灣與宮島周邊的島嶼景色，不過可惜當天的天氣不是說太好。\n晚餐 - 焼肉ふるさと 広島駅前店 # 晚餐吃廣島車站附近的燒肉，就是中規中矩的好吃，價格也還行的燒肉店。 最後就同樣搭乘新幹線回大阪了，結束了這趟廣島之旅。\n","date":"2025年3月25日","externalUrl":null,"permalink":"/daily-notes/japan-travel/hiroshima-trip/","section":"Daily-Notes","summary":"","title":"廣島、宮島 | 二天一夜自由行","type":"daily-notes"},{"content":"","date":"2025年3月25日","externalUrl":null,"permalink":"/tags/%E5%BB%A3%E5%B3%B6%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"廣島旅遊","type":"tags"},{"content":"","date":"2025年3月21日","externalUrl":null,"permalink":"/tags/mlb%E6%9D%B1%E4%BA%AC%E6%B5%B7%E5%A4%96%E9%96%8B%E5%B9%95%E6%88%B0/","section":"Tags","summary":"","title":"MLB東京海外開幕戰","type":"tags"},{"content":"這次去東京最主要的目的就是MLB東京海外開幕戰跟順便逛吉伊卡哇東京店， 原本是先訂好票跟飯店，想說如果有搶到開幕賽的票可以順便去的。 無奈沒搶到開幕賽的門票，所以只能去物販跟展覽。\nDay1 # 新幹線 # 從大阪搭新幹線到到東京差不多二個半小時。 一到先去超商買早餐，這個時間哪裡都看得到大谷翔平。 新宿マルイメン店 # 一到先陪女友去位在新宿マルイメン火影快閃店。 ポケモンセンター 渋谷 # 涉谷的寶可夢中心就位在渋谷PARCO 6F 午餐 - 博多天ぷらたかお 渋谷パルコ店 # 午餐吃這間位在渋谷PARCO內的天婦羅，食材新鮮，非常酥脆好吃。 MIYASHITA PARK - MLB Tokyo Series Official Store # 接著就到東京系列賽的物販會場，不過想買的球員卡都沒了，沒買什麼就離開了。\n澀谷TSUTAYA - 大谷翔平シグネチャーコレクションの期間限定店 # 剛好看到期間限定的大谷翔平特展，免費入場而且不用排隊整理卷。 大谷的手比我大好多! 大谷用的護具。 雙刀流的大谷。 50-50紀念衣。 印有大谷養的狗デコビン圖案的鞋子。 晚餐 - 東京たらこスパゲティ 原宿表参道店 # 下午在涉谷逛完後，晚餐跑到原宿來吃，點了明太子麵來吃，味道還不錯。 ちいかわらんど 原宿店 # 接著到ちいかわ原宿店，入手東京限定的周邊。 Day2 # 早上打開電視，看到今天開球的來賓，竟然還是Twice的 Mina、Sana、Momo，真的好想去😭 MIYASHITA PARK # 到涉谷宮下公園附近逛，有展出球員卡的區域，填問卷可以免費抽一包。\n女友抽到大谷! 君のハンバーグを食べたい 渋谷店 # 午餐又來到涉谷吃，看到這間漢堡排名分很高就進來吃了，沒讓我失望，飯很Ｑ粒粒分明，漢堡排非常香。 還遇到台灣人店員，一開始用日文點餐，然後她也用日文回我們，雙方都以為對方是日本人。 後來聽到我們用中文聊天，主動來跟我們打招呼🤣 老闆日本人後來也來了，還跟我們秀了幾句中文🤣\n池袋 # 後來下午都在池袋逛，都是買逛街買東西的行程，就沒有拍照了，只有這張ちいかわ🤣 晚餐 - 鳥貴族 駒込店 # 晚餐吃飯店附近的鳥貴族，這間的品質還行。 Day3 # 東京スカイツリー MLB Tokyo Series Fan Fest # 第三天一早前往晴空塔，參觀 MLB Tokyo Series Fan Fest。\nポケモンセンタースカイツリータウン # 隔壁就是寶可夢中心晴空塔店。 ちいかわベーカリー # 早上的行程結束後，前往位在原宿的吉伊卡哇麵包店，需事先購票才能入場。 在 Lawson Ticket 上購買並抽選，如果中籤信用卡會刷下去。 裡面有一張1000元的購買卷，可以拿來買麵包或周邊。 到現場的時候蠻多東西都賣完了。 點完餐與挑好周邊後，就可以去結帳。\n代代木公園 # 接著就去代代木公園，三月中已經有一些櫻花開了。\n品嚐剛剛買的麵包，這樣拍起來好可愛，會捨不得吃掉🤣 晚餐 - AFURI 原宿 # 一樣點了柚子鹽拉麵，感覺味道沒有2年前來這麼好吃了。 原宿竹下通り # 吃飽後就到附近的竹下通逛逛。 Day4 # 第四天的行程都給了富士山了，一大早就去搭新宿站巴士站搭高速巴士。 因為要去富士急樂園，已先在富士急樂園官網上買好樂園＋巴士的套票。 富士山河口湖 # 因為買的富士急樂園套票是下午才入場，所以早上就先去河口湖拍富士山。 河口湖駅，之後再轉公車前往大石公園， 沿路會經有名的拍照景點 Lawson 富士河口湖町役場前店之前報導的黑幕已經拆掉了。 大石公園 # 到大石公園，可以拍到有河口湖的富士山。 富士急樂園 # 其實來富士急樂園主要是陪女友來這裡的火影忍者園區。\n午餐 一楽ラーメン # 午餐吃一樂拉麵。 摩天輪 # 摩天輪上面可以看到整個富士急樂園。 當然刺激的也可以看到，但女友不敢坐，而且排隊都要一小時以上，沒人陪我排就放棄了。 只好叫要她去果然沒辦法的牌子區罰站。 Day5 # 這天一早東京突然下了很大的三月雪，從飯店窗戶外都能感覺到有多大，不過還好中午前雪就停了。\n午餐 - 三崎豊魚 東武池袋店 # 午餐吃池袋車站附近的生魚片丼飯，點了サーモンいくらまぐろ丼，鮭魚跟鮪魚都蠻新鮮的不錯吃。 ポケモンセンタートウキョーDX # 然後又到了日本橋附近的寶可夢中心DX店。 日本橋 # 接著就到日本橋附近逛逛，真的哪裡都看得到大谷。 虎ノ門之丘 Glass Rock - 道奇體驗展 # 需事先上網購票，我們買的是チャンピオンパス(6600円) 可以拿冠軍戒指跟獎杯拍照。 螢幕播放介紹。 上一次奪冠是2021年的事了。 然後去年也奪冠了! Mookie 的金手套獎。 Kershaw 的 賽揚獎。 投影牆。 去年世界大賽 Game1 的活躍選手。 大谷專區。 大谷40/40盜壘紀念。 大谷57、58盜壘紀念。 道奇簽名牆。 跟冠軍獎盃、戒指的合照。 連送教練的車子都有🤣 Day6 # 池袋 サンシャインシティ - 火影快閃店 # 有一些吃的跟玩的設施，但都需要另外付費。 然後非常多中國代購仔在這裡，排隊動線也設計很差排非常久，時間都浪費在這裡。 物販周邊也很快就沒了，體驗非常糟糕。 午晚餐 - Shintori Komagome # 下午4點多，回飯店拿寄放的行李，準備去機場。 途中找了一間看起來評價還不錯居酒屋，東西也非常好吃。 成田機場 # 從成田機場，逛了一下伴手禮店就搭機回去了。 ","date":"2025年3月21日","externalUrl":null,"permalink":"/daily-notes/japan-travel/tokyo-trip/","section":"Daily-Notes","summary":"","title":"東京｜六天五夜自由行","type":"daily-notes"},{"content":"","date":"2025年3月21日","externalUrl":null,"permalink":"/tags/%E6%9D%B1%E4%BA%AC%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"東京旅遊","type":"tags"},{"content":"","date":"2025年2月14日","externalUrl":null,"permalink":"/tags/dp-problem/","section":"Tags","summary":"","title":"DP Problem","type":"tags"},{"content":" 題目 # leetcode 310 - Minimum Height Trees (題目說明請點連結)\n範例 # Example 1:\nInput: n = 4, edges = [[1,0],[1,2],[1,3]] Output: [1] Explanation: 以節點 1 為根時，樹的高度為 1，這是所有可能根節點中的最小高度。 Example 2:\nInput: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]] Output: [3,4] Explanation: 以節點 3 或 4 為根時，樹的高度為 2，這是所有可能根節點中的最小高度。 解題思路 # 這題要求我們找到無向圖中所有可能的最小高度樹的根節點。最小高度樹是指以某個節點為根時，樹的高度最小。\n解法：拓撲排序（Topological Sort）\n使用拓撲排序的思想，從葉子節點開始，逐層向內收縮。 維護每個節點的度數，將度數為 1 的節點（葉子節點）加入隊列。 逐層移除葉子節點，直到剩餘節點數不超過 2。 剩餘的節點就是最小高度樹的根節點。 解法 # 最小高度樹的根節點一定是圖的\u0026quot;中心\u0026quot;節點 通過不斷移除葉子節點，最終剩下的節點就是中心節點 最多只會剩下 2 個節點（當圖是一條鏈時） 例子說明 # n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\n初始情況：構建圖和度數陣列 第一層移除：\n葉子節點：0, 1, 2, 5（度數為 1） 移除後：節點 3, 4 的度數減 1 剩餘節點：3, 4 第二層移除：\n節點 3, 4 的度數都變為 1，成為新的葉子節點 但此時剩餘節點數 ≤ 2，停止移除 最終結果：\n返回 [3, 4] 完整程式碼 # import java.util.*; class Solution { public List\u0026lt;Integer\u0026gt; findMinHeightTrees(int n, int[][] edges) { // 特殊情況：只有一個節點 if (n == 1) { return Arrays.asList(0); } // 構建圖和度數陣列 List\u0026lt;Set\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] degree = new int[n]; // 初始化圖 for (int i = 0; i \u0026lt; n; i++) { graph.add(new HashSet\u0026lt;\u0026gt;()); } // 添加邊並計算度數 for (int[] edge : edges) { int a = edge[0], b = edge[1]; graph.get(a).add(b); graph.get(b).add(a); degree[a]++; degree[b]++; } // 將所有葉子節點（度數為1）加入隊列 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { if (degree[i] == 1) { queue.offer(i); } } // 逐層移除葉子節點，直到剩餘節點數不超過2 while (n \u0026gt; 2) { int size = queue.size(); // 當前層的葉子節點數量 n -= size; // 更新剩餘節點數 // 處理當前層的所有葉子節點 for (int i = 0; i \u0026lt; size; i++) { int leaf = queue.poll(); // 取出一個葉子節點 // 獲取該葉子節點的所有鄰居 List\u0026lt;Integer\u0026gt; toRemove = new ArrayList\u0026lt;\u0026gt;(graph.get(leaf)); // 移除與鄰居的連接 for (int neighbor : toRemove) { graph.get(leaf).remove(neighbor); graph.get(neighbor).remove(leaf); degree[neighbor]--; // 鄰居的度數減1 // 如果鄰居變成新的葉子節點，加入隊列 if (degree[neighbor] == 1) { queue.offer(neighbor); } } } } // 返回剩餘的節點作為最小高度樹的根節點 return new ArrayList\u0026lt;\u0026gt;(queue); } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是節點的數量 空間複雜度：O(n)，用於存儲圖和隊列 ","date":"2025年2月14日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode310/","section":"技術文章","summary":"","title":"leetcode 310 - Minimum Height Trees","type":"tech-articles"},{"content":" 題目 # leetcode 322 - Coin Change (題目說明請點連結)\n範例 # Example 1:\nInput: coins = [1,2,5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2:\nInput: coins = [2], amount = 3 Output: -1 Explanation: 無法用面額為 2 的硬幣湊出金額 3 Example 3:\nInput: coins = [1], amount = 0 Output: 0 Explanation: 金額為 0 時不需要任何硬幣 解題思路 # 這題要求我們找出湊出指定金額所需的最少硬幣數量。如果無法湊出該金額，則返回 -1。\n解法：動態規劃（Dynamic Programming）\n使用 dp 陣列，dp[i] 表示湊出金額 i 所需的最少硬幣數量 初始化 dp[0] = 0，其他位置設為 -1（表示無法湊出） 對於每個金額 i，嘗試使用每種硬幣面額 如果可以使用某種硬幣，更新 dp[i] 為最小值 解法 # 對於金額 i，我們可以嘗試使用每種硬幣面額 coins[j] 如果 i \u0026gt;= coins[j] 且 dp[i-coins[j]] != -1，則可以使用該硬幣 dp[i] = min(dp[i], dp[i-coins[j]] + 1) 最終返回 dp[amount] 例子說明 # coins = [1,2,5], amount = 11\n初始化：dp[0] = 0, dp[1\u0026hellip;11] = -1 計算 dp[1]：\n可以使用硬幣 1：dp[1] = dp[0] + 1 = 1 計算 dp[2]：\n可以使用硬幣 1：dp[2] = dp[1] + 1 = 2 可以使用硬幣 2：dp[2] = dp[0] + 1 = 1 取最小值：dp[2] = 1 計算 dp[3]：\n可以使用硬幣 1：dp[3] = dp[2] + 1 = 2 可以使用硬幣 2：dp[3] = dp[1] + 1 = 2 取最小值：dp[3] = 2 以此類推\u0026hellip;\n最終結果：\ndp[11] = 3（使用 5 + 5 + 1） 完整程式碼 # import java.util.*; class Solution { public int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; // 創建dp陣列，dp[i]表示湊出金額i所需的最少硬幣數量 Arrays.fill(dp, -1); // 初始化所有位置為-1，表示無法湊出 dp[0] = 0; // 金額為0時不需要任何硬幣 // 遍歷每個金額，從1到amount for (int i = 1; i \u0026lt;= amount; i++) { // 嘗試使用每種硬幣面額 for (int j = 0; j \u0026lt; coins.length; j++) { // 如果當前金額大於等於硬幣面額，且使用該硬幣後的剩餘金額可以湊出 if (i \u0026gt;= coins[j] \u0026amp;\u0026amp; dp[i - coins[j]] != -1) { // 如果dp[i]還未計算過，或者使用當前硬幣可以得到更少的硬幣數量 if (dp[i] == -1 || dp[i] \u0026gt; dp[i - coins[j]] + 1) { dp[i] = dp[i - coins[j]] + 1; // 更新為使用當前硬幣的結果 } } } } return dp[amount]; // 返回湊出目標金額所需的最少硬幣數量 } } 時間複雜度 # 時間複雜度：O(amount × coins.length)，其中 amount 是目標金額，coins.length 是硬幣種類數量 空間複雜度：O(amount)，用於存儲 dp 陣列 ","date":"2025年2月14日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode322/","section":"技術文章","summary":"","title":"leetcode 322 - Coin Change","type":"tech-articles"},{"content":"","date":"2025年2月12日","externalUrl":null,"permalink":"/tags/bfs-problem/","section":"Tags","summary":"","title":"BFS Problem","type":"tags"},{"content":"","date":"2025年2月12日","externalUrl":null,"permalink":"/tags/dfs-problem/","section":"Tags","summary":"","title":"DFS Problem","type":"tags"},{"content":" 題目 # leetcode 934 - Shortest Bridge (題目說明請點連結)\n範例 # Example 1:\nInput: grid = [[0,1],[1,0]] Output: 1 Explanation: 需要建造一座橋樑連接兩個島嶼，最短距離為 1 Example 2:\nInput: grid = [[0,1,0],[0,0,0],[0,0,1]] Output: 2 Explanation: 需要建造一座橋樑連接兩個島嶼，最短距離為 2 Example 3:\nInput: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] Output: 1 Explanation: 兩個島嶼之間的最短距離為 1 解題思路 # 這題要求我們找到連接兩個島嶼的最短橋樑長度。島嶼由相連的陸地（1）組成，海洋由水（0）表示。\n問題分析 # 給定一個二維網格，包含兩個島嶼 需要找到連接兩個島嶼的最短橋樑 橋樑只能在水面上建造 返回最短橋樑的長度 解法：DFS + BFS # DFS：用於標記第一個島嶼的所有陸地 BFS：用於計算從第一個島嶼到第二個島嶼的最短距離 邊界處理：確保只在水面上建造橋樑 演算法步驟：\n找到第一個島嶼\n使用 DFS 遍歷第一個島嶼的所有陸地 將第一個島嶼的所有邊界點加入佇列 找到第二個島嶼\n使用 BFS 從第一個島嶼的邊界開始擴展 計算到第二個島嶼的最短距離 例子說明 # 輸入： grid = [[0,1],[1,0]]\n步驟 1：找到第一個島嶼\n從 (0,1) 開始 DFS 標記第一個島嶼的所有陸地 將邊界點加入佇列 步驟 2：BFS 尋找第二個島嶼\n從佇列中的點開始擴展 計算到第二個島嶼的距離 答案： 1（最短橋樑長度）\n完整程式碼 # import java.util.*; class Solution { // 四個方向的移動：上、下、左、右 int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; public int shortestBridge(int[][] grid) { int m = grid.length, n = grid[0].length; // 網格的行數和列數 boolean[][] visited = new boolean[m][n]; // 記錄已訪問的點 boolean flag = false; // 標記是否已找到第一個島嶼 Queue\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 用於BFS的佇列 // 使用DFS找到第一個島嶼，並將其邊界點加入佇列 for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 1) { // 找到第一個陸地 dfs(grid, i, j, queue, visited); // 使用DFS標記第一個島嶼 flag = true; // 標記已找到第一個島嶼 break; // 跳出內層迴圈 } } if (flag) { // 如果已找到第一個島嶼，跳出外層迴圈 break; } } // 使用BFS找到到第二個島嶼的最短距離 int distance = 0; // 記錄橋樑的長度 while (!queue.isEmpty()) { int size = queue.size(); // 當前層的點數 // 處理當前層的所有點 for (int s = 0; s \u0026lt; size; s++) { int[] cur = queue.poll(); // 取出佇列中的點 int x = cur[0], y = cur[1]; // 當前點的座標 // 檢查四個方向 for (int[] dir : dirs) { int i = x + dir[0], j = y + dir[1]; // 相鄰點的座標 // 檢查邊界條件和是否已訪問 if (i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n \u0026amp;\u0026amp; !visited[i][j]) { if (grid[i][j] == 1) { // 如果遇到第二個島嶼的陸地 return distance; // 返回當前距離 } queue.offer(new int[]{i, j}); // 將相鄰點加入佇列 visited[i][j] = true; // 標記為已訪問 } } } distance++; // 橋樑長度加1 } return -1; // 如果無法連接兩個島嶼，返回-1 } // DFS方法：標記第一個島嶼的所有陸地 public void dfs(int[][] grid, int i, int j, Queue\u0026lt;int[]\u0026gt; queue, boolean[][] visited) { // 檢查邊界條件和是否已訪問或為水 if (i \u0026lt; 0 || i \u0026gt;= grid.length || j \u0026lt; 0 || j \u0026gt;= grid[0].length || visited[i][j] || grid[i][j] == 0) { return; } queue.offer(new int[]{i, j}); // 將當前點加入佇列 visited[i][j] = true; // 標記為已訪問 // 遞迴訪問四個方向的相鄰點 for (int[] dir : dirs) { dfs(grid, i + dir[0], j + dir[1], queue, visited); } } } 時間複雜度 # 時間複雜度：O(m × n)，其中 m 和 n 是網格的行數和列數 空間複雜度：O(m × n)，用於存儲訪問標記和佇列 ","date":"2025年2月12日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode934/","section":"技術文章","summary":"","title":"leetcode 934 - Shortest Bridge","type":"tech-articles"},{"content":" 題目 # leetcode 200 - Number of Islands (題目說明請點連結)\n範例 # Example 1:\nInput: grid = [ [\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;], [\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;], [\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;], [\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;] ] Output: 1 Explanation: 網格中只有一個島嶼，由相連的陸地組成 Example 2:\nInput: grid = [ [\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;], [\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;], [\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;], [\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;] ] Output: 3 Explanation: 網格中有三個島嶼，分別由不同的相連陸地組成 解題思路 # 這題要求我們計算二維網格中島嶼的數量。島嶼被水包圍，並且通過水平或垂直連接相鄰的陸地而形成。\n解法：深度優先搜索（DFS）\n遍歷整個網格，當遇到陸地（\u0026lsquo;1\u0026rsquo;）時，開始 DFS 搜索。 在 DFS 過程中，將訪問過的陸地標記為水（\u0026lsquo;0\u0026rsquo;），避免重複訪問。 每次找到新的陸地時，島嶼計數加一。 使用方向數組來簡化四個方向的搜索。 例子說明 # grid = [[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;],[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;],[\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;],[\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;]]\n初始情況：count = 0 第一個島嶼：\n在位置 (0,0) 找到陸地，count++ DFS 淹沒整個島嶼：(0,0) -\u0026gt; (0,1) -\u0026gt; (1,0) -\u0026gt; (1,1) 島嶼計數：count = 1 第二個島嶼：\n在位置 (2,2) 找到陸地，count++ DFS 淹沒整個島嶼：(2,2) 島嶼計數：count = 2 第三個島嶼：\n在位置 (3,3) 找到陸地，count++ DFS 淹沒整個島嶼：(3,3) -\u0026gt; (3,4) 島嶼計數：count = 3 最終結果：\n返回 3 完整程式碼 # class Solution { int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // 四個方向的偏移量 public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) return 0; // 邊界條件檢查 int m = grid.length, n = grid[0].length; // 獲取網格的行數和列數 int count = 0; // 初始化島嶼計數 // 遍歷整個網格 for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == \u0026#39;1\u0026#39;) { // 找到新島嶼 count++; // 島嶼計數加一 dfs(grid, i, j); // 淹沒這座島嶼 } } } return count; // 返回島嶼總數 } private void dfs(char[][] grid, int i, int j) { int m = grid.length, n = grid[0].length; // 獲取網格的行數和列數 // 邊界條件：超出網格範圍或遇到水 if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n || grid[i][j] == \u0026#39;0\u0026#39;) return; grid[i][j] = \u0026#39;0\u0026#39;; // 淹沒該節點（標記為已訪問） // 向四個方向進行深度優先搜索 for(int[] dir : dirs) { dfs(grid, i + dir[0], j + dir[1]); // 遞歸搜索相鄰節點 } } } 時間複雜度 # 時間複雜度：O(m × n)，其中 m 和 n 分別是網格的行數和列數 空間複雜度：O(m × n)，最壞情況下遞歸調用的深度等於網格的大小 ","date":"2025年2月11日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode200/","section":"技術文章","summary":"","title":"leetcode 200 - Number of Islands","type":"tech-articles"},{"content":" 題目 # leetcode 127 - Word Ladder (題目說明請點連結)\n範例 # Example 1:\nInput: beginWord = \u0026ldquo;hit\u0026rdquo;, endWord = \u0026ldquo;cog\u0026rdquo;, wordList = [\u0026ldquo;hot\u0026rdquo;,\u0026ldquo;dot\u0026rdquo;,\u0026ldquo;dog\u0026rdquo;,\u0026ldquo;lot\u0026rdquo;,\u0026ldquo;log\u0026rdquo;,\u0026ldquo;cog\u0026rdquo;] Output: 5 Explanation: One shortest transformation sequence is \u0026ldquo;hit\u0026rdquo; → \u0026ldquo;hot\u0026rdquo; → \u0026ldquo;dot\u0026rdquo; → \u0026ldquo;dog\u0026rdquo; → \u0026ldquo;cog\u0026rdquo;, which is 5 words long. Example 2:\nInput: beginWord = \u0026ldquo;hit\u0026rdquo;, endWord = \u0026ldquo;cog\u0026rdquo;, wordList = [\u0026ldquo;hot\u0026rdquo;,\u0026ldquo;dot\u0026rdquo;,\u0026ldquo;dog\u0026rdquo;,\u0026ldquo;lot\u0026rdquo;,\u0026ldquo;log\u0026rdquo;] Output: 0 Explanation: The endWord \u0026ldquo;cog\u0026rdquo; is not in wordList, therefore there is no valid transformation sequence. 解題思路 # 這題要求我們找到從 beginWord 到 endWord 的最短轉換序列長度。每次只能改變一個字符，且新單詞必須在 wordList 中。\n我們可以用BFS從 beginWord 開始，逐層向外擴展，直到找到 endWord。\n解法 # 使用 BFS 來解決：\n首先將 wordList 轉換為 HashSet 以便快速查找。 檢查 endWord 是否在 wordList 中，如果不在則返回 0。 使用隊列進行 BFS，從 beginWord 開始。 對於每個單詞，嘗試改變每個位置的字符（a-z）。 如果新單詞在 wordList 中，加入隊列並從集合中移除（避免重複訪問）。 每層代表一個轉換步驟，距離從 1 開始計算。 例子說明 # beginWord = \u0026quot;hit\u0026quot;, endWord = \u0026quot;cog\u0026quot;, wordList = [\u0026quot;hot\u0026quot;,\u0026quot;dot\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;lot\u0026quot;,\u0026quot;log\u0026quot;,\u0026quot;cog\u0026quot;]\n初始情況：queue = [\u0026quot;hit\u0026quot;], distance = 1 第一層（距離 = 1）：\n處理 \u0026ldquo;hit\u0026rdquo; 嘗試改變每個字符： \u0026ldquo;ait\u0026rdquo;, \u0026ldquo;bit\u0026rdquo;, \u0026hellip;, \u0026ldquo;zit\u0026rdquo; → 都不在 wordList 中 \u0026ldquo;hat\u0026rdquo;, \u0026ldquo;hbt\u0026rdquo;, \u0026hellip;, \u0026ldquo;hot\u0026rdquo; → \u0026ldquo;hot\u0026rdquo; 在 wordList 中，加入隊列 \u0026ldquo;hia\u0026rdquo;, \u0026ldquo;hib\u0026rdquo;, \u0026hellip;, \u0026ldquo;hiz\u0026rdquo; → 都不在 wordList 中 隊列更新為：[\u0026quot;hot\u0026quot;] 第二層（距離 = 2）：\n處理 \u0026ldquo;hot\u0026rdquo; 嘗試改變每個字符： \u0026ldquo;aot\u0026rdquo;, \u0026ldquo;bot\u0026rdquo;, \u0026hellip;, \u0026ldquo;zot\u0026rdquo; → 都不在 wordList 中 \u0026ldquo;hat\u0026rdquo;, \u0026ldquo;hbt\u0026rdquo;, \u0026hellip;, \u0026ldquo;hzt\u0026rdquo; → 都不在 wordList 中 \u0026ldquo;hoa\u0026rdquo;, \u0026ldquo;hob\u0026rdquo;, \u0026hellip;, \u0026ldquo;hoz\u0026rdquo; → 都不在 wordList 中 隊列更新為：[] 第三層（距離 = 3）：\n處理 \u0026ldquo;dot\u0026rdquo; 嘗試改變每個字符： \u0026ldquo;aot\u0026rdquo;, \u0026ldquo;bot\u0026rdquo;, \u0026hellip;, \u0026ldquo;zot\u0026rdquo; → 都不在 wordList 中 \u0026ldquo;dat\u0026rdquo;, \u0026ldquo;dbt\u0026rdquo;, \u0026hellip;, \u0026ldquo;dzt\u0026rdquo; → 都不在 wordList 中 \u0026ldquo;doa\u0026rdquo;, \u0026ldquo;dob\u0026rdquo;, \u0026hellip;, \u0026ldquo;dog\u0026rdquo; → \u0026ldquo;dog\u0026rdquo; 在 wordList 中，加入隊列 隊列更新為：[\u0026quot;dog\u0026quot;] 第四層（距離 = 4）：\n處理 \u0026ldquo;dog\u0026rdquo; 嘗試改變每個字符： \u0026ldquo;aog\u0026rdquo;, \u0026ldquo;bog\u0026rdquo;, \u0026hellip;, \u0026ldquo;cog\u0026rdquo; → \u0026ldquo;cog\u0026rdquo; 在 wordList 中，且是目標單詞 找到目標，返回距離 5 完整程式碼 # import java.util.*; class Solution { public int ladderLength(String beginWord, String endWord, List\u0026lt;String\u0026gt; wordList) { // 建立單詞集合以便快速查找 Set\u0026lt;String\u0026gt; wordSet = new HashSet\u0026lt;\u0026gt;(wordList); // 如果終點單詞不在單詞列表中，無法轉換 if (!wordSet.contains(endWord)) { return 0; } // 使用隊列進行廣度優先搜索 Queue\u0026lt;String\u0026gt; wordQueue = new LinkedList\u0026lt;\u0026gt;(); // 從起始單詞開始 BFS wordQueue.add(beginWord); // 距離從 1 開始（包含起始單詞） int distance = 1; // BFS 循環：直到隊列為空 while (!wordQueue.isEmpty()) { int size = wordQueue.size(); // 當前層的節點數量 // 處理當前層級的所有單詞 for (int i = 0; i \u0026lt; size; i++) { String currWord = wordQueue.poll(); // 取出隊首單詞 // 如果當前單詞是終點單詞，返回距離 if (currWord.equals(endWord)) { return distance; } // 嘗試改變當前單詞的每個字符 for (int j = 0; j \u0026lt; currWord.length(); j++) { char[] temp = currWord.toCharArray(); // 轉換為字符數組 // 將位置 j 的字符替換為 a-z 中的每個字母 for (char c = \u0026#39;a\u0026#39;; c \u0026lt;= \u0026#39;z\u0026#39;; c++) { temp[j] = c; String newWord = new String(temp); // 構建新單詞 // 如果新單詞在單詞集合中，加入隊列 if (wordSet.contains(newWord)) { wordQueue.add(newWord); // 加入隊列 wordSet.remove(newWord); // 移除以避免重複訪問 } } } } // 處理完當前層級後增加距離 distance++; } // 如果沒有找到轉換序列，返回 0 return 0; } } 時間複雜度 # 時間複雜度：O(N × L × 26)，其中 N 是單詞數量，L 是單詞長度，26 是字符集大小 空間複雜度：O(N)，用於存儲隊列和單詞集合 ","date":"2025年2月10日","externalUrl":null,"permalink":"/tech-articles/leetcode/hard/leetcode127/","section":"技術文章","summary":"","title":"leetcode 127 - Word Ladder","type":"tech-articles"},{"content":"","date":"2025年2月10日","externalUrl":null,"permalink":"/tags/leetcode-hard/","section":"Tags","summary":"","title":"Leetcode Hard","type":"tags"},{"content":" 題目 # leetcode 542 - 01 Matrix (題目說明請點連結)\n範例 # Example 1:\nInput: mat = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: [[0,0,0],[0,1,0],[0,0,0]]\nExplanation: 每個 1 到最近的 0 的距離分別為 1，其餘為 0 Example 2:\nInput: mat = [[0,0,0],[0,1,0],[1,1,1]]\nOutput: [[0,0,0],[0,1,0],[1,2,1]]\nExplanation: 每個 1 到最近的 0 的距離分別為 1 或 2 解題思路 # 這題要求我們找到矩陣中每個元素到最近的 0 的距離。對於每個元素，我們需要計算它到最近的 0 的曼哈頓距離。\n我們可以從所有的 0 開始，向外擴展，逐層計算距離。\n解法 # 使用BFS來解決：\n首先將所有 0 的位置加入隊列，並標記為已訪問。 使用 BFS 從所有 0 開始向外擴展。 對於每個位置，檢查四個方向（上下左右）的相鄰位置。 如果相鄰位置未訪問過，則將其加入隊列，並設置距離為當前層數。 例子說明 # mat = [[0,0,0],[0,1,0],[1,1,1]]\n初始情況：所有 0 的位置加入隊列，queue = [(0,0), (0,1), (0,2), (1,0), (1,2)] 第一層（距離 = 0）：\n處理所有 0 的位置：(0,0), (0,1), (0,2), (1,0), (1,2) 將相鄰的 1 加入隊列：(1,1), (2,0), (2,2) 第二層（距離 = 1）：\n處理 (1,1), (2,0), (2,2) 將相鄰的 1 加入隊列：(2,1) 第三層（距離 = 2）：\n處理 (2,1) 沒有新的相鄰位置 最終結果：\n[[0,0,0],[0,1,0],[1,2,1]] 完整程式碼 # import java.util.LinkedList; import java.util.Queue; class Solution { // 定義四個方向的移動：右、左、下、上 int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; public int[][] updateMatrix(int[][] mat) { int m = mat.length, n = mat[0].length; int[][] res = new int[m][n]; // 結果矩陣，存儲每個位置到最近0的距離 boolean[][] visited = new boolean[m][n]; // 訪問標記矩陣，避免重複訪問 Queue\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // BFS 隊列，存儲待處理的位置 // 將所有 0 的位置加入隊列，並標記為已訪問 for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (mat[i][j] == 0) { queue.offer(new int[]{i, j}); // 將0的位置加入隊列 visited[i][j] = true; // 標記為已訪問 } } } int cost = 0; // 當前層的距離 while (!queue.isEmpty()) { // 當隊列不為空時繼續處理 int size = queue.size(); // 當前層的節點數量 // 處理當前層的所有節點 for (int s = 0; s \u0026lt; size; s++) { int[] cur = queue.poll(); // 取出隊首節點 int x = cur[0], y = cur[1]; // 獲取節點的座標 // 如果當前位置是 1，設置其距離為當前層數 if (mat[x][y] == 1) { res[x][y] = cost; // 設置距離 } // 檢查四個方向的相鄰位置 for (int[] dir : dirs) { int i = x + dir[0], j = y + dir[1]; // 計算相鄰位置的座標 // 確保位置在矩陣範圍內且未訪問過 if (i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n \u0026amp;\u0026amp; !visited[i][j]) { queue.offer(new int[]{i, j}); // 將相鄰位置加入隊列 visited[i][j] = true; // 標記為已訪問 } } } cost++; // 進入下一層，距離加 1 } return res; // 返回結果矩陣 } } 時間複雜度 # 時間複雜度：O(m × n)，其中 m 和 n 是矩陣的行數和列數 空間複雜度：O(m × n)，用於存儲隊列和訪問標記矩陣 ","date":"2025年2月7日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode542/","section":"技術文章","summary":"","title":"leetcode 542 - 01 Matrix","type":"tech-articles"},{"content":" 題目 # leetcode 129 - Sum Root to Leaf Numbers (題目說明請點連結)\n範例 # Example 1:\nInput: root = [1,2,3]\nOutput: 25\nExplanation: 根到葉子的路徑 1-\u0026gt;2 代表數字 12。根到葉子的路徑 1-\u0026gt;3 代表數字 13。因此，總和 = 12 + 13 = 25。\nExample 2:\nInput: root = [4,9,0,5,1]\nOutput: 1026\nExplanation: 根到葉子的路徑 4-\u0026gt;9-\u0026gt;5 代表數字 495。根到葉子的路徑 4-\u0026gt;9-\u0026gt;1 代表數字 491。根到葉子的路徑 4-\u0026gt;0 代表數字 40。因此，總和 = 495 + 491 + 40 = 1026。\n解題思路 # 這題要求我們計算從根節點到所有葉子節點的路徑所代表的數字總和。每個路徑代表一個數字，從根節點到葉子節點的數字按順序組成。\n我們需要遍歷所有從根到葉子的路徑，並累加每個路徑代表的數字。\n解法 # 使用 DFS 來解決：\n從根節點開始，維護一個當前路徑的數字。 每訪問一個節點，將當前數字乘以10再加上節點值。 當到達葉子節點時，將完整路徑的數字加入總和。 遞歸訪問左右子樹。 完整程式碼 # /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { // 全局變數，記錄所有路徑數字的總和 int sum = 0; public int sumNumbers(TreeNode root) { // 邊界條件：空樹返回 0 if(root == null){ return 0; } // 從根節點開始 DFS，初始數字為 0 dfs(root, 0); return sum; } /** * DFS 遍歷函數 * @param root 當前節點 * @param num 當前路徑的數字 */ public void dfs(TreeNode root, int num) { // 將當前節點的值加入路徑數字中 num = 10 * num + root.val; // 如果到達葉子節點，將完整路徑數字加入總和 if(root.left == null \u0026amp;\u0026amp; root.right == null){ sum += num; return; } // 遞歸訪問左子樹 if(root.left != null){ dfs(root.left, num); } // 遞歸訪問右子樹 if(root.right != null){ dfs(root.right, num); } } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是二元樹中的節點數 空間複雜度：O(h)，其中 h 是二元樹的高度（遞歸呼叫的 call stack 深度） ","date":"2025年2月6日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode129/","section":"技術文章","summary":"","title":"leetcode 129 - Sum Root to Leaf Numbers","type":"tech-articles"},{"content":" 題目 # leetcode 124 - Binary Tree Maximum Path Sum (題目說明請點連結)\n範例 # Example 1:\nInput: root = [1,2,3]\nOutput: 6\nExplanation: 最佳路徑為 2 -\u0026gt; 1 -\u0026gt; 3，路徑和為 2 + 1 + 3 = 6。\nExample 2:\nInput: root = [-10,9,20,null,null,15,7] Output: 42 Explanation: 最佳路徑為 15 -\u0026gt; 20 -\u0026gt; 7，路徑和為 15 + 20 + 7 = 42。 解題思路 # 題目要求找到二叉樹中的最大路徑和。路徑可以從任意節點開始，到任意節點結束，但必須是從父節點到子節點的連續路徑。\n解法 # 使用 深度優先搜索（DFS） 來解決：\n對於每個節點，計算左子樹和右子樹的最大路徑和。 如果子樹的路徑和為負數，則不選擇該子樹（設為0）。 更新全局最大值：左子樹路徑和 + 右子樹路徑和 + 當前節點值。 返回以當前節點為根的最大路徑和（只能選擇左子樹或右子樹之一）。 詳細步驟說明 # -10 / \\ 9 20 / \\ 15 7 步驟 1：遍歷節點 15\ndfs(15) 調用 dfs(null) 和 dfs(null)，都返回 0 left = max(0, 0) = 0, right = max(0, 0) = 0 更新 max = max(0 + 0 + 15, max) = 15 返回 max(0 + 15, 0 + 15) = 15 步驟 2：遍歷節點 7\ndfs(7) 調用 dfs(null) 和 dfs(null)，都返回 0 left = max(0, 0) = 0, right = max(0, 0) = 0 更新 max = max(0 + 0 + 7, 15) = 15 返回 max(0 + 7, 0 + 7) = 7 步驟 3：遍歷節點 20\ndfs(20) 調用 dfs(15) 和 dfs(7) left = max(15, 0) = 15, right = max(7, 0) = 7 更新 max = max(15 + 7 + 20, 15) = 42 返回 max(15 + 20, 7 + 20) = 35 步驟 4：遍歷節點 9\ndfs(9) 調用 dfs(null) 和 dfs(null)，都返回 0 left = max(0, 0) = 0, right = max(0, 0) = 0 更新 max = max(0 + 0 + 9, 42) = 42 返回 max(0 + 9, 0 + 9) = 9 步驟 5：遍歷根節點 -10\ndfs(-10) 調用 dfs(9) 和 dfs(20) left = max(9, 0) = 9, right = max(35, 0) = 35 更新 max = max(9 + 35 + (-10), 42) = max(34, 42) = 42 返回 max(9 + (-10), 35 + (-10)) = max(-1, 25) = 25 最終結果：42\n最佳路徑是 15 → 20 → 7，路徑和為 15 + 20 + 7 = 42。\n完整程式碼 # class Solution { // 全局變數，記錄最大路徑和 int max = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) { // 調用 DFS 遍歷整棵樹 dfs(root); return max; // 返回全局最大值 } /** * DFS 遍歷函數 * @param root 當前節點 * @return 返回以當前節點為根的最大路徑和（只能選擇左子樹或右子樹之一） */ public int dfs(TreeNode root) { // 邊界條件：空節點返回 0 if (root == null) { return 0; } // 遞歸計算左子樹的最大路徑和，如果為負數則不選擇（設為0） int left = Math.max(dfs(root.left), 0); // 遞歸計算右子樹的最大路徑和，如果為負數則不選擇（設為0） int right = Math.max(dfs(root.right), 0); // 更新全局最大值：左子樹路徑和 + 右子樹路徑和 + 當前節點值 // 這代表經過當前節點的路徑（可以同時選擇左右子樹） max = Math.max(left + right + root.val, max); // 返回以當前節點為根的最大路徑和 // 只能選擇左子樹或右子樹之一，加上當前節點值 return Math.max(left + root.val, right + root.val); } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是二叉樹中的節點數 空間複雜度：O(h)，其中 h 是二叉樹的高度 ","date":"2025年2月5日","externalUrl":null,"permalink":"/tech-articles/leetcode/hard/leetcode124/","section":"技術文章","summary":"","title":"leetcode 124 - Binary Tree Maximum Path Sum","type":"tech-articles"},{"content":" 題目 # leetcode 104 - Maximum Depth of Binary Tree (題目說明請點連結)\n範例 # Example 1:\nInput: root = [3,9,20,null,null,15,7] Output: 3 Explanation: 二元樹的最大深度為 3，從根節點到最遠葉節點的路徑長度 Example 2:\nInput: root = [1,null,2] Output: 2 Explanation: 二元樹的最大深度為 2，從根節點到最遠葉節點的路徑長度 解題思路 # 這題要求我們找到二元樹的最大深度。二元樹的最大深度是指從根節點到最遠葉節點的最長路徑上的節點數。 我們可以使用遞迴（DFS）或迭代（BFS）的方式來解決。\n解法 # 方法一：遞迴（DFS） # 使用遞迴的方式，對於每個節點：\n如果節點為空，返回 0 否則，返回左子樹和右子樹的最大深度 + 1 方法二：迭代（BFS） # 使用BFS，逐層遍歷二元樹，計算層數。\n完整程式碼 # 遞迴解法 # /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } int leftDepth = maxDepth(root.left); int rightDepth = maxDepth(root.right); return Math.max(leftDepth, rightDepth) + 1; } } 迭代解法（BFS） # import java.util.Queue; import java.util.LinkedList; class Solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); int depth = 0; while (!queue.isEmpty()) { int levelSize = queue.size(); for (int i = 0; i \u0026lt; levelSize; i++) { TreeNode current = queue.poll(); if (current.left != null) { queue.offer(current.left); } if (current.right != null) { queue.offer(current.right); } } depth++; } return depth; } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是二元樹中的節點數 空間複雜度： 遞迴解法：O(h)，其中 h 是二元樹的高度 迭代解法：O(w)，其中 w 是二元樹的最大寬度 ","date":"2025年2月4日","externalUrl":null,"permalink":"/tech-articles/leetcode/easy/leetcode104/","section":"技術文章","summary":"","title":"leetcode 104 - Maximum Depth of Binary Tree","type":"tech-articles"},{"content":" 題目 # leetcode 199 - Binary Tree Right Side View (題目說明請點連結)\n範例 # Example 1:\nInput: root = [1,2,3,null,5,null,4] Output: [1,3,4] Example 2:\nInput: root = [1,null,3] Output: [1,3] Example 3:\nInput: root = [] Output: [] 解題思路 # 這題要求我們從二元樹的右側視角看到的節點值。也就是說，對於每一層，我們需要返回該層最右邊的節點值。\n解法 # 方法一：迭代（BFS） # 使用BFS，逐層遍歷二元樹，對於每一層，我們記錄該層最右邊的節點值。\n方法二：遞迴（DFS） # 使用DFS，按照右子樹優先的順序遍歷，記錄每一層的第一個節點。\n完整程式碼 # BFS解法 # import java.util.List; import java.util.LinkedList; import java.util.Queue; class Solution { public List\u0026lt;Integer\u0026gt; rightSideView(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new LinkedList\u0026lt;\u0026gt;(); // 用來存放每層最右邊的節點值 if (root == null) { return result; // 如果樹為空，直接回傳空列表 } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 用於BFS的隊列 queue.offer(root); // 先將根節點加入隊列 while (!queue.isEmpty()) { int size = queue.size(); // 當前層的節點數量 result.add(queue.peek().val); // 每層的第一個節點（即最右邊的節點）加入結果 // 遍歷當前層的所有節點 for (int i = 0; i \u0026lt; size; i++) { TreeNode node = queue.poll(); // 取出隊首節點 // 先加入右子樹，再加入左子樹，確保下一層最右邊的節點會先被處理 if (node.right != null) { queue.offer(node.right); } if (node.left != null) { queue.offer(node.left); } } } return result; // 回傳所有層的最右邊節點值 } } DFS解法 # import java.util.List; import java.util.LinkedList; class Solution { public List\u0026lt;Integer\u0026gt; rightSideView(TreeNode root) { // 建立一個LinkedList來存放每層最右邊的節點值 List\u0026lt;Integer\u0026gt; result = new LinkedList\u0026lt;\u0026gt;(); // 從根節點開始進行DFS，初始深度為0 dfs(root, 0, result); // 回傳結果列表 return result; } private void dfs(TreeNode node, int depth, List\u0026lt;Integer\u0026gt; result) { // 如果節點為空，直接返回 if (node == null) { return; } // 當前深度等於結果列表的大小，代表這是該層第一個被訪問的節點（最右邊的節點） if (depth == result.size()) { result.add(node.val); // 將節點值加入結果 } // 先遞迴右子樹，再遞迴左子樹，確保每層最右邊的節點最先被加入 dfs(node.right, depth + 1, result); dfs(node.left, depth + 1, result); } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是二元樹中的節點數 空間複雜度： BFS解法：O(w)，其中 w 是二元樹的最大寬度 DFS解法：O(h)，其中 h 是二元樹的高度 ","date":"2025年2月4日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode199/","section":"技術文章","summary":"","title":"leetcode 199 - Binary Tree Right Side View","type":"tech-articles"},{"content":"","date":"2025年2月4日","externalUrl":null,"permalink":"/tags/leetcode-easy/","section":"Tags","summary":"","title":"Leetcode Easy","type":"tags"},{"content":"","date":"2025年2月3日","externalUrl":null,"permalink":"/tags/hashmap-problem/","section":"Tags","summary":"","title":"HashMap Problem","type":"tags"},{"content":"","date":"2025年2月3日","externalUrl":null,"permalink":"/tags/heap-problem/","section":"Tags","summary":"","title":"Heap Problem","type":"tags"},{"content":" 題目 # leetcode 1 - Two Sum (題目說明請點連結)\n範例 # Example 1:\nInput: nums = [2, 7, 11, 15], target = 9 Output: [0, 1] Explanation: 因為 nums[0] + nums[1] == 9，所以返回 [0, 1] Example 2:\nInput: nums = [3, 2, 4], target = 6 Output: [1, 2] Explanation: 因為 nums[1] + nums[2] == 6，所以返回 [1, 2] 解題思路 # 這題要求我們在數組中找到兩個數字，這兩個數字的和等於給定的 target，並返回它們的索引。這是經典的 HashMap 問題，可以利用HashMap高效地解決，時間複雜度為 O(n)。\n解法 # 我們可以使用HashMap來存儲每個數字的索引，當我們遍歷數組中的每一個數字時，檢查是否存在一個數字，使得 target - nums[i] 等於某個已經出現過的數字。如果存在，就直接返回這兩個數字的索引。\n具體步驟如下：\n初始化一個空的HashMap map，用來存儲數字的值和索引。 遍歷數組 nums，對於每個元素 nums[i]，計算 target - nums[i]，並檢查HashMap中是否存在這個差值。 如果存在，則返回這兩個數字的索引。 如果不存在，則將當前數字及其索引放入HashMap中。 例子說明 # nums = [2, 7, 11, 15], target = 9\n初始情況：map = {}，target = 9，我們從 nums 中遍歷每一個數字。 處理第一個數字 2：\n計算 target - 2 = 9 - 2 = 7。 HashMap map 中沒有 7，所以把 2 和它的索引 0 存入HashMap，map = {2: 0}。 處理第二個數字 7：\n計算 target - 7 = 9 - 7 = 2。 HashMap map 中有 2，所以返回 map.get(2) 和當前索引 1，即返回 [0, 1]。 所以答案是 [0, 1]，表示 nums[0] + nums[1] = 9。\n完整程式碼 # import java.util.Map; import java.util.HashMap; class Solution { public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 初始化一個HashMap來存儲數字和索引 for (int i = 0; i \u0026lt; nums.length; i++) { // 遍歷數組 if (map.containsKey(target - nums[i])) { // 檢查HashMap中是否存在目標數字的差值 return new int[] { map.get(target - nums[i]), i }; // 如果存在，返回索引 } else { map.put(nums[i], i); // 如果不存在，將當前數字和索引存入HashMap } } return new int[2]; // 返回空數組（理論上不會到這一步） } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是數組的長度 空間複雜度：O(n)，用於存儲 HashMap ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/easy/leetcode1/","section":"技術文章","summary":"","title":"leetcode 1 - Two Sum","type":"tech-articles"},{"content":" 題目 # leetcode 20 - Valid Parentheses (題目說明請點連結)\n範例 # Example 1:\nInput: s = \u0026ldquo;()\u0026rdquo; Output: true Explanation: 括號成對匹配且順序正確 Example 2:\nInput: s = \u0026ldquo;()[]{}\u0026rdquo; Output: true Explanation: 所有括號都成對匹配且順序正確 Example 3:\nInput: s = \u0026ldquo;(]\u0026rdquo; Output: false Explanation: 括號不匹配，\u0026rsquo;(\u0026rsquo; 和 \u0026lsquo;]\u0026rsquo; 不是對應的括號 解題思路 # 題目要求檢查括號是否成對匹配並且順序正確。有效的括號必須滿足以下條件：\n只有三種括號類型：()，[]，{}。 每個開括號都必須有對應的閉括號，並且順序必須正確。 如果所有括號都正確匹配，則返回 true，否則返回 false。 這個問題可以使用 Stack（堆疊） 來解決，因為堆疊是後進先出的結構，適合處理嵌套的結構。\n解法 # 遍歷字串中的每個字元： 如果是開括號 (、[、{，則壓入堆疊。 如果是閉括號 )、]、}，則檢查堆疊頂端是否是對應的開括號，如果是則彈出。 如果不是對應的開括號或堆疊為空，則返回 false。 遍歷結束後，檢查堆疊是否為空，若為空則表示所有括號匹配，返回 true，否則返回 false。 例子說明 # s = \u0026quot;()[]{}\u0026quot;\n初始情況：stack = [] 處理第一個字元 (：\n是開括號，壓入堆疊，stack = ['('] 處理第二個字元 )：\n是閉括號，檢查堆疊頂端是否為對應的開括號 ( 匹配成功，彈出堆疊，stack = [] 處理第三個字元 [：\n是開括號，壓入堆疊，stack = ['['] 處理第四個字元 ]：\n是閉括號，檢查堆疊頂端是否為對應的開括號 [ 匹配成功，彈出堆疊，stack = [] 處理第五個字元 {：\n是開括號，壓入堆疊，stack = ['{'] 處理第六個字元 }：\n是閉括號，檢查堆疊頂端是否為對應的開括號 { 匹配成功，彈出堆疊，stack = [] 遍歷結束：\n堆疊為空，返回 true 完整程式碼 # import java.util.Stack; class Solution { public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 初始化堆疊來存儲開括號 for(int i = 0; i \u0026lt; s.length(); i++) { // 遍歷字串中的每個字元 char c = s.charAt(i); if (c == \u0026#39;(\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;{\u0026#39;) { // 如果是開括號 stack.push(c); // 壓入堆疊 } else if (!stack.isEmpty() \u0026amp;\u0026amp; c == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; stack.peek() == \u0026#39;(\u0026#39;) { // 如果是右括號且堆疊頂端是對應的左括號 stack.pop(); // 彈出堆疊頂端元素 } else if (!stack.isEmpty() \u0026amp;\u0026amp; c == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; stack.peek() == \u0026#39;[\u0026#39;) { // 如果是右方括號且堆疊頂端是對應的左方括號 stack.pop(); // 彈出堆疊頂端元素 } else if (!stack.isEmpty() \u0026amp;\u0026amp; c == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; stack.peek() == \u0026#39;{\u0026#39;) { // 如果是右大括號且堆疊頂端是對應的左大括號 stack.pop(); // 彈出堆疊頂端元素 } else { // 如果括號不匹配或堆疊為空 return false; // 返回 false } } return stack.isEmpty(); // 檢查堆疊是否為空，如果為空則所有括號都匹配 } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是字串的長度 空間複雜度：O(n)，用於存儲堆疊 ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/easy/leetcode20/","section":"技術文章","summary":"","title":"leetcode 20 - Valid Parentheses","type":"tech-articles"},{"content":" 題目 # leetcode 215 - Kth Largest Element in an Array (題目說明請點連結)\n範例 # Example 1:\nInput: nums = [3,2,1,5,6,4], k = 2 Output: 5 Example 2:\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 解題思路 # 題目要求找到數組中第 k 大的元素。可以使用多種方法來解決此問題，常見的解法有以下兩種：\n排序法：將數組排序，然後選擇第 k 大的元素。 堆法：使用最小堆（Min-Heap）來解決，堆中始終保持 k 個最大元素，最小堆的根元素即為第 k 大的元素。 在這裡，我們選擇使用 最小堆，因為這樣可以達到更高效的時間複雜度。具體步驟如下：\n解法 # 初始化一個最小堆（Min-Heap）。 遍歷數組中的每個元素： 如果堆的大小小於 k，將當前元素加入堆中。 如果堆的大小達到 k，並且當前元素大於堆頂元素（最小值），則將堆頂元素移除並將當前元素加入堆中。 當所有元素遍歷完成後，堆頂元素即為第 k 大的元素。 這樣我們就能在 O(n log k) 的時間複雜度內找到第 k 大的元素。\n完整程式碼 # import java.util.PriorityQueue; class Solution { public int findKthLargest(int[] nums, int k) { PriorityQueue\u0026lt;Integer\u0026gt; heap = new PriorityQueue\u0026lt;\u0026gt;(); // 遍歷數組中的每個元素 for (int num : nums) { // 如果堆的大小小於 k，直接插入元素 if (heap.size() \u0026lt; k || heap.peek() \u0026lt;= num) { heap.offer(num); } // 如果堆的大小超過 k，移除堆頂最小元素 if (heap.size() \u0026gt; k) { heap.poll(); } } // 返回堆頂元素，即為第 k 大的元素 return heap.peek(); } } 時間複雜度 # 時間複雜度：O(n log k)，其中 n 是數組的長度，k 是第 k 大的 k 空間複雜度：O(k)，用於存儲最小堆 ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode215/","section":"技術文章","summary":"","title":"leetcode 215 - Kth Largest Element in an Array","type":"tech-articles"},{"content":" 題目 # leetcode 23 - Merge k Sorted Lists (題目說明請點連結)\n範例 # Example 1:\nInput: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Example 2:\nInput: lists = [] Output: [] 解題思路 # 題目要求將 k 個已經排序的鏈表合併成一個排序的鏈表。可以使用 最小堆（Min-Heap 來解決，因為最小堆可以幫助我們在每一步選擇當前最小的元素。\n解法 # 使用最小堆將每個鏈表的頭結點加入堆中。 從堆中取出最小的元素，並將該元素的下一個節點加入堆中。 重複步驟2直到堆為空，最終得到合併後的排序鏈表。 例子說明 # lists = [[1,4,5],[1,3,4],[2,6]]\n初始情況：將所有鏈表的頭節點加入堆中，heap = [1,1,2] 第一次取出：\n取出最小值 1（來自第一個鏈表） 將該鏈表的下一個節點 4 加入堆中，heap = [1,2,4] 結果鏈表：1 第二次取出：\n取出最小值 1（來自第二個鏈表） 將該鏈表的下一個節點 3 加入堆中，heap = [2,3,4] 結果鏈表：1 -\u0026gt; 1 第三次取出：\n取出最小值 2（來自第三個鏈表） 將該鏈表的下一個節點 6 加入堆中，heap = [3,4,6] 結果鏈表：1 -\u0026gt; 1 -\u0026gt; 2 第四次取出：\n取出最小值 3（來自第二個鏈表） 將該鏈表的下一個節點 4 加入堆中，heap = [4,4,6] 結果鏈表：1 -\u0026gt; 1 -\u0026gt; 2 -\u0026gt; 3 繼續取出\u0026hellip;\n最終結果：1 -\u0026gt; 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; 6 完整程式碼 # import java.util.PriorityQueue; class Solution { public ListNode mergeKLists(ListNode[] lists) { PriorityQueue\u0026lt;ListNode\u0026gt; heap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a.val - b.val); // 創建最小堆，按節點值排序 // 將每個鏈表的頭節點加入堆中 for (ListNode list : lists) { if (list != null) { // 如果鏈表不為空 heap.offer(list); // 將頭節點加入堆中 } } ListNode res = new ListNode(0); // 創建虛擬頭節點 ListNode cur = res; // 當前指針 // 合併所有鏈表 while (!heap.isEmpty()) { // 當堆不為空時繼續處理 ListNode node = heap.poll(); // 取出堆頂的最小節點 cur.next = node; // 將節點加入結果鏈表 cur = cur.next; // 移動當前指針 // 如果當前節點有下一個節點，則將其加入堆中 if (node.next != null) { heap.offer(node.next); // 將下一個節點加入堆中 } } return res.next; // 返回虛擬頭節點的下一個節點 } } 時間複雜度 # 時間複雜度：O(n log k)，其中 n 是所有鏈表節點的總數，k 是鏈表的數量 空間複雜度：O(k)，用於存儲最小堆 ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/hard/leetcode23/","section":"技術文章","summary":"","title":"leetcode 23 - Merge k Sorted Lists","type":"tech-articles"},{"content":" 題目 # leetcode 394 - Decode String (題目說明請點連結)\n範例 # Example 1:\nInput: s = \u0026ldquo;3[a]2[bc]\u0026rdquo; Output: \u0026ldquo;aaabcbc\u0026rdquo; Example 2:\nInput: s = \u0026ldquo;3[a2[c]]\u0026rdquo; Output: \u0026ldquo;accaccacc\u0026rdquo; Example 3:\nInput: s = \u0026ldquo;2[abc]3[cd]ef\u0026rdquo; Output: \u0026ldquo;abcabccdcdcdef\u0026rdquo; 解題思路 # 這題要求解碼嵌套格式的字串，例如 3[a2[c]] 需要展開成 accaccacc。\n解法：使用堆疊（Stack）模擬展開過程\n數字處理：當遇到數字時，累計數字值，表示接下來的字串需要重複的次數。 左括號 [：遇到 [ 時，將當前數字與已解析的字串推入堆疊，開始處理新的子字串。 右括號 ]：遇到 ] 時，從堆疊中取出數字與之前的字串，將當前處理的子字串重複相應次數後加回。 字母處理：如果是普通字母，則直接加入當前字串。 這種方法確保能夠處理多層嵌套結構，例如 3[a2[c]]。\n例子說明 # s = \u0026quot;3[a2[c]]\u0026quot;\n初始情況：sb = \u0026quot;\u0026quot;，stNum = []，stStr = []，n = 0 處理字符 \u0026lsquo;3\u0026rsquo;：\n是數字，n = n * 10 + (3 - '0') = 3 處理字符 \u0026lsquo;[\u0026rsquo;：\n是左括號，stNum.push(3)，n = 0 stStr.push(\u0026quot;\u0026quot;)，sb = \u0026quot;\u0026quot; 處理字符 \u0026lsquo;a\u0026rsquo;：\n是字母，sb.append('a')，sb = \u0026quot;a\u0026quot; 處理字符 \u0026lsquo;2\u0026rsquo;：\n是數字，n = n * 10 + (2 - '0') = 2 處理字符 \u0026lsquo;[\u0026rsquo;：\n是左括號，stNum.push(2)，n = 0 stStr.push(\u0026quot;a\u0026quot;)，sb = \u0026quot;\u0026quot; 處理字符 \u0026lsquo;c\u0026rsquo;：\n是字母，sb.append('c')，sb = \u0026quot;c\u0026quot; 處理字符 \u0026lsquo;]\u0026rsquo;：\n是右括號，cnt = stNum.pop() = 2 temp = \u0026quot;c\u0026quot;，sb = stStr.pop() = \u0026quot;a\u0026quot; 重複 2 次：sb.append(\u0026quot;c\u0026quot;)，sb.append(\u0026quot;c\u0026quot;) sb = \u0026quot;acc\u0026quot; 處理字符 \u0026lsquo;]\u0026rsquo;：\n是右括號，cnt = stNum.pop() = 3 temp = \u0026quot;acc\u0026quot;，sb = stStr.pop() = \u0026quot;\u0026quot; 重複 3 次：sb.append(\u0026quot;acc\u0026quot;)，sb.append(\u0026quot;acc\u0026quot;)，sb.append(\u0026quot;acc\u0026quot;) sb = \u0026quot;accaccacc\u0026quot; 最終結果：\n返回 \u0026quot;accaccacc\u0026quot; 完整程式碼 # import java.util.Stack; class Solution { public String decodeString(String s) { StringBuilder sb = new StringBuilder(); // 當前處理的字串 Stack\u0026lt;Integer\u0026gt; stNum = new Stack\u0026lt;\u0026gt;(); // 存儲重複次數的堆疊 Stack\u0026lt;StringBuilder\u0026gt; stStr = new Stack\u0026lt;\u0026gt;(); // 存儲字串的堆疊 int n = 0; // 當前累計的數字 for (int i = 0; i \u0026lt; s.length(); i++) { // 遍歷字串中的每個字符 if (Character.isDigit(s.charAt(i))) { // 如果是數字 n = n * 10 + (s.charAt(i) - \u0026#39;0\u0026#39;); // 累計數字值 } else if (s.charAt(i) == \u0026#39;[\u0026#39;) { // 如果是左括號 stNum.push(n); // 將數字推入堆疊 n = 0; // 重置數字 stStr.push(sb); // 將當前字串推入堆疊 sb = new StringBuilder(); // 開始新的字串 } else if (s.charAt(i) == \u0026#39;]\u0026#39;) { // 如果是右括號 int cnt = stNum.pop(); // 取出重複次數 StringBuilder temp = sb; // 暫存當前字串 sb = stStr.pop(); // 取出之前的字串 while (cnt-- \u0026gt; 0) { // 重複指定次數 sb.append(temp); // 將字串加入 } } else { // 如果是字母 sb.append(s.charAt(i)); // 直接加入當前字串 } } return sb.toString(); // 返回最終結果 } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是字串的長度 空間複雜度：O(n)，用於存儲堆疊 ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode394/","section":"技術文章","summary":"","title":"leetcode 394 - Decode String","type":"tech-articles"},{"content":" 題目 # leetcode 496 - Next Greater Element I (題目說明請點連結)\n範例 # Example 1:\nInput: nums1 = [4,1,2], nums2 = [1,3,4,2] Output: [-1,3,-1] Explanation: 對於 nums1 中的每個元素，在 nums2 中找到下一個更大的元素 Example 2:\nInput: nums1 = [2,4], nums2 = [1,2,3,4] Output: [3,-1] Explanation: 對於 nums1 中的每個元素，在 nums2 中找到下一個更大的元素 解題思路 # 這題要求我們對於 nums1 中的每個元素，在 nums2 中找到該元素右側第一個比它大的元素。如果沒有找到，則返回 -1。\n解法 # 我們可以使用 stack 來解決這個問題。具體步驟如下：\n使用stack來維護 nums2 中的元素 使用 HashMap 來存儲每個元素的下一個更大元素 遍歷 nums2，對於每個元素，如果stack頂元素小於當前元素，則更新 HashMap 最後根據 nums1 中的元素從 HashMap 中獲取結果 例子說明 # nums1 = [4,1,2], nums2 = [1,3,4,2]\n初始情況：stack = []，map = {} 處理元素 1：\nstack為空，直接將 1 入stack stack = [1] 處理元素 3：\nstack頂元素 1 \u0026lt; 3，將 1 出stack並記錄 map[1] = 3 stack為空，將 3 入stack stack = [3]，map = {1: 3} 處理元素 4：\nstack頂元素 3 \u0026lt; 4，將 3 出stack並記錄 map[3] = 4 stack為空，將 4 入stack stack = [4]，map = {1: 3, 3: 4} 處理元素 2：\nstack頂元素 4 \u0026gt; 2，直接將 2 入stack stack = [4, 2]，map = {1: 3, 3: 4} 最終結果：\n對於 nums1[0] = 4：map 中沒有 4，返回 -1 對於 nums1[1] = 1：map[1] = 3 對於 nums1[2] = 2：map 中沒有 2，返回 -1 結果：[-1, 3, -1] 完整程式碼 # import java.util.*; class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 使用stack來維護nums2中的元素 HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 存儲每個元素的下一個更大元素 // 遍歷nums2，使用單調stack找出每個元素的下一個更大元素 for (int nums : nums2) { // 如果stack不為空且stack頂元素小於當前元素，則更新map while (!stack.isEmpty() \u0026amp;\u0026amp; stack.peek() \u0026lt; nums) { map.put(stack.pop(), nums); // 將stack頂元素出stack並記錄其下一個更大元素 } stack.push(nums); // 將當前元素入stack } // 根據nums1中的元素從map中獲取結果 int[] res = new int[nums1.length]; for (int i = 0; i \u0026lt; res.length; i++) { // 如果map中存在該元素的下一個更大元素，則返回該值，否則返回-1 res[i] = map.containsKey(nums1[i]) ? map.get(nums1[i]) : -1; } return res; } } 時間複雜度 # 時間複雜度：O(n + m)，其中 n 是 nums2 的長度，m 是 nums1 的長度 空間複雜度：O(n)，用於存儲 stack 和 HashMap ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/easy/leetcode496/","section":"技術文章","summary":"","title":"leetcode 496 - Next Greater Element I","type":"tech-articles"},{"content":" 題目 # leetcode 503 - Next Greater Element II (題目說明請點連結)\n範例 # Example 1:\nInput: nums = [1,2,1] Output: [2,-1,2] Explanation: 對於每個元素，找到下一個更大的元素（可以循環查找） Example 2:\nInput: nums = [1,2,3,4,3] Output: [2,3,4,-1,4] Explanation: 對於每個元素，找到下一個更大的元素（可以循環查找） 解題思路 # 這題要求我們對於數組中的每個元素，找到下一個更大的元素。與 leetcode 496不同的是，這題的數組是循環的，也就是說可以從數組末尾回到開頭繼續查找下一個更大的元素。\n解法 # 我們可以使用 stack 來解決這個問題。具體步驟如下：\n使用 stack 來維護數組中的索引 初始化結果數組，所有元素設為 -1 遍歷數組兩次（模擬循環），對於每個元素，如果 stack 頂元素對應的值小於當前元素，則更新結果 只在第一次遍歷時將索引加入 stack 例子說明 # nums = [1,2,1]\n初始情況：stack = []，res = [-1, -1, -1] 第一次遍歷：\ni = 0, num = 1：stack 為空，將索引 0 入 stack i = 1, num = 2：stack 頂元素對應的值 1 \u0026lt; 2，更新 res[0] = 2，將索引 1 入 stack i = 2, num = 1：stack 頂元素對應的值 2 \u0026gt; 1，將索引 2 入 stack 第二次遍歷：\ni = 3, num = 1：stack 頂元素對應的值 1 = 1，將索引 0 入 stack i = 4, num = 2：stack 頂元素對應的值 1 \u0026lt; 2，更新 res[2] = 2 i = 5, num = 1：stack 頂元素對應的值 2 \u0026gt; 1，將索引 1 入 stack 最終結果：\nres = [2, -1, 2] 完整程式碼 # import java.util.*; class Solution { public int[] nextGreaterElements(int[] nums) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 使用stack來維護數組中的索引 int n = nums.length, res[] = new int[n]; // 初始化結果數組 Arrays.fill(res, -1); // 將所有結果設為-1 // 遍歷數組兩次，模擬循環查找 for (int i = 0; i \u0026lt; n * 2; i++) { int num = nums[i % n]; // 獲取當前元素（模擬循環） // 如果stack不為空且stack頂元素對應的值小於當前元素，則更新結果 while (!stack.isEmpty() \u0026amp;\u0026amp; nums[stack.peek()] \u0026lt; num) { res[stack.pop()] = num; // 更新stack頂元素的下一個更大元素 } // 只在第一次遍歷時將索引加入stack if (i \u0026lt; n) { stack.push(i); } } return res; } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是數組的長度 空間複雜度：O(n)，用於存儲 stack ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode503/","section":"技術文章","summary":"","title":"leetcode 503 - Next Greater Element II","type":"tech-articles"},{"content":" 題目 # leetcode 560 - Subarray Sum Equals K (題目說明請點連結)\n範例 # Example 1:\nInput: nums = [1, 1, 1], k = 2 Output: 2 Example 2:\nInput: nums = [1, 2, 3], k = 3 Output: 2 解題思路 # 這題目要求我們找出數組中和為 k 的子數組的個數。可以使用 前綴和 和 HashMap 來解決這個問題，這樣能夠高效處理，時間複雜度為 O(n)。\n什麼是前綴和與HashMap # 前綴和（Prefix Sum） 其實就是從數組的開頭開始，累加每一個數字，直到某個位置。對於數組中的任意子數組 [i, j]，它的和其實就是 sum[j] - sum[i-1]，其中 sum[i-1] 表示從頭到 i-1 的和。 舉個例子，假設有一個數組 nums = [2, 3, 1, 4]，我們可以計算它的前綴和陣列 sum 為：\nsum[0] = 2 sum[1] = 2 + 3 = 5 sum[2] = 2 + 3 + 1 = 6 sum[3] = 2 + 3 + 1 + 4 = 10 如果我們想知道 nums[1] 到 nums[3]（也就是 [3, 1, 4]）的和是多少，可以用 sum[3] - sum[0] = 10 - 2 = 8，這就是前綴和的應用。\n我們的目標是找到一組子數組，使得它們的和為 k。所以每當我們累加一個數字時，我們就去查HashMap中是否存在 total - k，如果存在，則說明這個位置之前的某個地方到現在的位置的子數組和正好是 k。 解法 # 每次遍歷到一個數字時，把它加到目前的總和 total，然後去HashMap裡查有沒有 total - k 這個值。如果有，代表之前某個位置到現在的子數組和剛好是 k，那就把這個值在HashMap出現的次數加到答案裡。\n為了確保能計算從陣列開頭開始的子數組，我們一開始就把HashMap設成 map = {0: 1}，這樣如果一開始的總和就等於 k，也能正確計算進去。\n例子說明 # nums = [3, 4, 7, 2, -3, 1, 4, 2], k = 7\n初始情況：map = {0: 1}, total = 0, result = 0 處理第一個數字 3：\ntotal = 3 查HashMap map 是否有 3 - 7 = -4，沒有。 更新 map，map = {0: 1, 3: 1}。 處理第二個數字 4：\ntotal = 7 查HashMap map 是否有 7 - 7 = 0，找到了，map.get(0) = 1，結果 result += 1，result = 1。 更新 map，map = {0: 1, 3: 1, 7: 1}。 處理第三個數字 7：\ntotal = 14 查HashMap map 是否有 14 - 7 = 7，找到了，map.get(7) = 1，結果 result += 1，result = 2。 更新 map，map = {0: 1, 3: 1, 7: 1, 14: 1}。 處理第四個數字 2：\ntotal = 16 查HashMap map 是否有 16 - 7 = 9，沒有找到。 更新 map，map = {0: 1, 3: 1, 7: 1, 14: 1, 16: 1}。 處理第五個數字 -3：\ntotal = 13 查HashMap map 是否有 13 - 7 = 6，沒有找到。 更新 map，map = {0: 1, 3: 1, 7: 1, 14: 1, 16: 1, 13: 1}。 處理第六個數字 1：\ntotal = 14 查HashMap map 是否有 14 - 7 = 7，找到了，map.get(7) = 1，結果 result += 1，result = 3。 更新 map，map = {0: 1, 3: 1, 7: 1, 14: 2, 16: 1, 13: 1}。 處理第七個數字 4：\ntotal = 18 查HashMap map 是否有 18 - 7 = 11，沒有找到。 更新 map，map = {0: 1, 3: 1, 7: 1, 14: 2, 16: 1, 13: 1, 18: 1}。 處理第八個數字 2：\ntotal = 20 查HashMap map 是否有 20 - 7 = 13，找到了，map.get(13) = 1，結果 result += 1，result = 4。 更新 map，map = {0: 1, 3: 1, 7: 1, 14: 2, 16: 1, 13: 1, 18: 1, 20: 1}。 最終結果是 4，即有四個子數組的和為 7。\n完整程式碼 # import java.util.HashMap; class Solution { public int subarraySum(int[] nums, int k) { int result = 0, total = 0; // 初始化結果和累計和 HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 創建HashMap存儲前綴和及其出現次數 map.put(0, 1); // 初始化，確保能計算從開頭開始的子數組 for (int num : nums) { // 遍歷數組中的每個數字 total += num; // 累加當前數字到總和 if (map.containsKey(total - k)) { // 檢查是否存在前綴和等於total-k result += map.get(total - k); // 如果存在，將出現次數加到結果中 } map.put(total, map.getOrDefault(total, 0) + 1); // 更新當前前綴和的出現次數 } return result; // 返回結果 } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是數組的長度 空間複雜度：O(n)，用於存儲 HashMap ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode560/","section":"技術文章","summary":"","title":"leetcode 560 - Subarray Sum Equals K","type":"tech-articles"},{"content":" 題目 # leetcode 735 - Asteroid Collision (題目說明請點連結)\n範例 # Example 1:\nInput: asteroids = [5, 10, -5] Output: [5, 10] Explanation: The asteroid -5 collides with 10 and is destroyed. Example 2:\nInput: asteroids = [8, -8] Output: [] Explanation: The asteroid 8 collides with -8 and both are destroyed. Example 3:\nInput: asteroids = [10, 2, -5] Output: [10] Explanation: The asteroid -5 collides with 2 and destroys it, then collides with 10 and is destroyed. 解題思路 # 這題要求模擬行星碰撞的過程，規則如下：\n每顆行星的值代表其大小與方向： 正值表示向右移動。 負值表示向左移動。 當行星相遇時： 若方向相同，則繼續前進。 若相對方向，則發生碰撞，較小的行星被摧毀。 若兩顆行星大小相等，則都被摧毀。 需要維護行星的最終狀態。 使用 Stack（堆疊） 來解決這個問題：\n依序遍歷 asteroids 陣列，將行星推入堆疊。 若遇到負值行星，則檢查堆疊頂端是否為正值行星，並進行碰撞處理。 持續彈出較小的行星，直到找到適當的位置。 最後返回堆疊中的行星作為結果。 例子說明 # asteroids = [10, 2, -5]\n初始情況：stack = [] 處理第一個行星 10：\n正值，直接推入堆疊，stack = [10] 處理第二個行星 2：\n正值，直接推入堆疊，stack = [10, 2] 處理第三個行星 -5：\n負值，檢查堆疊頂端 2 |-5| = 5 \u0026gt; 2，彈出 2，stack = [10] 繼續檢查堆疊頂端 10 |-5| = 5 \u0026lt; 10，不彈出，stack = [10] 最終 stack = [10] 最終結果：\n返回 [10] 完整程式碼 # import java.util.Stack; class Solution { public int[] asteroidCollision(int[] asteroids) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 創建堆疊來存儲行星 for (int i = 0; i \u0026lt; asteroids.length; i++) { // 遍歷所有行星 if (asteroids[i] \u0026gt; 0) { // 如果是向右移動的行星（正值） stack.push(asteroids[i]); // 直接推入堆疊 } else { // 如果是向左移動的行星（負值） // 持續彈出較小的向右移動的行星 while (!stack.isEmpty() \u0026amp;\u0026amp; stack.peek() \u0026gt; 0 \u0026amp;\u0026amp; stack.peek() \u0026lt; -asteroids[i]) { stack.pop(); // 彈出較小的行星 } // 如果堆疊頂端有相同大小的行星，兩者都摧毀 if (!stack.isEmpty() \u0026amp;\u0026amp; stack.peek() == -asteroids[i]) { stack.pop(); // 彈出堆疊頂端的行星 } else if (stack.isEmpty() || stack.peek() \u0026lt; 0) { // 如果堆疊為空或頂端是向左移動的行星 stack.push(asteroids[i]); // 推入當前行星 } // 如果堆疊頂端有更大的向右移動的行星，當前行星被摧毀，不推入堆疊 } } // 將堆疊轉換為數組 int[] res = new int[stack.size()]; // 創建結果數組 for (int i = res.length - 1; i \u0026gt;= 0; i--) { // 從後往前填充數組 res[i] = stack.pop(); // 彈出堆疊頂端元素 } return res; // 返回結果 } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是行星數組的長度 空間複雜度：O(n)，用於存儲Stack ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode735/","section":"技術文章","summary":"","title":"leetcode 735 - Asteroid Collision","type":"tech-articles"},{"content":" 題目 # leetcode 739 - Daily Temperatures (題目說明請點連結)\n範例 # Example 1:\nInput: temperatures = [73, 74, 75, 71, 69, 72, 76, 73] Output: [1, 1, 4, 2, 1, 1, 0, 0] Explanation: 在第 0 天後的 1 天內會變暖（74 比 73 高）。 Example 2:\nInput: temperatures = [30, 40, 50, 60] Output: [1, 1, 1, 0] Example 3:\nInput: temperatures = [30, 60, 90] Output: [1, 1, 0] 解題思路 # 這題要求找到每一天之後幾天會出現更高的溫度。\n解法：單調遞減堆疊（Monotonic Stack）\n建立一個 Stack 來存儲溫度的索引。 從後往前遍歷 temperatures 陣列。 如果當前溫度 temperatures[i] 大於等於堆疊頂端對應的溫度，則彈出堆疊。 如果堆疊非空，則計算與堆疊頂端的索引相差的天數，存入結果陣列。 將當前索引推入堆疊。 這種方法確保堆疊內的索引對應的溫度是遞減的，從而能夠快速找到下一個更高的溫度。\n以 Example 1 為例：\n輸入：temperatures = [73, 74, 75, 71, 69, 72, 76, 73] 初始化結果陣列 res = [0,0,0,0,0,0,0,0]，堆疊 stack = [] 從後往前遍歷：\ni = 7，溫度 73，堆疊為空，res[7]=0，stack=[7] i = 6，溫度 76，stack.top=7 (73 \u0026lt; 76)，所以 stack 清空，res[6]=0，stack=[6] i = 5，溫度 72，stack.top=6 (76 \u0026gt; 72)，res[5]=6-5=1，stack=[6,5] i = 4，溫度 69，stack.top=5 (72 \u0026gt; 69)，res[4]=5-4=1，stack=[6,5,4] i = 3，溫度 71，stack.top=4 (69 \u0026lt; 71)，彈出4，stack.top=5 (72 \u0026gt; 71)，res[3]=5-3=2，stack=[6,5,3] i = 2，溫度 75，stack.top=3 (71 \u0026lt; 75)，彈出3，stack.top=5 (72 \u0026lt; 75)，彈出5，stack.top=6 (76 \u0026gt; 75)，res[2]=6-2=4，stack=[6,2] i = 1，溫度 74，stack.top=2 (75 \u0026gt; 74)，res[1]=2-1=1，stack=[6,2,1] i = 0，溫度 73，stack.top=1 (74 \u0026gt; 73)，res[0]=1-0=1，stack=[6,2,1,0] 最終結果 res = [1, 1, 4, 2, 1, 1, 0, 0]\n這代表：\n第 0 天後 1 天會變暖（74 \u0026gt; 73） 第 1 天後 1 天會變暖（75 \u0026gt; 74） 第 2 天後 4 天會變暖（76 \u0026gt; 75） 以此類推 完整程式碼 # import java.util.Stack; class Solution { public int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; int[] res = new int[n]; // 用來存放每一天要等幾天才會變暖 Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 單調遞減堆疊，存放溫度的索引 // 從後往前遍歷溫度陣列 for (int i = n - 1; i \u0026gt;= 0; i--) { // 如果堆疊不為空，且當前溫度大於等於堆疊頂端的溫度，則彈出堆疊 while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[i] \u0026gt;= temperatures[stack.peek()]) { stack.pop(); } // 如果堆疊不為空，代表堆疊頂端的索引對應的溫度比當前高 if (!stack.isEmpty()) { res[i] = stack.peek() - i; // 計算距離 } // 將當前索引壓入堆疊 stack.push(i); } return res; } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是溫度數組的長度 空間複雜度：O(n)，用於存儲Stack ","date":"2025年2月3日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode739/","section":"技術文章","summary":"","title":"leetcode 739 - Daily Temperatures","type":"tech-articles"},{"content":"","date":"2025年2月3日","externalUrl":null,"permalink":"/tags/stack-problem/","section":"Tags","summary":"","title":"Stack Problem","type":"tags"},{"content":"過年正好有回台灣，就看到高雄港有展出巨型吉依卡哇的消息，就開車前往順便跟家人去高雄玩。\n高雄港 # 抵達附近停車場，停好車出來遠處就看到小八的屁股 全家也剛好有聯名活動，飲料杯是吉依卡哇的圖案 三隻分別在高雄港的不同位置，不過都是走路能到的距離，順便逛高雄港。 烏薩奇 # 只有烏薩奇在陸地上，而且最小隻。 吉伊卡哇 # 小八 # ","date":"2025年1月28日","externalUrl":null,"permalink":"/daily-notes/daily-life/kaohsiung-chiikawa/","section":"Daily-Notes","summary":"","title":"高雄 | 吉伊卡哇燈會","type":"daily-notes"},{"content":"","date":"2025年1月28日","externalUrl":null,"permalink":"/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/","section":"Categories","summary":"","title":"日常生活","type":"categories"},{"content":"","date":"2025年1月20日","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"","date":"2025年1月20日","externalUrl":null,"permalink":"/categories/hugo%E7%B6%B2%E7%AB%99%E7%9B%B8%E9%97%9C/","section":"Categories","summary":"","title":"Hugo網站相關","type":"categories"},{"content":"在 Hugo 網站中加入 Disqus 評論系統，讓部落格文章下方可以顯示留言區，提升讀者互動。\n1.建立 Disqus 帳號並取得 shortname # 前往 Disqus 官網 註冊帳號。 建立一個新的網站，取得你的 shortname 2.新增 Disqus partial 檔案 # 建立好專案後，點擊左上角Installation，因為選項沒有Hugo，所以選擇下方的Universal Code install instructions。 接著將代碼複製起來，在 layouts/partials/ 目錄下建立 disqus.html，內容如下：\n\u0026lt;div style=\u0026#34;margin-top: 4rem;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;hr style=\u0026#34;margin-bottom: 2rem; border-top: 1.5px solid #ccc;\u0026#34; /\u0026gt; \u0026lt;div id=\u0026#34;disqus_thread\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var disqus_config = function () { this.page.url = \u0026#39;{{ .Permalink }}\u0026#39;; this.page.identifier = \u0026#39;{{ .File.Path }}\u0026#39;; }; (function() { var d = document, s = d.createElement(\u0026#39;script\u0026#39;); s.src = \u0026#39;https://你的-shortname.disqus.com/embed.js\u0026#39;; s.setAttribute(\u0026#39;data-timestamp\u0026#39;, +new Date()); (d.head || d.body).appendChild(s); })(); \u0026lt;/script\u0026gt; \u0026lt;noscript\u0026gt; 請啟用 JavaScript 以檢視 \u0026lt;a href=\u0026#34;https://disqus.com/?ref_noscript\u0026#34;\u0026gt;由 Disqus 提供的評論\u0026lt;/a\u0026gt; \u0026lt;/noscript\u0026gt; 記得將 你的-shortname 替換成你自己的 Disqus shortname。\n3.在文章模板插入 partial # 打開 layouts/_default/single.html，在文章內容（{{ .Content }}）之後插入：\n{{ partial \u0026#34;disqus.html\u0026#34; . }} 4.設定 config.toml # 在網站根目錄的 config.toml 加入：\ndisqusShortname = \u0026#34;你的-shortname\u0026#34; 5.重啟Hugo查看顯示效果 # 完成上述步驟後，重新啟動 Hugo 網站，文章下方就會出現 Disqus 留言區。\n注意事項 # 若要自訂顯示條件，可用 if 判斷只在特定文章顯示。 若留言區未顯示，請檢查 shortname 是否正確、網路是否可連 Disqus。 ","date":"2025年1月20日","externalUrl":null,"permalink":"/tech-articles/hugo-website/add-disqus/","section":"技術文章","summary":"","title":"在 Hugo 網站加入 Disqus ","type":"tech-articles"},{"content":"前幾天終於搶到 吉伊卡哇拉麵的整理卷，之前在名古屋PARCO的拉麵沒有機會吃到， 終於大阪也開張了地點就位在大阪 心齋橋 PARCO B2。\n預約、點餐 # 需事先在LivePocket-Ticket購入整理卷。 到現場之後，出示整理卷上的 QR Code 給工作人員掃，等待入場的期間，線上進行點餐。 拉麵 # 點完餐後，店員會直接帶入座，在座位上等待拉麵上來。 座位上會擺著所選的餐點立牌，可以先拍照。 為了烏薩奇點了大碗的，味道是不錯， 不過麵太多吃到後面有點膩，沒有什麼轉味的元素。 ","date":"2025年1月17日","externalUrl":null,"permalink":"/daily-notes/japan-life/chiikawa-ramen/","section":"Daily-Notes","summary":"","title":"大阪 | 心齋橋 PARCO 吉伊卡哇拉麵","type":"daily-notes"},{"content":"","date":"2025年1月12日","externalUrl":null,"permalink":"/tags/binary-search-problem/","section":"Tags","summary":"","title":"Binary Search Problem","type":"tags"},{"content":" 題目 # leetcode 1011 - Capacity To Ship Packages Within D Days (題目說明請點連結)\n範例 # Example 1:\nInput: weights = [1,2,3,4,5,6,7,8,9,10], days = 5 Output: 15 Explanation: 船隻容量為 15 時，可以在 5 天內運送所有包裹 Example 2:\nInput: weights = [3,2,2,4,1,4], days = 3 Output: 6 Explanation: 船隻容量為 6 時，可以在 3 天內運送所有包裹 Example 3:\nInput: weights = [1,2,3,1,1], days = 4 Output: 3 Explanation: 船隻容量為 3 時，可以在 4 天內運送所有包裹 解題思路 # 這題要求我們找到船隻的最小容量，使得所有包裹能在指定的天數內運送完成。\n問題分析 # 給定包裹重量陣列和運送天數 需要找到船隻的最小容量 船隻容量必須大於等於任何單個包裹的重量 返回滿足條件的最小容量 解法：二分搜尋 # 二分搜尋：在可能的容量範圍內搜尋最小容量 可行性檢查：檢查給定容量是否能在指定天數內運送所有包裹 範圍確定：左邊界為最大包裹重量，右邊界為所有包裹重量總和 演算法步驟：\n確定搜尋範圍\n左邊界：最大包裹重量（船隻必須能裝下任何單個包裹） 右邊界：所有包裹重量總和（最壞情況） 二分搜尋\n計算中間容量 檢查該容量是否可行 根據結果調整搜尋範圍 可行性檢查\n模擬運送過程 計算需要的天數 判斷是否在指定天數內完成 例子說明 # 輸入： weights = [1,2,3,4,5,6,7,8,9,10], days = 5\n步驟 1：確定搜尋範圍\n左邊界：10（最大包裹重量） 右邊界：55（所有包裹重量總和） 步驟 2：二分搜尋\n中間容量：32 檢查可行性：需要 3 天，可行 調整範圍：[10, 32] 步驟 3：繼續搜尋\n中間容量：21 檢查可行性：需要 4 天，可行 調整範圍：[10, 21] 答案： 15（最小可行容量）\n完整程式碼 # import java.util.*; class Solution { public int shipWithinDays(int[] weights, int days) { int left = 0, right = 0; // 二分搜尋的左右邊界 // 計算搜尋範圍：左邊界為最大包裹重量，右邊界為所有包裹重量總和 for (int w : weights) { left = Math.max(left, w); // 左邊界必須大於等於任何單個包裹的重量 right += w; // 右邊界為所有包裹重量總和 } // 二分搜尋最小可行容量 while (left \u0026lt; right) { int mid = left + (right - left) / 2; // 計算中間容量 if (hasCapacityToShip(days, mid, weights)) { // 檢查該容量是否可行 right = mid; // 如果可行，嘗試更小的容量 } else { left = mid + 1; // 如果不可行，嘗試更大的容量 } } return left; // 返回最小可行容量 } // 檢查給定容量是否能在指定天數內運送所有包裹 public boolean hasCapacityToShip(int days, int capacity, int[] weights) { int need = 1; // 需要的天數，初始為1 int current = 0; // 當前船隻的載重量 // 模擬運送過程 for (int w : weights) { // 如果加上當前包裹會超過容量，需要新的一天 if (current + w \u0026gt; capacity) { current = 0; // 重置載重量 need++; // 天數加1 } current += w; // 將包裹加入船隻 } return need \u0026lt;= days; // 判斷是否在指定天數內完成 } } 時間複雜度 # 時間複雜度：O(n × log(sum(weights)))，其中 n 是包裹數量 空間複雜度：O(1)，只使用常數額外空間 ","date":"2025年1月12日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode1011/","section":"技術文章","summary":"","title":"leetcode 1011 - Capacity To Ship Packages Within D Days","type":"tech-articles"},{"content":" 題目 # leetcode 1231 - Divide Chocolate(題目說明請點連結)\nExample 1:\nInput: sweetness = [1,2,3,4,5,6,7,8,9], K = 5\nOutput: 6\nExplanation: You can divide the chocolate to [1,2,3], [4,5], [6], [7], [8], [9]\nExample 2:\nInput: sweetness = [5,6,7,8,9,1,2,3,4], K = 8\nOutput: 1\nExplanation: There is only one way to cut the bar into 9 pieces.\nExample 3:\nInput: sweetness = [1,2,2,1,2,2,1,2,2], K = 2\nOutput: 5\nExplanation: You can divide the chocolate to [1,2,2], [1,2,2], [1,2,2]\n解題思路 # 輸入為一個sweetness的甜度陣列，與需要分給k個朋友(要包含自己)，\n輸出為將巧克力切成 k+1 塊的所有人能得到甜度中的最小值。\n此題思路與 leetcode410 類似，但要搜尋目標的不同。 比較Leetcode 410 與 Leetcode 1231 # Leetcode 410：最小化最大值\n更新邏輯：當找到可行解時，我們嘗試更小的最大值，右邊界 right=mid。\n因為需要試探更小的範圍，用 下取中間值。\nLeetcode 1231：最大化最小值\n更新邏輯：當找到可行解時，我們嘗試更大的最小值，左邊界 left=mid。\n因為需要試探更大的範圍，用 上取中間值。\n這裡搜尋最大化最小值將二分法設定範圍如下：\n左邊界（min）：陣列之中的最小甜度。\nmin=min(sweetness) 右邊界（max）：所有甜度的總和。\nmax=∑(sweetness) 二分搜索過程：\n初始化二分範圍為 [min,max]。 計算中間值 mid=(min+max+1)/2。 建立canSplit方法驗證 mid 是否可行： 如果可行，更新左邊界 min=mid，嘗試更大甜度。 如果不可行，更新右邊界 max=mid-1。 最後當 min(left)==max(right)，找到答案 例子說明 # sweetness = [1,2,3,4,5,6,7,8,9], k = 5\n初始情況：left = 1（最小甜度），right = 45（總甜度） 第一次二分：mid = 23\n檢查是否能分成 6 塊，每塊甜度至少 23 不可行，right = mid - 1 = 22 第二次二分：mid = 11\n檢查是否能分成 6 塊，每塊甜度至少 11 可行，left = mid = 11 第三次二分：mid = 16\n檢查是否能分成 6 塊，每塊甜度至少 16 可行，left = mid = 16 繼續二分\u0026hellip;\n最終找到最大可行值 6 最終結果：\n返回 6 完整程式碼 # class Solution { public int maximizeSweetness(int [] sweetness, int k) { int left = Integer.MAX_VALUE; // 初始化左邊界為最大值 int right = 0; // 初始化右邊界為0 for (int sweet : sweetness) { // 遍歷甜度數組 if (sweet \u0026lt; left) { // 找到最小甜度 left = sweet; } right += sweet; // 累計總甜度 } while (left \u0026lt; right) { // 當left小於right時繼續搜索 int mid = left + (right - left + 1) / 2; // 計算中間值，使用上取整 if(canSplit(sweetness, k, mid)) { // 檢查是否能分成k+1塊，每塊甜度至少mid left = mid; // 如果可行，嘗試更大的最小值 } else { right = mid - 1; // 如果不可行，嘗試更小的最大值 } } return left; // 返回最大可行值 } public boolean canSplit(int [] sweetness, int k, int minSweetness) { int count = 0; // 記錄已分割的塊數 int sum = 0; // 當前塊的甜度總和 for(int sweet : sweetness) { // 遍歷甜度數組 sum += sweet; // 累加當前甜度 if(sum \u0026gt;= minSweetness) { // 如果當前塊的甜度達到最小值 sum = 0; // 重置當前塊的甜度 count++; // 增加塊數 } } if(count \u0026gt;= k + 1) { // 如果能分成至少k+1塊 return true; // 可行 } return false; // 不可行 } } 時間複雜度 # 時間複雜度：O(n log S)，其中 n 是數組的長度，S 是甜度總和 空間複雜度：O(1)，只使用了常數額外空間 ","date":"2025年1月10日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode1231/","section":"技術文章","summary":"","title":"leetcode 1231 - Divide Chocolate","type":"tech-articles"},{"content":" 題目 # leetcode 141 - Linked List Cycle(題目說明請點連結)\nExample 1:\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\nExample 2:\nInput: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\nExample 3:\nInput: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list.\n解題思路 # 這題確認 Linked List 是否有 Cycle ，回傳true、flase。\n可以用上快慢指針確認是否有Cycle：\nslow 一次走1個節點，fast 一次走2個節點，只要 fast 與 slow 相遇即是有Cycle。\n初始情況：slow = head = 3，fast = head = 3 第一次迭代：\nslow = slow.next = 2 fast = fast.next.next = 0 slow = 2，fast = 0 第二次迭代：\nslow = slow.next = 0 fast = fast.next.next = 2 slow = 0，fast = 2 第三次迭代：\nslow = slow.next = -4 fast = fast.next.next = 0 slow = -4，fast = 0 第四次迭代：\nslow = slow.next = 2（回到節點2） fast = fast.next.next = 2（回到節點2） slow = 2，fast = 2 slow == fast，返回 true 完整程式碼 # public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; // 初始化快指針，指向頭節點 ListNode slow = head; // 初始化慢指針，指向頭節點 while(fast != null \u0026amp;\u0026amp; fast.next != null) { // 當快指針和快指針的下一個節點不為空時 fast = fast.next.next; // 快指針每次移動兩步 slow = slow.next; // 慢指針每次移動一步 if(fast == slow) { // 如果快指針和慢指針相遇 return true; // 有環 } } return false; // 無環 } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是鏈表中節點的數量 空間複雜度：O(1)，只使用了常數額外空間 ","date":"2025年1月10日","externalUrl":null,"permalink":"/tech-articles/leetcode/easy/leetcode141/","section":"技術文章","summary":"","title":"leetcode 141 - Linked List Cycle","type":"tech-articles"},{"content":" 題目 # leetcode 237 - Delete Node in a Linked List(題目說明請點連結)\nExample 1:\nInput: head = [4,5,1,9], node = 5\nOutput: [4,1,9]\nExplanation: You are given the second node with value 5,\nthe linked list should become 4 -\u0026gt; 1 -\u0026gt; 9 after calling your function.\nExample 2:\nInput: head = [4,5,1,9], node = 1\nOutput: [4,5,9]\nExplanation: You are given the third node with value 1,\nthe linked list should become 4 -\u0026gt; 5 -\u0026gt; 9 after calling your function.\n解題思路 # 這題就是實作Linked List 的 Delete Node Function。\n例子說明 # head = [4,5,1,9], node = 5\n初始情況：4 -\u0026gt; 5 -\u0026gt; 1 -\u0026gt; 9，要刪除節點 5 複製下一個節點的值：\nnode.val = node.next.val 節點 5 的值變成 1 鏈表變成：4 -\u0026gt; 1 -\u0026gt; 1 -\u0026gt; 9 跳過下一個節點：\nnode.next = node.next.next 節點 5 的 next 指向節點 9 鏈表變成：4 -\u0026gt; 1 -\u0026gt; 9 完成刪除：\n原本的節點 5 被\u0026quot;覆蓋\u0026quot;為節點 1 實際上是將下一個節點的值複製到當前節點，然後跳過下一個節點 完整程式碼 # class Solution { public void deleteNode(ListNode node) { node.val = node.next.val; // 將下一個節點的值複製到當前節點 node.next = node.next.next; // 跳過下一個節點，直接指向下下個節點 } } 時間複雜度 # 時間複雜度：O(1)，只需要常數時間操作 空間複雜度：O(1)，只使用了常數額外空間 ","date":"2025年1月10日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode237/","section":"技術文章","summary":"","title":"leetcode 237 - Delete Node in a Linked List","type":"tech-articles"},{"content":" 題目 # leetcode 1062 - Split Array Largest Sum(題目說明請點連結)\nExample 1:\nInput: nums = [7,2,5,10,8], k = 2\nOutput: 18\nExplanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\nExample 2:\nInput: nums = [1,2,3,4,5], k = 2\nOutput: 9\nExplanation: There are four ways to split nums into two subarrays. The best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.\n解題思路 # 輸入為一個字串，輸出為能切成的K群數內子集合其中最大的總和，舉例：\nnums = [7,2,5,10,8] 可以被分成 k = 2 群數的子集合，\n[7,2,5] 和 [10,8]，其中最大的和為18(10+8)。\n我們的目標是最小化子結合的最大和（即答案），這是一個 有序範圍問題，因為：\n當分割數 k 增加時，每個子集合的和會減小（子集合更短）。\n當分割數 k 減少時，每個子集合的和會增大（子集合更長）。\n而問題可以轉化為判斷 sum 是否滿足條件，將數組劃分為 k 個子集合，且每個子集合的和都不超過 sum。\n而其單調性也符合使用二分搜索的條件，二分法範圍如下：\n左邊界（min）：陣列中的最大值，因為任何子集合的和都至少等於其陣列當中的最大值。\nmin=max(nums) 右邊界（max）：所有數字的總和，因為當 k=1 時，所有數字都在一個子集合中。\nmax=∑(nums) 二分搜索過程：\n初始化二分範圍為 [min,max]。 計算中間值 mid=(min+max)/2。 建立canSplit方法驗證 mid 是否可行(其最大值mid是否能分成k群)： 如果可行，更新右邊界 max=mid，嘗試更小的最大和。 如果不可行，更新左邊界 min=mid+1。 最後當 min(left)==max(right)，找到答案 例子說明 # nums = [7,2,5,10,8], k = 2\n初始情況：left = 10（最大值），right = 32（總和） 第一次二分：mid = 21\n檢查是否能分成 2 個子集合，每個子集合和 ≤ 21 可行：[7,2,5] 和 [10,8]，right = mid = 21 第二次二分：mid = 15\n檢查是否能分成 2 個子集合，每個子集合和 ≤ 15 不可行，left = mid + 1 = 16 第三次二分：mid = 18\n檢查是否能分成 2 個子集合，每個子集合和 ≤ 18 可行：[7,2,5] 和 [10,8]，right = mid = 18 第四次二分：mid = 17\n檢查是否能分成 2 個子集合，每個子集合和 ≤ 17 不可行，left = mid + 1 = 18 最終結果：\nleft = 18，返回 18 完整程式碼 # class Solution { public int splitArray(int[] nums, int k) { int left = 0; // 初始化左邊界 int right = 0; // 初始化右邊界 for(int num : nums) { // 遍歷數組 if(num \u0026gt; left) { // 找到最大值作為左邊界 left = num; } right += num; // 累計總和作為右邊界 } while(left \u0026lt; right) { // 當left小於right時繼續搜索 int mid = left + (right - left) / 2; // 計算中間值 if(canSplit(nums, k, mid)) { // 檢查是否能分成k個子集合，每個子集合和≤mid right = mid; // 如果可行，嘗試更小的最大和 } else { left = mid + 1; // 如果不可行，嘗試更大的最大和 } } return left; // 返回最小可行值 } public boolean canSplit(int nums[], int k, int maxValue) { int sum = 0; // 當前子集合的和 int count = 1; // 已分割的子集合數量 for(int num : nums) { // 遍歷數組 if(sum + num \u0026gt; maxValue) { // 如果加入當前數字會超過最大值 count++; // 開始新的子集合 sum = num; // 重置當前子集合的和 if(count \u0026gt; k) { // 如果子集合數量超過k return false; // 不可行 } } else { sum += num; // 將當前數字加入當前子集合 } } return true; // 可行 } } 時間複雜度 # 時間複雜度：O(n log S)，其中 n 是數組的長度，S 是數組的總和 空間複雜度：O(1)，只使用了常數額外空間 ","date":"2025年1月10日","externalUrl":null,"permalink":"/tech-articles/leetcode/hard/leetcode410/","section":"技術文章","summary":"","title":"leetcode 410 - Split Array Largest Sum","type":"tech-articles"},{"content":" 題目 # leetcode 237 - Reverse Linked List II(題目說明請點連結)\nExample 1:\nInput: head = [1,2,3,4,5], left = 2, right = 4\nOutput: [1,4,3,2,5]\nExample 2:\nInput: head = [5], left = 1, right = 1\nOutput: [5]\n解題思路 # 這題給定一個 linked list 與 left、right。\n回傳從left到right reverse 後的 linked list。\n比如 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5 left = 2 , right = 4\n回傳的答案就是 1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5\n這題我們將每一次的反轉進行逐步交換即可。\n例子說明 # head = [1,2,3,4,5], left = 2, right = 4\n首先建立一個 dummy 作為避免 head 被反轉找不到沒有人指向第一個節點的情況，\n初始情況：dummy -\u0026gt; 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 prev：dummy（指向dummy，值為0） cur：1（指向head，值為1） temp：暫無 找到反轉起始位置：\nprev 移動到節點 1（left-1 = 1），此時 prev 指向1 cur 指向節點 2（left = 2），此時 cur 指向2 temp：暫無 狀態：dummy -\u0026gt; 1(prev) -\u0026gt; 2(cur) -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 第一次交換：\ntemp = cur.next = 3，此時 temp 指向3 cur.next = temp.next = 4，2的next指向4 temp.next = prev.next = 2，3的next指向2 prev.next = temp = 3，1的next指向3 交換後指針狀態： prev：1 cur：2 temp：3 結果：dummy -\u0026gt; 1(prev) -\u0026gt; 3(temp) -\u0026gt; 2(cur) -\u0026gt; 4 -\u0026gt; 5 第二次交換：\ntemp = cur.next = 4，此時 temp 指向4 cur.next = temp.next = 5，2的next指向5 temp.next = prev.next = 3，4的next指向3 prev.next = temp = 4，1的next指向4 交換後指針狀態： prev：1 cur：2 temp：4 結果：dummy -\u0026gt; 1(prev) -\u0026gt; 4(temp) -\u0026gt; 3 -\u0026gt; 2(cur) -\u0026gt; 5 完成反轉：\n返回 dummy.next，即 [1,4,3,2,5] 此時 prev 仍指向1，cur指向2，temp指向4，反轉區間已完成 完整程式碼 # /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { if (head == null || left == right) { // 邊界條件：空鏈表或left等於right return head; } ListNode dummy = new ListNode(0); // 創建虛擬頭節點 dummy.next = head; // 將虛擬頭節點連接到原鏈表 ListNode prev = dummy; // 初始化prev指針 for(int i = 1; i \u0026lt; left; i++) { // 移動prev到left位置的前一個節點 prev = prev.next; } ListNode cur = prev.next; // cur指向left位置的節點 for(int i = 0; i \u0026lt; right - left; i++) { // 執行right-left次交換 ListNode temp = cur.next; // 暫存cur的下一個節點 cur.next = temp.next; // 將cur的next指向temp的下一個節點 temp.next = prev.next; // 將temp的next指向prev的下一個節點 prev.next = temp; // 將prev的next指向temp } return dummy.next; // 返回虛擬頭節點的下一個節點 } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是鏈表中節點的數量 空間複雜度：O(1)，只使用了常數額外空間 ","date":"2025年1月10日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode92/","section":"技術文章","summary":"","title":"leetcode 92 - Reverse Linked List II","type":"tech-articles"},{"content":"","date":"2025年1月10日","externalUrl":null,"permalink":"/tags/linked-list-problem/","section":"Tags","summary":"","title":"Linked List Problem","type":"tags"},{"content":"在日本，新年的首次參拜被稱為初詣（はつもうで）。每到新年，許多日本人會前往神社或寺廟，祈求新的一年平安順利、身體健康。 初詣通常會在1/1到1/3之間進行，有些人則會選擇在元旦當天凌晨就前往參拜。\n1/4 和朋友相約到奈良春日大社進行初詣，這天人潮比較少，順便去奈良看路。\n春日大社 # 從難波搭乘近鐵奈良線，到近鐵奈良站後，轉搭巴士到春日大社，大概1小時左右。 就這樣一路往上走到春日大社。\n1/4來初詣的人潮還是蠻多的。 買了一個鹿造型的籤。 東大寺三月堂 # 參拜結束後，就順便來觀光，一路走到東大寺這邊。 東大寺二月堂 # 剛好看到有人在寫生。\n東大寺鐘樓 # 這個鐘超大的! 東大寺 # 奈良公園 # 太多人在餵仙貝，鹿都不吃了。 興福寺 # 奈良東向通店 # 然後就一路走回商店街，買了中古堂的艾草麻糬。 找了間叫做文楽的店吃午餐，味道還行。 奈良限定鑰匙圈入手！ ","date":"2025年1月4日","externalUrl":null,"permalink":"/daily-notes/japan-life/japanese-new-year-visit/","section":"Daily-Notes","summary":"","title":"奈良 | 日本新年參拜紀錄","type":"daily-notes"},{"content":"","date":"2025年1月4日","externalUrl":null,"permalink":"/tags/%E5%A5%88%E8%89%AF%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"奈良旅遊","type":"tags"},{"content":"","date":"2025年1月4日","externalUrl":null,"permalink":"/tags/%E6%97%A5%E6%9C%AC%E6%B4%BB%E5%8B%95/","section":"Tags","summary":"","title":"日本活動","type":"tags"},{"content":"這天與朋友相約在本願寺跨年，在日本比較少像台灣會這樣放煙火慶祝。大部分日本人會選擇前往寺廟或神社參拜，迎接新的一年。12月31日在日本被稱為大晦日，這天晚上許多寺廟會舉行除夜の鐘活動，敲響108下鐘聲，象徵去除人們一年的煩惱與不安，並祈求新的一年平安順利。\n難波駅 # 約在難波站集合，這天一路上都非常熱鬧，我們就一路走路前往本願寺。 本願寺津村別院（北御堂） # 抵達時已接近晚上11點，敲鐘的整理卷是22:15開始發放，還好還有拿到。 不過是拿到H排的整理卷，應該是蠻後面的。 除夜會 # 除夜の鐘 # 除夜會結束後，所有人就到廣場，等待住持敲響108下鐘聲。 跨年倒數 # 接近0點的時候，階梯上出現投影開始倒數。\n2025新年快樂！ 敲鐘體驗 # 接著會讓有領取整理卷的人，依照上面的字母編號A開始依序上去敲鐘。\n12點過後的日本街道 # 我們每個人都敲完中後就離開本願寺了，沿路走路回去，已經12點多都沒有電車了。 跨年敲鐘12點過後左右的心齋橋還是非常多人。 ラウンドワンスタジアム 千日前店 # 因為朋友都住比較遠，半夜之後就沒有電車能回去了。 所以決定找個能待到早上的地方，發現 Round One 有有跨年活動， 到早上9點之前都可以用裡面的設施，就決定去那邊等到有首班電車了。\n到早上9點前，只要憑卷都可以無限出入，中間想去外面也可以。 非常多設施可以玩，還有漫畫跟卡拉OK。 然後我們就一路待到早上5點有首班車才離開，好久沒有通宵了。\n","date":"2025年1月1日","externalUrl":null,"permalink":"/daily-notes/japan-life/japanese-new-year/","section":"Daily-Notes","summary":"","title":"大阪 | 日本跨年紀錄","type":"daily-notes"},{"content":"","date":"2025年1月1日","externalUrl":null,"permalink":"/tech-articles/","section":"技術文章","summary":"","title":"技術文章","type":"page"},{"content":" 題目 # leetcode 1047 - Remove All Adjacent Duplicates In String(題目說明請點連結)\nExample 1:\nInput: s = \u0026ldquo;abbaca\u0026rdquo;\nOutput: \u0026ldquo;ca\u0026rdquo;\nExplanation: For example, in \u0026ldquo;abbaca\u0026rdquo; we could remove \u0026ldquo;bb\u0026rdquo; since the letters are adjacent and equal, and this is the only possible move.\nThe result of this move is that the string is \u0026ldquo;aaca\u0026rdquo;, of which only \u0026ldquo;aa\u0026rdquo; is possible, so the final string is \u0026ldquo;ca\u0026rdquo;.\nExample 2:\nInput: s = \u0026ldquo;azxxzy\u0026rdquo;\nOutput: \u0026ldquo;ay\u0026rdquo;\n解題思路 # 輸入為一個字串，輸入為一個去除相鄰重複字元後的字串。\n這題可以用Two pointors 的解法去實作。\n以下面為例子：\n分別用i、j二個指針，i為遍歷新字元的指針，j為判斷條件與搜索的答案。\n步驟 字串狀態 指針位置 操作說明 Step 1 abbaca i=0, j=0 i和j同時從0開始，覆蓋字元 abbaca 同時前進覆蓋 Step 2 abbaca i=2, j=1 遇到j當前位置與j-1位置重複 abbaca j退回到j-2位置(即0) abbaca j=0 去除重複字元後繼續 Step 3 abbaca i=3, j=1 繼續同時往下覆蓋 aabaca 此時j、j-1位置又重複 aabaca j=-1 j退回到-1位置 Step 4 abbaca i=4, j=0 繼續覆蓋，j從0開始 cabaca 二指針繼續同時前進 Step 5 abbaca i=5, j=1 i跑到最後一個位置 cabaca 遍歷完成 完整程式碼 # class Solution { public String removeDuplicates(String s) { int j = 0; // 初始化指針 j，用於記錄結果字符的位置 char[] res = s.toCharArray(); // 將字串轉換為字符數組 for(int i = 0; i \u0026lt; s.length(); ++i, ++j) { // 遍歷字符數組，i和j同時前進 res[j] = res[i]; // 將當前字符賦值給 j 指針位置 if(j \u0026gt; 0 \u0026amp;\u0026amp; res[j] == res[j-1]) { // 如果當前字符和前一個字符相同 j -= 2; // j 指針回退兩步，去除重複的字符 } } return new String(res, 0, j); // 返回去重後的字串，只取前j個字符 } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是字串的長度，因為每個字元最多只會被處理兩次（進出j指針）。 空間複雜度：O(n)，用於存儲字符數組 res。 Stack解法 # 其實最一開始的直覺是想到用 stack 去解這道題，\n運用LIFO(Last In First Out)到機制，把給個字元分別放到Stack去做比較，\n每次就檢查相鄰的二個值是否一致;\n1.要放進Stack的值\n2.Stack中最上面的那個值\nStack : ab\nPut in : baca\n相同就Stock pop出去，不相同就放進去繼續比較。\n結束後就能拿到去除重複的字元Stack，在組成字串即為答案。\nclass Solution { public String removeDuplicates(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 初始化一個Stack char[] chars = s.toCharArray(); // 將字串轉換為字符數組 for(char c : chars){ // 遍歷字符數組 if(!stack.isEmpty() \u0026amp;\u0026amp; stack.peek() == c){ // 如果Stack不為空且Stack頂字符與當前字符相同 stack.pop(); // 彈出Stack頂字符 }else { stack.push(c); // 否則將當前字符壓入Stack } } StringBuilder result = new StringBuilder(); // 初始化結果字串 for (char c : stack) { // 遍歷Stack result.append(c); // 將字符添加到結果字串 } return result.toString(); // 返回結果字串 } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是字串的長度 空間複雜度：O(n)，用於存儲字符數組或Stack ","date":"2024年12月30日","externalUrl":null,"permalink":"/tech-articles/leetcode/easy/leetcode1047/","section":"技術文章","summary":"","title":"leetcode 1047 - Remove All Adjacent Duplicates In String","type":"tech-articles"},{"content":" 題目 # leetcode 1062 - Longest Repeating Substring(題目說明請點連結)\nExample 1:\nInput: \u0026ldquo;abcd\u0026rdquo;\nOutput: 0\nExplanation: There is no repeating substring.\nExample 2:\nInput: \u0026ldquo;abbaba\u0026rdquo;\nOutput: 2\nExplanation: The longest repeating substrings are \u0026ldquo;ab\u0026rdquo; and \u0026ldquo;ba\u0026rdquo;, each of which occurs twice.\nExample 3:\nInput: \u0026ldquo;aabcaabdaab\u0026rdquo;\nOutput: 3\nExplanation: The longest repeating substring is \u0026ldquo;aab\u0026rdquo;, which occurs 3 times.\nExample 4:\nInput: \u0026ldquo;aaaaa\u0026rdquo;\nOutput: 4\nExplanation: The longest repeating substring is \u0026ldquo;aaaa\u0026rdquo;, which occurs twice.\n解題思路 # 輸入為一個字串，輸出為字串內重複最多的子字串的次數。\n這題的思路可以利用有序區間和單調性特性：\n假設輸入字符串為 S = \u0026ldquo;aabcaabdaab\u0026rdquo;，我們嘗試檢查不同的子串長度是否有重複。\n子串長度和重複性： 子串長度 𝐿 (aabcaabdaab)\nL 是否有重複子串 重複部分 1 有 單字符如 \u0026ldquo;a\u0026rdquo; 重複多次 2 有 如 \u0026ldquo;aa\u0026rdquo; 或 \u0026ldquo;ab\u0026rdquo; 重複 3 有 如 \u0026ldquo;aab\u0026rdquo; 重複 4 無 沒有重複長度 4 的子串 5 無 沒有重複長度 5 的子串 6 無 沒有重複長度 6 的子串 有序區間：從 1 到 6（子串長度）是有序的，因為是否有重複子串隨著長度變化而遵守規律。\n單調性：\n當 𝐿≤3 時，存在重複子串。\n當 L≥4 時，不存在重複子串。\n透過 Binary search 在這個有序陣列當中找到最大重複的那個數字，\n並寫另外寫一個方法用HashSet來判斷是否有重複值。\n例子說明 # s = \u0026quot;aabcaabdaab\u0026quot;\n初始情況：left = 1，right = 11 第一次二分：mid = 6\n檢查長度 6 的子串是否有重複 沒有重複，right = mid - 1 = 5 第二次二分：mid = 3\n檢查長度 3 的子串是否有重複 \u0026ldquo;aab\u0026rdquo; 重複 3 次，有重複，left = mid = 3 第三次二分：mid = 4\n檢查長度 4 的子串是否有重複 沒有重複，right = mid - 1 = 3 最終結果：\nleft = 3，返回 3 完整程式碼 # class Solution { public int longestRepeatingSubstring(String s) { int left = 1, right = s.length(); // 初始化二分搜索的範圍 while(left \u0026lt; right) { // 當left小於right時繼續搜索 int mid = left + (right - left + 1) / 2; // 計算中間值，使用上取整 if(hasRepeatingSubstring(s, mid)) { // 檢查是否有長度為mid的重複子串 left = mid; // 如果有重複，嘗試更大的長度 } else { right = mid - 1; // 如果沒有重複，嘗試更小的長度 } } return left; // 返回最長重複子串的長度 } public boolean hasRepeatingSubstring(String s, int length) { HashSet\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); // 創建HashSet來存儲子串 for (int i = 0; i \u0026lt;= s.length() - length; i++) { // 遍歷所有可能的起始位置 if(set.contains(s.substring(i, i + length))) { // 檢查當前子串是否已經存在 return true; // 如果存在，說明有重複 } else { set.add(s.substring(i, i + length)); // 將當前子串加入集合 } } return false; // 沒有找到重複子串 } } 時間複雜度 # 時間複雜度：O(n² log n)，其中 n 是字串的長度。\n最佳情況：若字串中很快就找到重複子串，則每次二分時 hasRepeatingSubstring 很快返回，實際遍歷的子串較少，接近 O(n log n)。 最差情況：每次都要完整檢查所有長度為 mid 的子串，且二分 log n 次，每次檢查 O(n) 個子串，每個子串長度 O(n)，所以總體為 O(n² log n)。 空間複雜度：O(n²)，用於存儲所有可能的子串於 HashSet 中。\n","date":"2024年12月30日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode1062/","section":"技術文章","summary":"","title":"leetcode 1062 - Longest Repeating Substring","type":"tech-articles"},{"content":" 題目 # leetcode 26 - Remove Duplicates from Sorted Array\nExample 1:\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: 函數應該回傳 k = 2，nums 前兩個元素為 1 和 2。 後面的元素不重要，可以是任意值。\nExample 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: 函數應該回傳 k = 5，nums 前五個元素為 0, 1, 2, 3, 4。 後面的元素不重要，可以是任意值。\n解題思路 # 輸入為一個排序好的陣列，將nums陣列內容的前k的去除重複的數字由小到大排出。\n首先初始化二個index作為比較的指針i、j，\ni為到結束前作為遍歷指針直到最後一項結束，\nj為判斷有是否有新的重複指針，就會將j所在的直放到該位置，\n因為是排序好的陣列，只要與j位置陣列，判斷有相異就放上新的內容\n步驟 陣列狀態 指針位置 操作說明 Step 1 [0,0,1,1,1,2,2,3,3,4] i=1, j=1 i從1開始，與j-1位置比較，相同所以不做任何操作 [0,_,_,_,_,_,_,_,_,_] 第一個位置保持不變 Step 2 [0,0,1,1,1,2,2,3,3,4] i=2, j=1 與j-1位置比較，不同，將1放入j位置 [0,1,_,_,_,_,_,_,_,_] i=2, j=2 j指針移動到下一個位置 Step 3 [0,0,1,1,1,2,2,3,3,4] i=3, j=2 與j-1位置比較，相同所以不做任何操作 [0,1,_,_,_,_,_,_,_,_] j指針保持不變 Step 4 [0,0,1,1,1,2,2,3,3,4] i=5, j=2 與j-1位置比較，不同，將2放入j位置 [0,1,2,_,_,_,_,_,_,_] i=5, j=3 j指針移動到下一個位置 Step 5 [0,0,1,1,1,2,2,3,3,4] i=7, j=3 與j-1位置比較，不同，將3放入j位置 [0,1,2,3,_,_,_,_,_,_] i=7, j=4 j指針移動到下一個位置 Step 6 [0,0,1,1,1,2,2,3,3,4] i=9, j=4 與j-1位置比較，不同，將4放入j位置 [0,1,2,3,4,_,_,_,_,_] i=9, j=5 j指針移動到下一個位置 Step 7 [0,1,2,3,4,2,2,3,3,4] 遍歷完成，返回j=5 Function 只要回傳相異的K即可。\n完整程式碼 # class Solution { public int removeDuplicates(int[] nums) { int j = 1; // 初始化第二個指針 for (int i = 1; i \u0026lt; nums.length; i++) { // 從第二個元素開始 if (nums[i] != nums[j - 1]) { // 如果當前元素不是重複的 nums[j] = nums[i]; // 將其移動到數組的下一個位置 j++; // 增加第二個指針 } } return j; // 返回沒有重複元素的數組長度 } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是數組的長度 空間複雜度：O(1)，只使用了常數額外空間 ","date":"2024年12月30日","externalUrl":null,"permalink":"/tech-articles/leetcode/easy/leetcode26/","section":"技術文章","summary":"","title":"leetcode 26 - Remove Duplicates from Sorted Array","type":"tech-articles"},{"content":" 題目 # leetcode 344 - Reverse String(題目說明請點連結)\nExample 1:\nInput: s = [\u0026ldquo;h\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;o\u0026rdquo;]\nOutput: [\u0026ldquo;o\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;h\u0026rdquo;]\nExample 2:\nInput: s = [\u0026ldquo;H\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;h\u0026rdquo;]\nOutput: [\u0026ldquo;h\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;H\u0026rdquo;]\n解題思路 # 輸入為一個陣列，輸入為一個反方向陣列的內容，過程中不能建立額外的空間。\n給定index i為0、j陣列長度-1。\n隨著迴圈次數，i逐漸遞增，j逐漸遞減，中止條件當i\u0026gt;j，也就是到中間時交換完畢。\n例子說明 # s = [\u0026quot;h\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;o\u0026quot;]\n初始情況：i = 0，j = 4，s = [\u0026quot;h\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;o\u0026quot;] 第一次迭代：\n交換 s[0] 和 s[4] s = [\u0026quot;o\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;h\u0026quot;] i++，j--，i = 1，j = 3 第二次迭代：\n交換 s[1] 和 s[3] s = [\u0026quot;o\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;h\u0026quot;] i++，j--，i = 2，j = 2 第三次迭代：\ni = 2，j = 2，i == j，停止迭代 最終結果：s = [\u0026quot;o\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;h\u0026quot;] 完整程式碼 # class Solution { public char[] reverseString(char[] s) { // 初始化兩個指針，i從開頭開始，j從結尾開始 int i = 0; int j = s.length - 1; while(i \u0026lt; j) { // 當i小於j時繼續交換 char tmp = s[i]; // 暫存i位置的字符 s[i] = s[j]; // 將j位置的字符放到i位置 s[j] = tmp; // 將暫存的字符放到j位置 i++; // i指針向右移動 j--; // j指針向左移動 } return s; // 返回反轉後的字符數組 } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是字符數組的長度 空間複雜度：O(1)，只使用了常數額外空間 ","date":"2024年12月30日","externalUrl":null,"permalink":"/tech-articles/leetcode/easy/leetcode334/","section":"技術文章","summary":"","title":"leetcode 344 - Rrevese String","type":"tech-articles"},{"content":" 題目 # leetcode 42 - Trapping Rain Water (題目說明請點連結)\nExample 1:\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1].\nIn this case, 6 units of rain water (blue section) are being trapped.\nExample 2:\nInput: height = [4,2,0,3,2,5]\nOutput: 9\n解題思路 # 輸入給定一個牆壁高度的陣列如上圖所示，算出此牆面能累積的總水量。\n此題能使用雙向指針的概念，分別紀錄left與right的位置。 因為水往低處流，分別以maxLeft 與 maxRight 紀錄二側指針由外向內的最高位\n置，每走到一個地方就由二側的最高高度-當前高度，即會得該處的蓄水量。 以圖例為例，\n當left走到該處:\n當前蓄水量為 maxLeft - current，也就是之前紀錄的1 - 當前的高0 = 1\n當right走到該處:\n當前蓄水量為 maxLeft - current，也就是之前紀錄的2 - 當前的高1 = 1 最後left與right 相會結束程式，輸出總水量即可 完整程式碼 # class Solution { public int trap(int[] height) { int left = 0, right = height.length - 1; // 初始化左右指針 int maxLeft = height[left], maxRight = height[right]; // 初始化左右兩側的最大高度 int water = 0; // 初始化總蓄水量 while(left \u0026lt; right) { // 當左右指針未相遇時繼續 if(maxLeft \u0026lt; maxRight) { // 如果左側最大高度小於右側 left++; // 移動左指針 maxLeft = Math.max(maxLeft, height[left]); // 更新左側最大高度 water += maxLeft - height[left]; // 計算當前位置的蓄水量 } else { // 如果右側最大高度小於等於左側 right--; // 移動右指針 maxRight = Math.max(maxRight, height[right]); // 更新右側最大高度 water += maxRight - height[right]; // 計算當前位置的蓄水量 } } return water; // 返回總蓄水量 } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是數組的長度 空間複雜度：O(1)，只使用了常數額外空間 ","date":"2024年12月30日","externalUrl":null,"permalink":"/tech-articles/leetcode/hard/leetcode42/","section":"技術文章","summary":"","title":"leetcode 42 - Trapping Rain Water","type":"tech-articles"},{"content":" 題目 # leetcode 80 - Remove Duplicates from Sorted Array II (題目說明請點連結)\nExample 1:\nInput: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: 函數應該回傳 k = 5，nums 前五個元素為 1, 1, 2, 2, 3。 後面的元素不重要，可以是任意值。\nExample 2:\nInput: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,,]\nExplanation: 函數應該回傳 k = 7，nums 前七個元素為 0, 0, 1, 1, 2, 3, 3。 後面的元素不重要，可以是任意值。\n解題思路 # 此題為 leetcode 26的變形，一樣能用Two pointor的方式去解，輸出的陣列 為，前K的排序好的數字且不能重複二次以上。\n輸入為一個排序好的陣列，將nums陣列內容的前k的去除重複的數字由小到大排出，但允許重複最多二次。\n首先初始化二個index作為比較的指針i、j，\ni為到結束前作為遍歷指針直到最後一項結束，\nj為判斷有是否有新的重複指針，就會將j所在的直放到該位置，\n因為是排序好的陣列，只要與j-2位置陣列，判斷有相異就放上新的內容\n步驟 陣列狀態 指針位置 操作說明 Step 1 [1,1,1,2,2,3] i=2, j=2 i從2開始，與j-2位置比較，相同所以不做任何操作 [1,1,_,_,_,_] 前兩個位置保持不變 Step 2 [1,1,1,2,2,3] i=3, j=2 與j-2位置比較，不同，將2放入j位置 [1,1,2,_,_,_] i=3, j=3 j指針移動到下一個位置 Step 3 [1,1,1,2,2,3] i=4, j=3 與j-2位置比較，不同，將2放入j位置 [1,1,2,2,_,_] i=4, j=4 j指針移動到下一個位置 Step 4 [1,1,1,2,2,3] i=5, j=4 與j-2位置比較，不同，將3放入j位置 [1,1,2,2,3,_] i=5, j=5 j指針移動到下一個位置 Step 5 [1,1,2,2,3,3] 遍歷完成，返回j=5 Function 只要回傳相異的K即可。\n完整程式碼 # class Solution { public int removeDuplicates(int[] nums) { int j = 2; // 初始化指針j，從索引2開始，因為前兩個元素可以保留 for (int i = 2; i \u0026lt; nums.length; i++) { // 從第三個元素開始遍歷 if (nums[i] != nums[j - 2]) { // 如果當前元素與j-2位置的元素不同 nums[j] = nums[i]; // 將當前元素移動到j位置 j++; // 移動j指針到下一個位置 } } return j; // 返回去除重複元素後的數組長度 } } 時間複雜度 # 時間複雜度：O(n)，其中 n 是數組的長度 空間複雜度：O(1)，只使用了常數額外空間 ","date":"2024年12月30日","externalUrl":null,"permalink":"/tech-articles/leetcode/medium/leetcode80/","section":"技術文章","summary":"","title":"leetcode 80 - Remove Duplicates from Sorted Array II","type":"tech-articles"},{"content":"","date":"2024年12月30日","externalUrl":null,"permalink":"/tags/two-pointers-problem/","section":"Tags","summary":"","title":"Two Pointers Problem","type":"tags"},{"content":" Day 1 # 大阪出發 - 名門大洋フェリー # 搭乘晚上7:50分的渡輪從大阪出發，在船上住一晚，早上醒來就會到門司港了。 從大阪市區搭地鐵到渡船大樓(フェリーターミナル)站，走路5分鐘就會到大阪南港的乘船點。 船舶介紹 # 事先在網路上訂票，或是現場買票也可以，但是建議如果想要有個室的話，還是先預訂比較好，現場都只剩開放式的那種，只有簾子拉起來。 船上設施還蠻多的，除了淋浴間還有展望浴室，能邊欣賞海景邊泡澡。基本上就跟飯店差不多，只是廁所跟浴室都在外面而已。\n船內設施 # 登船 船內大廳 個室 預約的時候都只剩單人個室了，還蠻多家庭跟情侶來的，雙人房以上的房間數量並不多。 單人房大概長這樣，簡單的床、電視、書桌、洗手台。 電視能看的頻道不多，而且船如果離陸地太遠畫面訊號會不太好，然後有頻道能看船行進中所在位置。 娛樂間 販賣部、販賣機\n大廳櫃檯旁邊就是販賣部，避免拍到人就沒拍了，圖為官網照片。 基本上販賣部、販賣機賣的東西都比外面貴，可以先在外面買好再帶進來。 展望浴室、淋浴間 淋浴間與澡堂都在7樓。 外面會寫著目前入浴中的人數。 避免拍到人就沒拍了，圖為官網照片。 餐廳 船上有餐廳是要另外付費的，2000日圓我覺得有點貴，可以吃飽再來或自己外帶便當過來。 船外看台 # 有寫每個橋預計會通過的時段，時間差不多的時候可以出來看 明石海峽大橋 # 瀨戶大橋 # Day 2 # 前一天其實沒有睡得很好，畢竟在船上還是會晃，出來甲板看看早上的風景。\n門司港駅 # 到改港口後有免費的接駁車，可以做到門司港站。 藍翼橋 # 剛好遇到開橋時間。 門司港懷舊展望室 # 可以看到整個門司港的景色，還能看到關門橋。 這裡的建築都有很特別的風格。 香蕉人像 # 午餐 - 世界にひとつだけの焼きカレー プリンセスピピ門司港 # 人非常多開店前10分鐘到先登記候位，在寒風中等了快一小時才入場。 點了めんたい焼きカレー，額外加點了炸雞， 就是味道還行的焗烤咖喱飯，我覺得沒有值得等那麼久。 小倉祇園 八坂神社 # 往小倉城的路上，沿路會經過八坂神社。 小倉城 # 小倉城在全部天守閣中`高度排第6`，最高的是大阪城，長知識了。 上去可以看到小倉市區的風景。 北九州河畔步行街 # 到飯店Check In前還有時間，就到小倉城旁邊的步行街逛逛。 旁邊有蠻多百貨的，正好是接近聖誕節。 而這個時候正好是ちいかわ一番賞開抽的時候，沒想到這個地方還有！就抽了三抽！ 1B 2D還算不錯，D賞能自己選，還好烏薩奇跟吉伊還有。 晚餐 - 小倉鉄なべ 総本店 # 來這邊了就來吃看看有名的鐵鍋煎餃，煎到非常脆，味道還不錯， 但肉餡不多都在吃皮的感覺，2人份要1500日幣，份量也不多其實不便宜。\nDay 3 # 博多駅 # 早上飯店Check Out後，從小倉站出發搭乘JR前往福岡博多站。 博多マルイ # Pokémon Center FUKUOKA # 福岡的寶可夢中心就位在博多在旁邊的百貨內。 ラブライブ！サンシャイン! Aqours CLUB 出張所 # 剛好是Aqours 9周年來博多展出的時間，不過水團後來就沒什麼在追了，但聲優都認識當初剛出來台灣辦Live也有去看，進來逛一下回憶湧上心頭。 午餐 - 博多水たき 濱田屋 くうてん # 來福岡一定要吃的就是這裡的雞肉，午餐選了一間水坎雞肉鍋，點了博多水炊きコース。\n東西是一道一道上來，柚子醋配上雞肉還蠻搭的。 結束後會把蛋跟飯加進去變成雜炊。 櫛田神社 # 午餐結束後前往櫛田神社，只有地鐵一站的距離，就用走的當作飯後散步。 牛頭都被摸到發亮了。 抽了張中吉籤。 伊都きんぐ 天神店 # 前往警固神社的路上，經過一間甜點店，點了草莓香草奶油銅鑼燒，非常好吃，但一顆不便宜含稅要658日幣。 後來又經過買了一顆培茶口味的來吃也很讚。 警固神社 # 然後就一路走到了警固神社。 福岡タワー # 下午在飯店Check In完行李後，就搭公車接著前往福岡塔，沿路會經過福岡PayPay巨蛋。\n福岡タワー南口站下車後走一小段路就會抵達。 上去的電梯是透明的，塔的外面都是玻璃窗戶。\n有卡片每個幾度都能集章。 福岡塔在日本排第3高，又長知識了。\n晚餐 - 元祖博多めんたい重 # 晚餐回來天神這邊吃，有名的明太子飯。 這間的沾麵好像也很有名，加上很餓就點了套餐飯麺セット。 麵條很Q彈，明太子沾麵湯很濃厚，飯配湯也很讚， 我覺得麵比飯還好吃，飯只有明太子跟海苔在上面稍嫌不足，還好有點飯麵的套餐。 天神中央公園 # 飯後來到天神中央公園，感受聖誕節的氣氛。\n福岡PARCO # 接著又跑到福岡PARCO，逛アニメイト跟ちいかわ，看有沒有福岡限定的周邊，都在這棟的8F。 Day 4 # 太宰府 # 早上從天神站搭西鐵福岡-西鐵天神大牟田線，在西鐵二日市站轉西鐵福岡-太宰府線，大概半小時左右就會到。\n太宰府駅 # 太宰府前表参道 # 梅枝餅 かさの家 # 有名的梅枝餅其實就是紅豆麻糬，還不錯吃不會太甜，有內用區。 太宰府天滿宮 # 同樣被摸到發亮的牛頭。 星巴克 # 這裡的星巴克造型好特別。 一蘭 太宰府參道店 # 這裡的一蘭拉麵比較特別是六角形的碗，麵的長度是59公分(取自日文合格ゴウカク的諧音)，`象徵祈求合格。 柳川 # 從太宰府站過來搭西鐵福岡-太宰府線，同樣在西鐵二日市站轉西鐵福岡-西鐵天神大牟田線就會到西鐵柳川站。 柳川運河 # 三柱神社 # kuyurucoffee # 當天真的走蠻多路的，就找了間咖啡廳稍作休息。 晚餐 - 博多シーフードうお田 # 柳川行程結束後回到了博多，找了一間有名的明太子丼飯店。 點了招牌的明太いくら卵焼き丼，味道還不錯明太子、鮭魚卵蠻新鮮的，還有一張貼紙。 博多運河城 # 吃完就到走到隔壁的博多運河城，欣賞欣賞聖誕節水舞表演。\n宵夜 - かわ屋 警固店 # 逛完有點餓了，來吃福岡有名的烤雞皮，外脆內Ｑ會讓人一串接著一串。 要結帳的時候，老闆會給收尾的雞湯。 Day 5 # 午餐 - めんたい料理 博多 椒房庵 # 最後一天在飯店待到快11點才出來，就直接去吃午餐了，找了間博多車站有名的明太子鯛魚丼飯。 選了一半炙燒的吃法，炙燒過後的明太子非常香。 一樣有著三吃的吃法，原味、加入蛋黃醬、做成茶泡飯，都非常好吃。 天神地下街 # 吃飽吃後來逛天神地下街，一樣有著聖誕節氣氛。\n其實大部分都是餐廳跟服飾店，從天神南站開始走，走到底會到ミーナ天神購物中心， 在 Seria 入手睡衣版本的吉伊卡哇。\n在 Gigo 獲得戰利品太陽伊布、月亮伊布。 真言宗 東長寺 # もち吉　博多本店 # 參觀完來旁邊稍作休息，點了豆皮麻糬，稻荷壽司的外皮裡面包麻糬，意外還不錯吃。 晚餐 - 博多一幸舍 # 最後以福岡的一幸舍拉麵當作收尾，豚骨的豬骨味道偏重，味道還行。 福岡機場 # 晚上搭國內線飛機回大阪，隨身行李差點超重。 結束了北九州的美食之旅。\n","date":"2024年12月19日","externalUrl":null,"permalink":"/daily-notes/japan-travel/kitakyushu-trip/","section":"Daily-Notes","summary":"","title":"北九州｜福岡、小倉、門司港 五天四夜自由行","type":"daily-notes"},{"content":" 交通方式 # 這一趟預計把京都的楓葉全部看過一遍，但因為京都賞楓的人潮一直都很可怕， 所以起了個大早從人朝最多的清水寺開始看起， 大阪市區搭首班地鐵到清水寺最快也要1小時50分，抵達時已接近7點。 清水寺 # 清水寺6點就開門了，7點左右到人潮外面的沒有想像中這麼多。 一入場才發現我錯了，清水寺的對面的賞楓舞台早已擠滿人。 清水寺舞台 # 實際走過來才知道人會什麼都擠在這裡了，真的很美！\n三重塔 # 走下來到三重塔的拍照地點。 八重塔 # 從清水坂一路走下來接到三年坂 沿路會看到八重塔，這裡是拍八重塔的好地點！ 早上這一路上都沒有什麼人，走起來很舒服。 八坂神社 # 一路走到八坂神社已經快8點，早已有來參拜的人。\n永觀堂 # 本來想進永觀堂看的，但是9點才開放，離入場還有一個小時，在外面拍拍照就走了。 真如堂 # 然後就沿路慢慢走到了真如堂，其實一路上都有楓葉，進來也接近9點開園的時間，不過已經提早開放給大家入場了。 這裡的楓葉都紅的差不多了！ 銀閣寺 # 早上最後的時間來銀閣寺這裡走走，楓葉雖然不多，但也蠻漂亮的。 午餐 - 麵屋優光 河原町 # 中午坐巴士回到了京都河原町附近，找了一間拉麵店當作午餐，有點餓點了スペシャルらーめん，肉多到滿出來，湯頭是貝類醬油湯底。 ちいかわもぐもぐ本舗 伏見店 # 下午預計去伏見稻荷走走，都來了一樣要去在旁邊的 ちいかわ 伏見店 這裡有伏見稻荷限定的商品！\n伏見稻荷大社 # 買完就沿著商店街走到了伏見稻荷大社。 抽了張吉籤。 拿出剛買的稻荷烏薩奇出來拍照🤣 下午茶 - THE Lower East Nine cafe -LE9- # 今天走一早就都在走路，下午決定來點輕鬆的行程，找個咖啡廳休息。 最後在太陽下山前就離開京都了。 ","date":"2024年12月9日","externalUrl":null,"permalink":"/daily-notes/japan-travel/kyoto-autumn-leaves/","section":"Daily-Notes","summary":"","title":"京都｜賞楓行","type":"daily-notes"},{"content":"","date":"2024年12月9日","externalUrl":null,"permalink":"/tags/%E4%BA%AC%E9%83%BD%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"京都旅遊","type":"tags"},{"content":" Day1 # 難波租車 # 一早跟大家約好在難波的日産レンタカー租車公司集合。 取我們未來二天要開的車。 第一次開在日本的高速公路上!\n天橋立 # 直接開了2個小時的車抵達天橋立。\n天橋立纜車 # 接著到了天橋立ビューランド リフト・モノレール山麓駅 搭纜車上去展望台，買了來回票。 不敢坐リフト的人，可以選坐モノレール 不過是來回的車廂，等待時間就比較久，我們同行的友人就不坐，敢坐的人就線上去展望台等了。 リフト 速度並不快，可以欣賞上山的風景。\n下山的時候風景比較美，可以看到剛剛我們剛剛逛的天橋立。\n天橋立展望台 # 抵達展望台後，可以看到整個天橋立的風景。\n午餐 - 龍宮そば # 午餐就找了天橋立附近的蕎麥麵，味道普通，隨便找的就沒有抱太大得期待。 伊根舟屋 # 吃完午餐便繼續開車前往伊根舟屋，附近停好車後直接下來逛。 有點難想像這裡還是京都🤣\n晚餐 - 焼鳥とジンギスカン 北の大地 # 接著我們就一路開到鳥取的飯店，抵達時已經是晚上7點， 各自先回飯店放行李後再出來吃飯，找了一間居酒屋餐廳。 其實我們沒有點很多，回程的路上就在超商買了一些東西回飯店吃， 看到ちいかわ出新的和菓子就買來吃了🤣 Day2 # 青山剛昌ふるさと館 # 都來鳥取了當然要去柯南作者的故鄉博物館！ 裡面非常多東西，非常值得一來！而且附近很好停車。\n館外拍照景點 # 館內設施 # 入場有送聖誕節的特典，拿到和葉跟平次。 今天我代班啦！ 柯南的滑板遊戲體驗。 每一年的劇場版海報。 小劇場動畫，不能錄影就只拍照了。 把門票放上去會有立體投影！ 還有解謎遊戲，回答完可以拿到一張認定証。\n走之前打了一顆紀念幣。 コナンの家 米花商店街 # 第二天時間有限，這裡拍拍照逛一下，就前往下一個景點了。\n鳥取砂丘 # 接著開車前往鳥取沙丘。\n這裡真得超遼闊，然後風超大超冷！ 上來之後會看到日本海。\n午餐 - 天下一品 # 附近沒有什麼吃的就選了間連鎖拉麵，豚骨拉麵加點了一塊雞皮，味道還不錯，中上水準的好吃。 神戸市 - 摩耶山 展望デッキ # 下午都在開車，因為要趕在租車公司關門前回到大阪， 結果到神戶的時候比預期的時間還早，臨時起意去看神戶的百萬夜景 - 摩耶山掬星台夜景。 在停車場停好車後，再走一小段山路後，抵達展望台。 最後回到大阪還完車後，就就地解散了，結束這二天一夜的行程。\n","date":"2024年12月4日","externalUrl":null,"permalink":"/daily-notes/japan-travel/tottori-kyoto-road-trip/","section":"Daily-Notes","summary":"","title":"鳥取、水之京都｜二天一夜自駕旅行","type":"daily-notes"},{"content":"","date":"2024年12月4日","externalUrl":null,"permalink":"/tags/%E9%B3%A5%E5%8F%96%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"鳥取旅遊","type":"tags"},{"content":" 交通方式 # 中午跟朋友約在京都車站碰面，從京都搭 JR 過去大概50分鐘。 午餐 - 京都車站 # 午餐在京都車站的美食街解決，找了一間叫 京だし茶漬け専門店 京都おぶや，點了招牌海鮮茶泡飯。 彥根城 # 彥根車站下車後，發現過去彥根城的巴士班次不多，索性用走的站前直直走1.5公里就會到。 附近的楓葉還沒完全紅透。 天守閣上的景色。 玄宮園 # 就位在彥根城的隔壁，雖然楓葉都還沒完全紅透，但是已經夠漂亮了。 ","date":"2024年12月2日","externalUrl":null,"permalink":"/daily-notes/japan-travel/shiga-hikone-castle/","section":"Daily-Notes","summary":"","title":"滋賀｜彥根城、玄宮園","type":"daily-notes"},{"content":"","date":"2024年12月2日","externalUrl":null,"permalink":"/tags/%E6%BB%8B%E8%B3%80%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"滋賀旅遊","type":"tags"},{"content":"沒錯今天是吉伊卡哇一番賞開抽的日子。 先說結果總計29抽有3個A賞算是蠻歐的，還好不用這張圖支援了🤣 10連抽的特典送的都是同一張桌布，所以抽過10連之後，其實單抽或是10連抽都可以。 一番賞結果 # 這邊是自己抽加上，幫朋友代抽，總計29抽，幫自己抽的是有拿到1A算還行。\n獎品配送 # 預計2025年2月下旬會開始寄送，要開始煩惱要怎麼把A賞寄回去台灣了😂\n","date":"2024年10月15日","externalUrl":null,"permalink":"/daily-notes/japan-life/usagi-ichiban-kuji/","section":"Daily-Notes","summary":"","title":"烏薩奇一番賞 開抽","type":"daily-notes"},{"content":"","date":"2024年9月30日","externalUrl":null,"permalink":"/tags/%E7%92%B0%E7%90%83%E6%94%BB%E7%95%A5/","section":"Tags","summary":"","title":"環球攻略","type":"tags"},{"content":" 交通方式 # 從大阪市區搭車的話，推薦從搭JR環狀線過去，從新今宮搭到西九条站轉JR櫻島線，到環球城站大概20分鐘就到了。 環球站一出來就是周圍的商店街、美食街，跟著人潮走就會走到大門口了。 門票資訊 # 一般購票 # 可以透過台灣購票網站(Klook、KKday)、或是環球官網購買，每天的票價與開園時間都不固定，建議先在官網查看。\n年票制度 # 販售的年票有二種，分別是グランロイヤル(Grand Royal)與スタンダード(Standard)，差別是在特定日期的除外日(約90天)是否能入場，價格也差了一倍多。 購買 Grand Royal 的年票主要享有的福利： 一年內不限時間次數入園 獲得該年グランロイヤル會員胸針 隔年續約年票享有折扣 能搶先購買特殊活動、期間限定票卷 園區內餐廳打9折 同行者打95折 (需在官網提前購票，最多五名) 生日月同行者打85折 (需在官網提前購票，最多五名) 官方停車場折扣 1000 日圓 購買/換票流程： 加入環球會員 選擇要購買得年票種類グランロイヤル(Grand Royal)或是スタンダード(Standard) 進入付款流程：線上刷卡/超商付款 領取方式：現場領取/宅配 這裡我選現場領取，會有一個領取的 QR Code，到現場給售票口的工作人員掃就能領到年票了。 快速通關券 # 如果只規劃一天，想要有一定要玩到的設施的話，這個部分建議在事先買好，因為當天9點入園的時候，現場販售的快速通關幾乎的沒了。 環球App # 這個 App 可以說是必載，很多功能都在裡面，主要就是拿來：\n查看地圖：園區真的很大，有即時定位功能用來找設施真的很方便，還能看每個設施的等待時間。 看活動表演時間 : 上面會寫當天活動表演的時間與地點。 抽特別區域(如瑪利歐園區)的入場卷: 要先登錄已購買的門票(上面的QR Code)，綁定後才能抽選 當天遊玩的設施 # 我們其實沒有玩太多設施，主要是看表演跟拍照而已，畢竟有買年票，一些固定的設施之後都可以再來玩。\n鬼滅の刃 XRライド ～刀鍛冶の里を疾走せよ～ # 一入園就搶先衝去這個設施，人還是很多，大概排1個半小時才排到。 遊玩體驗算還行吧，就是帶著VR頭盔，坐不會很刺激的雲霄飛車(只有左右晃的程度)，整個過程大概5分鐘而已。 進去前有個拍照的區域，結束出來的時候，有販賣部可以看拍出來的照片決定要不要另外買。 スーパーマリオ・ランド～ # 有手環的話可以玩裡面的金幣小遊戲。 - マリオカート ～クッパの挑戦状～ 這裡有個小插曲，就是女友玩的時候VR頭盔是沒有畫面的，事後跟工作人員反應，就讓我們二個不用排隊重新搭一次，我自己就跟著女友又多玩到一場。 表演節目 # 寶可夢遊行 # 剛好是萬聖節遊行的活動，蠻可愛蠻Ｑ的，穿那麼大件的布偶衣還這麼靈活，真的很強🤣\n小小兵遊行 # 剛入園就遇到小小兵在遊行，還能上去拍照。\n侏羅紀恐龍秀 # 經過的時候剛好看到，還蠻逼真的。\n萬聖節遊行 # 我們出來的時候剛好是萬聖節遊行接近尾聲，蠻歡樂的沒有嚇人的環節，大家都在跳舞🤣\n美食餐廳 # 我們真的在環球吃了不少東西，園區內餐廳年票還有打折，基本上餐點除了好拍照，味道也都還行，但就是貴了點🤣\n寶可夢萬聖節餐點 # 還蠻漂亮的很好拍照，不過味道就有點普通。 海賊王餐點 # 航海王的餐點意外蠻好吃的🤣 Shake Shack 環球影城店 # 這間在園區外就沒有9折了，我們玩到快關園才出來，基本上吃的都關了，看到 Shake Shack 還有開就決定來補充一下能量。 ","date":"2024年9月30日","externalUrl":null,"permalink":"/daily-notes/japan-travel/osaka-universal-studios/","section":"Daily-Notes","summary":"","title":"大阪｜環球影城","type":"daily-notes"},{"content":" 交通方式 # 從大阪市區搭車的話，可以搭乘大阪地鐵坂筋線，到山田站轉單軌列車到萬博紀念公園站，大概抓1小時左右的時間。 單軌列車 万博記念公園 # 一下來就會看到知名地標太陽の塔，真的沒有很好看，加上陰陰的天氣感覺怪陰森的😂 LaLaport EXPOCITY # 隔壁就是 LaLaport EXPOCITY 我們決定先去逛。 路上看到Dippin' Dots 冰淇淋 覺得很新奇就買來吃了，還蠻好吃的口感很特別。 接著就直衝柯南的快閃店　名探偵コナンラン，我們來的時候剛好是最後一天 9/29。 然後還剛好看到咒術迴戰的快閃店。\n接著下午快4點到美食街吃午晚餐，今天的作息很不正常🤣 OSAKA WHEEL オオサカホイール # LaLaport EXPOCITY 旁邊就是日本最高的摩天輪，想說都來了就上去坐看看。 轉一圈的時間是18分鐘，票價一人1000日幣，車廂是透明的，為了看夜景等到晚上才來坐。\n從上面可以看到整個萬博紀念公園，晚上會開燈。 摩天輪去跟回來的路上裝飾得蠻漂亮的很好拍照。 ","date":"2024年9月29日","externalUrl":null,"permalink":"/daily-notes/japan-travel/osaka-expo-commemorative-park/","section":"Daily-Notes","summary":"","title":"大阪｜萬博紀念公園 ＆ LaLaport EXPOCITY ","type":"daily-notes"},{"content":"在梅田ロフト4樓 期間限定展出，難得是自己跟女友以前都有看過的戀愛動畫，15周年記念特展就想說來參觀看看。\n門口展示 # 漫畫 # 畫展 # 渡狸、反ノ塚雕像 # 周邊紀念品區 # 展逛完最後面有個周邊紀念品區，女友忍不住買了一些東西🤣 ","date":"2024年9月28日","externalUrl":null,"permalink":"/daily-notes/japan-life/inu-x-boku-ss-exhibition/","section":"Daily-Notes","summary":"","title":"大阪 | 梅田ロフト 妖狐×僕SS・藤原ここあ 15周年記念展 ","type":"daily-notes"},{"content":" 預約餐廳 # 要去寶可夢咖啡廳建議一個月前就要預約了，而且幾乎都是開放的一個月前的秒滿。 平日的話可以賭看看現場入場。 寶可夢咖啡廳 # 等待的時間先在門口拍這二隻皮卡丘。 點了一份主餐、甜點、二杯飲料。\n表演活動 # 用餐到一半，皮卡丘會出來打招呼。\n離開前跟旁邊得客人打招呼打招呼🤣 ","date":"2024年9月27日","externalUrl":null,"permalink":"/daily-notes/japan-life/osaka-pokemon-cafe/","section":"Daily-Notes","summary":"","title":"大阪 | 心齋橋 PARCO 寶可夢咖啡廳 開箱","type":"daily-notes"},{"content":" 交通方式 # 從新今宮附近前往，需要轉三次車才會到。 渡月橋 # 從渡月橋一路往嵐山商店街的方向走\n午餐 - 嵐山よしむら 蕎麥麵 # 嵐山這裡的蕎麥麵名店，候位1小時才吃到，候位的時間可以去旁邊的嵐山商店街逛， 很多人都為了二樓的透明玻璃窗戶邊吃邊看外面風景，但運氣不好坐到沒靠窗的座位 吃的方面點了天ざる膳 2480日幣 蠻貴的，完全不值得，蕎麥麵也不好吃。\n嵐山商店街 # 這裡賣蠻多京都的伴手禮跟周邊，不過沒買什麼，只有因為天氣熱買了冰淇淋來吃。 竹林小徑 # 嵐山商店街一直往下走就會到竹林小徑，夏天過來人沒有到很多。 晚餐 - 京の焼肉処 弘 京都駅前店 # 晚餐回到京都，選了一間燒肉店，肉的品質還不錯。 京都塔 # 吃完晚餐就在京都車站附近逛，準備回大阪。 ","date":"2024年9月16日","externalUrl":null,"permalink":"/daily-notes/japan-travel/kyoto-arashiyama-day-trip/","section":"Daily-Notes","summary":"","title":"京都 | 嵐山一日遊","type":"daily-notes"},{"content":" 交通方式 # 去程直接搭JR從大阪梅田站到姬路站，差不多一小時就會到，回程同樣搭JR停靠神戶站下車，最後再回大阪。 姫路駅 # 到姬路站後出來旁邊就有公車站，大概搭10分鐘左右就會到姬路城 姫路城 # 公車到姬路城大手門前下車，然後就一路走到姫路城內。\n天守閣上的風景還蠻不錯的，只可惜天氣沒有到太好。 午餐 ーメン・ギョーザ 新生軒 # 從姫路城沿路慢慢走回車站，路上挑了一間拉麵店來吃。 算是清爽系的鹽味拉麵，味道還不錯。 神戸ハーバーランドumie # JR 神戶站下來旁邊就是，非常大的一間購物中心， 購入了 ちいかわ 姫路、神戶限定的鑰匙圈。 神戸ポートタワー # 一路逛下去就會走到神戶塔，再過去就是神戶港。 元町、南京町商店街 # 8月底的天氣還是太熱，下午就前往元町、南京町商店街隨處走走。 三宮神社 # 晚餐 - 神戸牛 炭火焼肉 石田屋 # 晚餐選了這裡神戸牛有名石田屋，選了 特上石田屋コース 7000日圓的套餐。 肉的品質不錯，不過還是吃不慣冷盤的生牛肉，量不多CP值不高嚐鮮即可。\n前菜 主餐 甜點 ","date":"2024年8月24日","externalUrl":null,"permalink":"/daily-notes/japan-travel/himeji-kobe-day-trip/","section":"Daily-Notes","summary":"","title":"姬路、神戶 | 一日遊","type":"daily-notes"},{"content":"","date":"2024年8月24日","externalUrl":null,"permalink":"/tags/%E5%A7%AC%E8%B7%AF%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"姬路旅遊","type":"tags"},{"content":"","date":"2024年8月24日","externalUrl":null,"permalink":"/tags/%E7%A5%9E%E6%88%B6%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"神戶旅遊","type":"tags"},{"content":"","date":"2024年8月20日","externalUrl":null,"permalink":"/tags/%E6%97%A5%E6%9C%AC%E8%87%AA%E7%94%B1%E8%A1%8C/","section":"Tags","summary":"","title":"日本自由行","type":"tags"},{"content":" Day 1 # 名古屋車站 # 早上8點從大阪搭乘 近鐵Hinotori 出發去名古屋，2個小時就到了 ，不過加特急卷要快5000日幣，有時間的搭高速巴士會比較便宜一些。 一到車站先去遊客中心購買犬山城的來回套票(1680日幣)，套票內容包含:\n犬山城門票 名鉄名古屋\u0026lt;-\u0026gt;犬山站/犬山遊園站來回車票各一張 有楽苑門票折扣卷 犬山城下町商店的折價卷 套票非常划算，光是來回車票+門票就超過套票的價格了。 午餐 - 飛騨牛一頭家 馬喰一代 # 午餐吃車站附近的飛騨牛一頭家 馬喰一代 名古屋WEST 套餐12000日幣，真的蠻貴的，不過想說來都來了就給他點下去。不過吃完的感想是嚐鮮一次就好，CP值不高。 前菜是飛騨牛的生肉盤口感蠻像在吃鮪魚的，最好吃的是壽司。 主餐是飛騨牛涮涮鍋跟牛舌肉盤。 肉片涮個8-10秒就起鍋了不想浪費這麼好的肉，真的是入口即化。\n甜點是咖啡香草冰淇淋。 犬山城下町 # 接著就搭 名古屋鉄道 從名古屋站出發去犬山城 在犬山站下車，走一小段路會到犬山城下町，計劃是一路逛上去到犬山城， 然後再從犬山遊園站搭回去名古屋站，這樣就不用走重複的路線。 針綱神社、三光稻荷神社 # 沿路會經過 針綱神社 與 三光稻荷神社 犬山城 # 然後就到了犬山城，要脫鞋入場，因為國寶城裡面都是木造的。 從最高樓看下去的景色非常遼闊。\n名古屋PARCO # 結束犬山城的行程就先去飯店check in，然後出來逛附近的 PARCO。 剛好是ちいかわラーメン豚期間販售的時間，但是沒事先做功課抽整理卷沒辦法入場QQ 不過可以逛 B1 ちいかわらんど，買名古屋限定的商品! 晚餐 - 矢場丼 矢場町本店 # 來名古屋一定要來吃矢場丼的創始店，在日本其他地方都會看到的味增豬排連鎖店，都來住附近了一定要來光顧一下， 算是蠻早就來吃的，沒有排什麼隊就吃到了，口味是偏鹹的豬排，整理來說算不錯！ 吃飽又去附近的Jump Shop 逛了一下🤣 雖然沒買什麼東西就是了。 綠洲21、中部電力 Mirai Tower # 吃飽當作散步就去逛逛綠洲21、中部電力 Mirai Tower都在附近，晚上開燈拍起來非常漂亮。 白天跟晚上的中部電力塔是完全不同的感覺！\nDay 2 # 早餐 - コメダ珈琲店 錦伊勢町通店 # 隔天一早，要來驗證名古屋這裡的是不是點飲料送早餐，找了一間連鎖咖啡店來測試，結果是真的🤣 名古屋城 # 名古屋城因為天守閣目前還在整修，沒辦法走上去看。 三輪神社、大須観音 # 接著就前往位在大須商店街旁邊的三輪神社、大須観音，因為還沒到午餐時間就來參拜一下。 午餐 - 大須商店街 # 午餐走商店街小吃路線，在事先做功課的時候發現這裡很多吃的！還剛好跟 BanG Dream 聯名辦活動。 コンパル 大須本店 : 炸蝦三明治 手羽先むすめ 大須店 : 炸雞翅 御手洗糰子 新雀本店 : 烤糰子 覚王山フルーツ大福弁才天 大須店 : 草莓、水蜜桃大福 最後太熱決定先回飯店避暑，一開電視才知道當天最高溫竟然有到38度，真的像烤箱。 晚餐 - あつた蓬莱軒 松坂屋店 # 點了鰻魚飯套餐，果然名不虛傳，真的蠻好吃的。 旁邊寫著鰻魚三吃的吃法，不過我覺得第二吃(加上芥末、蔥花、海苔)、第三吃，只差在有沒有把茶泡飯的湯淋上去而已。 Day 3 # 早餐 - ブルーボトルコーヒー 名古屋栄カフェ # 去了名古屋的藍瓶咖啡，不過這間就沒有點飲料送早餐了，還另外點了水果布丁。 名古屋港水族館 # 接著前往名古屋港水族館，觀看這裡有名的海豚表演。 午餐 - 名古屋辛麵 鯱輪 # 這間算是剛好路過看到有人在排隊久想說吃看看，味道是不錯沒有視覺上的那麼辣，但還是吃到滿身汗。 下午茶 - HARBS 榮本店 # 都來名古屋了一定要朝聖一下 HARBS 的創始店，不過現場人帶多就外帶回飯店吃了。 熱田神宮 # 接著就去了熱田神宮參拜，抽了張半吉籤。\n晚餐 - 世界の山ちゃん 錦三大津店 # 可能是有吃下午茶的關係，不怎麼餓，就外帶這間有名的雞翅與雞皮回飯店吃，味道非常重適合下酒，但我只有買茶來配🤣 Day 4 # 中部電力 Mirai Tower - 眺望塔 # 蠻晚才從飯店 Check Out ，就略過早餐，直接去逛名古屋電力塔了，前幾天都只有遠拍沒有上去。 還剛好遇到哥吉拉70週年的活動，留一顆頭在塔下🤣 付了門票上去，票價算蠻貴的。 午餐 - もうもう亭 広小路店 # 點了 もうもう牛まぶし 的燒肉套餐，還有茶泡飯的吃法，非常好吃😋 名古屋市科學館 # 下午茶 - 和栗モンブラン専門店 栗りん # 天氣實在熱到受不了，大須商店街逛到一半跑進來避暑，看到刨冰蒙布朗覺得很新奇，就跑進來吃了。 還會在你面前做，錄下了整個製作過程。\n晚餐 - カツレツMATUMURA 豬排 # 晚餐就在名古屋車站附近吃了，晚上要回大阪就在附近逛，然後順便等車。 豬排非常軟嫩好吃，大概7、8分熟，還單點了炸雞柳也很好吃。 名古屋車站 # 最後在車站的紀念品店，挑了一盒餅該當作給同學們的伴手禮，就搭車回大阪了。 ","date":"2024年8月20日","externalUrl":null,"permalink":"/daily-notes/japan-travel/nagoya-trip/","section":"Daily-Notes","summary":"","title":"名古屋 | 四天三夜自由行","type":"daily-notes"},{"content":"","date":"2024年8月20日","externalUrl":null,"permalink":"/tags/%E5%90%8D%E5%8F%A4%E5%B1%8B%E6%97%85%E9%81%8A/","section":"Tags","summary":"","title":"名古屋旅遊","type":"tags"},{"content":"這個星期六和語言學校同學約好在パームガーデン舞洲烤肉與看煙火，這應該是這個夏天最後參加的煙火活動了吧。 下午約在西九條站集合，採買食材後，再搭公車過去烤肉的地點，大概30分鐘。 訂位/收費方式 # 採線上預約制，然後這裡的可以選擇自己帶食材過來考的方案， 一個人頭收1300円的場地費，然後加上座位費(一般桌椅300円/沙發椅600円)， 烤肉器具等等都會幫你準備，只要帶食材過來就好。\n食材採買 # 日本的超市自己買肉來烤真的都蠻便宜的，一大盒才1000日元。 パームガーデン舞洲 # 我們蠻早就到烤肉的地點了，加上天氣很熱現在附近的吊床區坐一下，然後買飲料來喝。 台灣同學又拿出了義美小泡芙來做台灣外交🤣\n烤肉活動 # 時間接近傍晚，我們也開始備料跟生火，準備烤肉了。 煙火表演 # 晚上的7:45分開始煙火表演\n心得 # 這是第一次在日本戶外自己烤肉，算是很不錯的體驗，而且只要帶食材就好蠻輕鬆的，烤肉器具、生火材料都是店家會幫忙準備好，結束時把桌面整理乾淨就好。 煙火雖然沒有大阪淀川煙火來的漂亮，但現場只放給幾組烤肉的人在看也別有一番風味。\n","date":"2024年8月10日","externalUrl":null,"permalink":"/daily-notes/japan-life/osaka-maishima/","section":"Daily-Notes","summary":"","title":"大阪 | 舞洲ロングラン花火 \u0026 烤肉活動","type":"daily-notes"},{"content":"這次的柯南30週年展在大阪大丸梅田店15樓舉辦，需事前購入電子票， 購買後期限之內選一天憑電子票卷入場。 到現場後會依照當天的人數發放入場整理卷，當天人不是非常多，拿到約20分鐘後的入場卷。 購買的票卷有包含特典。 進來首先看到的是這30年內出版的漫畫，全部展示出來。\n然後是柯南雕像與畫作的展示。 還有清水寺為背景的場景。 犯人大集合。 博士的發明跟犯案工具。 基德雕像與畫作展示 漫畫家簽名專區 30週年等身大立牌。\n結束後會拿到物販的入場卷，可以到樓下13樓去購買相關物販。 ","date":"2024年8月6日","externalUrl":null,"permalink":"/daily-notes/japan-life/conan-30th-exhibition/","section":"Daily-Notes","summary":"","title":"大阪 ｜ 大丸梅田店 柯南30週年展","type":"daily-notes"},{"content":"","date":"2024年8月3日","externalUrl":null,"permalink":"/tags/%E8%8A%B1%E7%81%AB%E5%A4%A7%E6%9C%83/","section":"Tags","summary":"","title":"花火大會","type":"tags"},{"content":" 大阪淀川煙火 # 大阪淀川煙火大會（なにわ淀川花火大会）是大阪夏天最大的煙火之一，每年8月初在淀川河畔舉辦。這場煙火大會自1989年開始舉辦，至今已經成為大阪代表性的夏日活動，每年都吸引超過數十萬人前來觀賞。\n有了上一次參加大阪天神祭的經驗，加上這次有日本老師的私藏景點推薦，這次的煙毀大會也特地提前和同學約好一起提早去卡位！ 交通方式 # 從大阪梅田站搭阪神本線到姬島站下車，走10分鐘左右就會到岸邊。 梅田午餐 - 炸牛排 # 午餐跟同學約在梅田，吃這間 牛かつもと村，肉的品質很好一咬就化開，是我吃過連鎖炸牛排店中最好吃的一間，韓國同學真的蠻會推薦吃的🤣 花火大會 # 然後就是提早去搶位子啦，不過真的不愧是日本老師推薦的景點，完全看到觀光客，都是日本人。\n隨著天色逐漸暗下來，煙火也開始施放，真的非常漂亮煙火的種類很多，從岸邊看沒有遮蔽物真的非常壯觀！\n心得 # 這次的煙火大會真的非常慶幸有來！現場真的非常震撼，這次去的觀賞地點也沒有上次天神祭那樣擠滿人， 下次有機會想在梅田展望台上看，聽說從上面角度看的景色更厲害！\n","date":"2024年8月3日","externalUrl":null,"permalink":"/daily-notes/japan-travel/osaka-yodogawa-fireworks/","section":"Daily-Notes","summary":"","title":"大阪 | 淀川煙火","type":"daily-notes"},{"content":"","date":"2024/7/30","externalUrl":null,"permalink":"/en/posts/about/","section":"Posts","summary":"","title":"About me","type":"posts"},{"content":"","date":"2024年7月30日","externalUrl":null,"permalink":"/ja/","section":"Easonのブログ","summary":"","title":"Easonのブログ","type":"page"},{"content":"","date":"2024/7/30","externalUrl":null,"permalink":"/en/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"メモを取らないとすぐに忘れてしまうエンジニアです。ここでは、自分の学習メモや日常の出来事を記録しています。\n","date":"2024年7月30日","externalUrl":null,"permalink":"/ja/about/","section":"Easonのブログ","summary":"","title":"私について","type":"page"},{"content":" 前言 # 封面照片是入境當晚拍的通天閣照片，塔上寫著「社会に貢献する」，而我也即將在這裡貢獻我一年的時間了🤣\n抵達日本入境後，有一些手續要處理，這篇文章做個紀錄。\n日本住處 # 因為是自己租房，入境時當然要先打理好未來一年的落腳處。 入境後的隔天一早，就去就找之前在台灣已經線上找好的房仲，簽訂房子的入住契約。\n因為事先已線上對過了就大致再核對一下就快速簽約完成了。 房仲還事先幫我處理好水電的開通，省去很多麻煩，拿到鑰匙後就前往租屋處啦！\n房間的格局是1K，但實際上比想像中還要大！ 瓦斯必須要本人在場才能開通，房仲也幫我預約了當天進行開通。 區役所辦理手續 # 確認日本的地址後，必須在14天內到區役所進行登錄， 而我已經事先找好住宿，確認好房屋狀況後，房仲的人非常好說可以帶我跑一遍流程， 當天下午跟房仲約在附近的浪速區區役所，有人帶著真的順利很多！ 住址登錄+住民票 # 領取號碼牌，並填寫住民異動屇申請表，櫃檯人員會跟你收取填寫好的住民異動屇與在留卡，等待一段時間後，就會拿到背面印有你新住址的在留卡，以及住民票。\n國民健康保險 # 拿到有住址在留卡後，櫃檯人員會給你國民健康保險窗口的號碼牌，叫你到那邊去等叫號，叫號後會在窗口跟你說明健康保險流程，以及是每個人都必須都要加入的，然後會寄一整年份的繳費單到你的住址，每個月就拿該月的繳費單到超商或指定機構繳納。完成手續後就拿到了健康保險證。\n國民年金免除 # 接著是國民年金的部分，窗口人員是說必須要先加入再進行免除的申請，而這裡的窗口能夠當天同時進行申請(有人分享是要後續再跑一趟免除，還是要依照該區的實際流程為主)，然後之後免除結果後續會再寄通知到住址，一樣會寄一整年份的繳費單到你的住址，在免除結果通知下來前都先不要去繳納。\nMy Number Card # 最後是 My Number Card 的部分，同個窗口的人員有問到，就一起辦理了，需繳交1000日圓的費用，等待一段時間就能拿到印有自己照片的 My Number Card 卡了！這張卡就相當於你的身份數位證明，後續不管是要看醫生或是查詢保險繳費紀錄等等的行政程序，都可以透過這張卡進行。\n租屋處的整理 # 之前提到日本租屋大部分是不帶傢俱的，所以都得自己想辦法生出來，房仲之前有推薦給我一個台灣人在大阪開的二手傢俱商，我在台灣就先跟他訂了一些二手傢俱，約好入住當天下午搬進來，省去不少麻煩。\n我只買了床、冰箱、洗衣機、客廳大燈等大型必要傢俱，確保當天能順利住下來，傢俱商也有提供幫忙搬運與安裝的服務，蠻讚的。 之後幾天又陸續在Amazon上訂購桌椅來自己組裝，還有到附近的宜得利與超市採買生活用品。 最終房間終於變成理想的模樣！ 申辦日本門號 # 本來房仲要跟著我去辦電話的，但因為當天下午有搬傢俱的行程，就在區役所跟房仲就地解散了。\n隔天就自己去辦了樂天的門號，還好承辦人員很親切，也沒有用到太困難的日文，都還算是聽得懂，之前有做過功課，方案的部分都已經有事先了解。\n選擇樂天的原因： 第一個是能刷卡繳費，然後都是電子帳單，對我來說非常方便。 第二就是依照你的用量收費，3G、20G 分段收費，超過20G後都是收一樣的價格，因為房間就有Wi-Fi了，這點對我來說非常彈性。 不過缺點就是有些地方的收訊真的蠻差的。 日本郵局開戶 # 到 App Store 下載 ゆうちょ手続き 的 App，線上進行開戶填寫資料，日後郵局會把銀行卡以簽收的方式直接寄到你的住址，不需要親自跑一趟。\n收到銀行卡後，後續為了房租能透過郵局自動扣款，必續親自帶著印章親自跑一趟郵局進行印鑑登錄，然後順便確認其他相關手續是否已經完成。\n結語 # 以上就是入境之後要做的事情啦，區役所的部分還好有房中帶著我，雖然已經有一點日文基礎，但是實際上日本人講話的語速非常的快！有些地方真的會聽不太懂，還好有房仲的輔助講解，才讓我的流程跑得很順利！\n","date":"2024年7月30日","externalUrl":null,"permalink":"/daily-notes/japan-life/working-holiday-arrival/","section":"Daily-Notes","summary":"","title":"日本打工度假｜入境後要做的事情","type":"daily-notes"},{"content":" 大阪天神祭 # 大阪天神祭（天神祭り）是日本三大祭典之一，每年7月24日、25日在大阪天滿宮及其周邊舉辦。祭典已有超過千年歷史，最有名的就是船渡御和奉納花火，每年都吸引超過百萬人潮參加。 難得這個時候在大阪，就跟語言學校的同學相約參加7月25日的本宮祭，感受一下日本祭典的氣氛！ 交通方式 # 有事先聽說過當天會非常多人，所以下午就約好在大阪天滿站集合，再走路過去天神祭的地點。 一出車站就看到天神祭的工作人員在發扇子與交通管制，不愧是25日的本宮祭，有種全大阪人當天都擠在這裡的感覺，人潮非常多！ 我們就一路跟著人潮，走到晚上看煙火的地方。 天滿橋大川沿岸 # 當了現場人潮真的非常多，真的非常建議早點到現場卡位，我們到的時候河邊的位子已經所剩不多了。 好險我們還是有看到零星的位子，就先放了野餐墊佔好位子。 沿路旁邊都是攤販，從下午就開始營業了。 天氣實在太熱，附近 Lowson 買冰、飲料結帳的人潮，從店內一路排到外面。 我們也買了些攤販的小吃當作晚餐，還有台灣同學帶了義美小泡芙，要跟外國同學做文化交流🤣 船渡御 # 接近傍晚時分，花船陸續出發，河岸兩邊擠滿了人。每艘船上都有表演和音樂，現場氣氛很歡樂。\n花火大會 # 晚上7點半左右開始放煙火，不過太晚佔位子，加上沒有事先研究觀賞煙火的地點，煙火有點被樹擋到😅\n心得 # 第一次參加天神祭，人真的非常多，現場氣氛真的很震撼！不管是花船還是煙火都很有日本夏日祭典的感覺，非常多人穿著浴衣前來，不過人真的很多加上天氣非常熱，真的很佩服他們🤣 推薦有機會的話一定要來體驗一次！真的要事先研究好觀賞煙火的位置，還有可能一早就要來搶位子😂\n","date":"2024年7月25日","externalUrl":null,"permalink":"/daily-notes/japan-travel/osaka-tenjin-matsuri/","section":"Daily-Notes","summary":"","title":"大阪 | 天神祭","type":"daily-notes"},{"content":" 交通方式 # 地鐵坐到大阪港，再走10分鐘就會到 週六早上10點，和語言學校同學們約在大阪海遊館門口集合買票入場。 人潮算普通，大概排20分鐘左右就能買到票。 開館時間與票價是浮動的，可以事先在官網上查看。 海遊館周圍還有其他設施像是觀光船、樂高樂園，有計劃一起前往的話，買套票的話應該會比較划算。 館內參觀動線 # 參觀路線就如官網上所介紹的環太平洋的動線，中間圍繞著有鯨鯊的太平洋水族區。 館內設計是繞著主水槽一圈一圈往下走，每一層都能從不同角度欣賞到。 餵食結束就滾回去的海豹🤣\n蒙特瑞灣的海獅，引導一下就會跟你轉圈圈🤣\n南極大陸館的企鵝。\n太平洋館的水槽真的非常大，裡面有二隻鯨鯊在遊，可以從每層樓的不同角度觀賞。\n智利海岸的日本沙丁魚，一直圍繞的石頭轉。\n海月銀河館水母，看著蠻療癒的🤣\n最後是福克蘭群島的南跳岩企鵝，這裡是半開放空間，所以味道還蠻重的😂\n午餐在隔壁天保山購物中心的美食街，點了鮭魚親子丼，看了那麼多魚也餓了🤤 然後下午的行程附近的點都沒有買票，加上天氣又非常熱，就跑去卡拉OK避暑唱歌了。 心得 # 整體來說大阪海遊館蠻值得來的，館內動線規劃很好，裡面冷氣非常涼，是夏天避暑的好地方。 整個逛下來大概2-3小時，可以在這邊規劃早上的時間，然後接這邊美食街的午餐行程還蠻推薦的。\n","date":"2024年7月20日","externalUrl":null,"permalink":"/daily-notes/japan-travel/osaka-aquarium/","section":"Daily-Notes","summary":"","title":"大阪 | 海遊館","type":"daily-notes"},{"content":"這次的聯名活動同時有 快閃咖啡廳 \u0026amp; POP UP STORE 分別位在6樓與9樓。\n6樓 快閃咖啡廳 # 平日中午沒什麼人，不用排隊就能入場了。 店員會先跟你確認餐點，入場就直接入座，低消至少要點餐點或飲料， 然後都會送隨機杯墊特典。 點了隊長的義大利麵跟副隊長的飲料，亞白隊長立牌只能拍照，吃完要還給餐廳不能帶走。 味道算是普通吧，畢竟是聯名餐點，沒有抱太大的期待期待😂 特典杯墊拿到Q版的レノ跟キコル。 吃飽後要離開前，才能拍店內的擺設與裝潢。 9樓 POP UP STORE # 6樓咖啡廳吃飽後，就接著去9樓逛。 裡面有等身大小的立牌，還蠻帥的，不過カフカ是變身前的狀態，應該是還沒被發現🤣 還有能製作姓名貼的機器，一次300日幣。 ","date":"2024年7月4日","externalUrl":null,"permalink":"/daily-notes/japan-life/kaiju-no-8-popup-store/","section":"Daily-Notes","summary":"","title":"大阪 | 心齋橋 PARCO 怪獸8號 聯名快閃咖啡廳 \u0026 POP UP STORE","type":"daily-notes"},{"content":"","date":"2024年7月3日","externalUrl":null,"permalink":"/tags/google-analytics/","section":"Tags","summary":"","title":"Google Analytics","type":"tags"},{"content":"","date":"2024年7月3日","externalUrl":null,"permalink":"/tags/google-search-console/","section":"Tags","summary":"","title":"Google Search Console","type":"tags"},{"content":" 前言 # SEO（搜尋引擎優化）對於任何網站來說都是非常重要的，這裡簡單記錄一下 Hugo 網站是如何進行 SEO 優化，以及如何新建 Google Search Console、Google Analytics。讓自己的 GitHub Pages 能在 Google 搜尋結果中被看見，並以 Google Analytics 進行分析。\nHugo 的 SEO 優化 # Meta 標籤優化 # 在 Hugo 中，我們可以通過以下方式優化 meta 標籤： 把網頁 head 標籤中的 meta 訊息設定好，例如 title, description, categories, author, tags 等等。 有任何想新增的欄位，也可以加在 YAML Front Matter 中，如下：\n--- title: \u0026#34;Hugo 網站的 SEO 優化與 Google 分析\u0026#34; date: 2024-07-03T14:36:11+09:00 description: \u0026#34;Hugo 網站的 SEO 優化介紹，以及 Google Search Console 提交，讓自己的 GitHub Pages 能在 google 搜尋結果 被看見，並以 Google Analytics進行分析。\u0026#34; tags: [\u0026#34;SEO\u0026#34;,\u0026#34;hugo\u0026#34;,\u0026#34;Google Search Console\u0026#34;,\u0026#34;Google Analytics\u0026#34;] categories: [\u0026#34;hugo網站架設\u0026#34;] draft: false author: \u0026#34;Eason\u0026#34; slug: hugo-website-seo-optimization --- 結構化資料 # 為文章添加結構化資料，幫助搜尋引擎更好地理解內容。在 Hugo 中，可以在 schema.html 中設定：\n\u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;Article\u0026#34;, \u0026#34;headline\u0026#34;: \u0026#34;{{ .Title }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Description }}\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;{{ .Site.Params.author }}\u0026#34; }, \u0026#34;datePublished\u0026#34;: \u0026#34;{{ .Date.Format \u0026#34;2006-01-02T15:04:05Z07:00\u0026#34; }}\u0026#34;, \u0026#34;dateModified\u0026#34;: \u0026#34;{{ .Lastmod.Format \u0026#34;2006-01-02T15:04:05Z07:00\u0026#34; }}\u0026#34;, \u0026#34;publisher\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Organization\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;{{ .Site.Title }}\u0026#34; } } \u0026lt;/script\u0026gt; 網站地圖 (Sitemap) # Hugo 內建自動生成 sitemap.xml的服務，可以透過修改 hugo.toml 去設置關於 Sitemap 的配置參數：\n# Sitemap 配置 [sitemap] changefreq = \u0026#34;daily\u0026#34; priority = 0.5 filename = \u0026#34;sitemap.xml\u0026#34; [languages] [languages.zh-TW] languageCode = \u0026#34;zh-TW\u0026#34; languageName = \u0026#34;繁體中文\u0026#34; weight = 1 title = \u0026#34;Eason的部落格\u0026#34; contentDir = \u0026#34;content/posts\u0026#34; robots.txt 優化 # 創建或優化 static/robots.txt：\nUser-agent: * Allow: / # 網站地圖 Sitemap: https://yourdomain.com/sitemap.xml # 禁止爬取管理頁面 Disallow: /admin/ Disallow: /private/ Google Search Console # 註冊 Google Search Console # 前往 Google Search Console\n點左上角新增資源，點選「網址前置」，輸入網域。 選擇驗證方式：下載 HTML 檔案 直接將下載下來的 HTML 檔放到 Hugo 網站的 /static 目錄下(根目錄)。 重新部署 Hugo 網站\n等待幾分鐘後，按下驗證，成功會顯示提示如圖。 提交 Sitemap。 # 在 Search Console 的左側選單點選 Sitemap。 添加 sitemap.xml URL：https:/eason0614.github.io/zh-tw/sitemap.xml 提交後，Google 會開始爬取你的網站 剛提交應該會顯示資料處理中，過幾天再回來看成效。 Google Analytics # 前往 Google Analytics\n點擊左上「建立」，新增資源，並填入網址與名稱。 將 Google 代碼 ID 複製下來，貼到 hugo.toml 的 googleAnalytics 參數設定中。 # hugo.toml googleAnalytics = \u0026#34;G-XXXXXXX\u0026#34; 重新部署 Hugo 網站，並回到新增頁面按下測試，成功後就能使用 Google Analytics 的功能了。 總結 # Hugo 網站的本身已有提供一些 SEO 優化的方法，通過這些優化措施，特別是對於使用 Hugo 建立的靜態網站，做好 SEO 優化才能讓你的文章被更多人看見。\n","date":"2024年7月3日","externalUrl":null,"permalink":"/tech-articles/hugo-website/seo/","section":"技術文章","summary":"","title":"Hugo 網站的 SEO 優化與 Google 分析","type":"tech-articles"},{"content":"","date":"2024年7月3日","externalUrl":null,"permalink":"/tags/seo/","section":"Tags","summary":"","title":"SEO","type":"tags"},{"content":" 前言 # 已經成功抵達日本了，記錄一下當初打工度假簽證從申請到入境前的準備！ 為什麼想打工度假？ 從以前就很喜歡日本，主要是想彌補學生時代沒出國留學的遺憾吧！ 人生就這麼一次能申請日本打工度假機會，加上已經出社會工作一段時間了\n年齡也接近30歲(打工度假的年齡限制)，當初抱著申請看看有上就出發的念頭，沒想到就順利申請上了。\n這邊列一下要準備的東西與大概的時程。\n從得知結果到領證，有半年的時間，然後領證後一年內要出發， 結果發表到出發最晚有一年半的時間，所以準備的時間算是滿充裕的。\n時程 事項 約10天 簽證申請 (每年4月、10月各一次，以實際公告為主) 準備項目：赴日簽證申請表、白底彩色證件照1張、護照影本、計畫書、存款證明、台灣身分證影本、履歷書、其他自我推薦之文件影本（非必要） 6 個月 領證時間 (公告結果起算) 準備項目：護照正本、受理領證憑單、保險相關證明 1年 簽證有效時間 (領證後起算) 準備項目：在日租屋、學校申請、傢俱家電、找打工 1. 簽證申請 # 每年公告的時間都不太一樣，不過大概會落在4月、10月。 開放的時間大概10天左右，只有平日工作時間可以去提交申請。 這部分如果有意前往可以提前準備。\n所需要的文件可以到 日台交流協會的網站下載\n赴日簽證申請表 : 照實填寫就行。 白底彩色證件照1張: 要求6個月內的大頭照，實際上不要跟本人差太多就可以。 護照影本 : 黑白複印照片那頁就行，如果履歷書有寫去過日本，建議也附上之前簽證張的那頁。 履歷書 : 照實填寫就行。 計畫書 : 打工度假期間的規劃，寫作文，沒有想法的話交給ChatGPT，內容不要太誇張應該是沒問題。 存款證明 : 到銀行櫃檯申請證明，要有等值8萬台幣以上的存款證明，一張大概50元。 台灣身分證影本 : 黑白複印正反面。 其他自我推薦之文件影本（非必要）: 有通過JLPT檢定可以附上。 上述都準備好就可以挑一天去交流協會提交資料了，現場人員不會幫你檢查資料缺漏，建議要事先檢查好，以免因為資料有缺漏而沒有申請上。\n繳交完資料會給你一張紅色的受理領證憑單，有申請上的話到時要拿這張去領證。 2. 領取簽證 # 等待交流學會發布合格者名單，上了就可以開始準備領證囉！ 後來聽說其實備齊文件都蠻好上的，通過率算是很高的樣子。 從名單上找看看有沒有受理領證憑單上的號碼。\n護照正本 : 要注意不要出發的時候護照不要過期。 受理領證憑單 : 當初提交申請拿到的小紅單。 保險相關證明 : 要有在日期間的保險證明，投保項目必須要包含生病、受傷及死亡，領證的時候承辦人員會看投保項目！若本身已有壽險且這些項目也可以，我就是用壽險證明去領證的，就沒有額外花錢去投保了。 東西都提交檢查通過，就順利拿到簽證啦！承辦人會把簽證貼到你的護照內頁上，上面會標示一年內有效，以領證當天起算。\n3. 出發前準備 # 這部分就看各人的規劃了，如果有租屋或是上語言學校的話，建議是先在台灣先找好，\n打工的話有些代辦會有一些能在台灣先面試的職缺，有的會包含住宿。\n這部分就看每個人的需求了，不過在日本當地找一定是有非常多的選擇！\n在日住處 : 看自己的預算、需求。\n金額：Airbnb \u0026gt; 自己租屋 \u0026gt; Share House 方便性： Airbnb \u0026gt;＝ Share House \u0026gt; 自己租屋 生活機能： 自己租屋 \u0026gt;＝ Airbnb \u0026gt; Share House 如果不想綁在一個地方的話，推薦 Airbnb、Share House，不過這二個建議要問過房東是否能夠在區役所登記地址，國民年金、健保之類的通知繳交信件之後會寄到你登記的地址，之後要搬走前也記得要去區役所辦理遷出。\n綜合考量後，最後決定自己租屋了，地點選在大阪，租金相對東京便宜，去周邊的縣市交通也很方便。\n不過自己租屋的話就會有蠻多手續要處理的，找房仲簽訂契約、添購傢俱(日本租屋都常空屋給你)、自己開通水電瓦斯等。\n語言學校 : 這部分蠻推薦透過代辦去申請的，因為通常代辦是跟學校收取費用的，只要教學費給代辦就可以，省去很多手續流程代辦也會依照你的需求推薦學校， 當然自己找好也可以，當初是直接跟代辦問自己做好功課的學校是否能幫忙申請，大部分的學校代辦都有在合作，他們都知道每間學校的招生狀況。\n打工 ： 我是預計語言學校上一段時間再開始找打工，選擇也比較多，不過缺點是前期可能會比較燒錢，要多備一些存款。\n出發機票 ：主要就是學校上課時間跟住宿入住日期都確定之後，就可以訂機票了，時間大概落在一個月前訂，租屋太早找房仲通常不太會理你 XD\n提款卡國外提款 ：提款卡預設都是不允許國外提款的，預計會在日本提款的話記得事先去辦理國外提款權限的開通。永豐外幣卡在日本每個月有三次免費提款還不錯(公告到2024年底)。\n海外信用卡刷卡 ：建議辦一張JCB的信用卡，在日本有些地方VISA都刷不太過，自己是辦玉山的熊本熊卡，回饋的部分還不錯。\n日幣現金 ： 依照個人需求，可以先換好帶去，但要注意入境不能攜帶超過100萬日圓。通常試算一下大概抓1~2個月的租金與租屋前期費用，這部分通常只能付現，其他部分可以靠刷卡或是 PayPay 解決。\n訂購飯店 ：自己租屋的話，租屋入住時通常是空屋的狀態，看個人之後的時程規劃入境後要住的天數，訂購到實際入住前需要的天數。\n我是中午的飛機，入境當天到大阪都已經接近晚上了，已經規劃好隔天入住跟搬傢俱到租屋處，就只多住了一天飯店。\n購買網卡或eSIM ： 落地沒有網路是非常不方便的，事先購買大概3-7天的網路，時間自己估算一下，日本門號開戶前的過渡期。\n台灣門號轉eSIM ： 因為目前在用的Iphone是實體卡只有單卡插孔，日本的電信都常都是實體卡，為了台灣門號還能接收簡訊，就先去中華電信把實體卡轉eSIM了。\nApp ：乗換案内、Yahoo防災通報，這二個算是我覺得最實用的，可以再找找其他人的推薦，iphone 的話交通卡可以先在 Apple Pay 申請一張，儲值透過刷卡非常方便。\n駕照日文譯本 : 如果有在日本自駕的需求，可以先申請起來。\n結語 # 以上是打工度假從申請到入境前的紀錄啦！在機場入境時也順利提交簽證領到在留卡了！\n","date":"2024年7月1日","externalUrl":null,"permalink":"/daily-notes/japan-life/working-holiday-departure/","section":"Daily-Notes","summary":"","title":"日本打工度假｜從申請到出發前的準備","type":"daily-notes"},{"content":"","date":"2024年6月3日","externalUrl":null,"permalink":"/tags/crontab/","section":"Tags","summary":"","title":"Crontab","type":"tags"},{"content":"","date":"2024年6月3日","externalUrl":null,"permalink":"/tags/macos/","section":"Tags","summary":"","title":"MacOS","type":"tags"},{"content":"","date":"2024年6月3日","externalUrl":null,"permalink":"/categories/macos/","section":"Categories","summary":"","title":"MacOS","type":"categories"},{"content":" 前言 # 本文將紀錄如何在 macOS 上使用 crontab 設定，將已經完成的程式或腳本用 macOC 中的 crontab 實行自動化執行，設定定時任務自動執行。\n前置準備 # 1. 確認 deploy.sh 腳本可執行 # 首先確認你的 deploy.sh 腳本具有執行權限：\nls -la deploy.sh 如果沒有執行權限，請執行：\nchmod +x deploy.sh 2. 測試腳本是否正常運行 # 在設定 crontab 之前，建議先手動執行一次確認腳本可以正常運行：\n./deploy.sh crontab 基本操作 # 1. 查看現有的 crontab 任務 # crontab -l 如果沒有設定過，會顯示 crontab: no crontab for [username]\n2. 編輯 crontab（新增任務） # crontab -e 這會開啟預設的編輯器（通常是 vim 或 nano）\n3. 新增自動部署任務 # 在 crontab 編輯器中，新增以下這一行：\n0 0 * * * /Users/eason/Desktop/project/blog/deploy.sh \u0026gt;\u0026gt; /Users/eason/Desktop/project/blog/deploy.log 2\u0026gt;\u0026amp;1 說明:\n0 0 * * * = 每天晚上 12:00 執行 \u0026gt;\u0026gt; /Users/eason/Desktop/project/blog/deploy.log 2\u0026gt;\u0026amp;1 = 將輸出記錄到 deploy.log 檔案 2\u0026gt;\u0026amp;1 = 將錯誤訊息也導向到同一個日誌檔案 常用的 crontab 時間格式 # # 每天凌晨 2 點 0 2 * * * # 每週日凌晨 3 點 0 3 * * 0 # 每月 1 號凌晨 4 點 0 4 1 * * # 每小時執行 0 * * * * # 每 30 分鐘執行 */30 * * * * # 每週一至週五晚上 11 點 0 23 * * 1-5 如果想要在一天內執行多次，可以設定多個時間點：\n# 每天早上 6 點和晚上 12 點執行 0 6,0 * * * /Users/eason/Desktop/project/blog/deploy.sh \u0026gt;\u0026gt; /Users/eason/Desktop/project/blog/deploy.log 2\u0026gt;\u0026amp;1 管理 crontab 任務 # 1. 檢查 crontab 是否設定成功 # crontab -l 2. 查看執行日誌 # # 查看最新的日誌 tail -f /Users/eason/Desktop/project/blog/deploy.log # 查看所有日誌 cat /Users/eason/Desktop/project/blog/deploy.log 3. 刪除 crontab 任務 # 刪除所有任務：\ncrontab -r 編輯 crontab 手動刪除特定行：\ncrontab -e macOS 權限問題 # macOS 可能會要求你授權 cron 的執行權限，這邊記錄一下解決的方式：\n1. 權限設定 # 前往「系統偏好設定」\u0026gt;「安全性與隱私」 找到選擇「完整磁碟存取權」 解鎖並進入編輯模式 在「完整磁碟存取權」中加入cron，路徑應該會在 /usr/sbin/ 底下： 2. 環境變數 # crontab 執行時的環境變數可能與你的終端機不同。如果遇到路徑問題，可以在 crontab 中設定環境變數：\nPATH=/usr/local/bin:/usr/bin:/bin 0 0 * * * /Users/eason/Desktop/project/blog/deploy.sh \u0026gt;\u0026gt; /Users/eason/Desktop/project/blog/deploy.log 2\u0026gt;\u0026amp;1 結語 # 透過設定 crontab 自動化部署，就省去每次都要手動執行的麻煩。\n不過要記得：\n先測試腳本是否正常運行 注意 macOS 的權限設定 定期去檢查日誌確保都正常執行 確保設定的自動化流程都有如期正常在運行。\n","date":"2024年6月3日","externalUrl":null,"permalink":"/tech-articles/macos/crontab-setup-tutorial/","section":"技術文章","summary":"","title":"macOS 如何設定 crontab","type":"tech-articles"},{"content":"","date":"2024年6月1日","externalUrl":null,"permalink":"/tags/github/","section":"Tags","summary":"","title":"Github","type":"tags"},{"content":" 為什麼選擇 Hugo？ # 相信有在使用 Github 的各位，應該知道 Github Page 這個功能，它可以讓我們免費架設靜態網頁，不過因為是靜態網頁的關係，所以不支援像是登入、資料庫等動態功能，那麼要如何快速建立一個好看又實用的個人部落格呢？這時候 Hugo 這個強大的靜態網站生成器就派上用場了。 Hugo 生成 HTML 的速度非常快，幾秒內就能把 Markdown 跟你使用的 Hugo 主題結合在一起，變成 HTML 網頁，雖然使 Markdown 語法可能要稍微熟悉一下，剛從 Medium 的筆者可能會有些陣痛期，但是如果本身已有網頁開發經驗，相信上手是非常快的。\n快速建立 Hugo # 1. 安裝 Hugo # 依照各作業系統 進行下載\nMacOS：\nbrew install hugo 安裝完成後輸入：\nhugo --version 並且有出現版本訊息，代表安裝成功。\n2. 建立 Hugo 網站 # 到 Hugo主題頁 挑選自己喜歡的主題下載下來。\n# 建立新網站 hugo new site my-blog cd my-blog # 安裝主題（以 Blowfish 為例） git init git submodule add https://github.com/nunocoracao/blowfish.git themes/blowfish 3. 寫第一篇文章 # hugo new posts/hello-world.md 編輯 content/posts/hello-world.md：\n--- title: \u0026#34;Hello World\u0026#34; date: 2024-06-01 draft: false --- 這是我的第一篇文章！ 4. 本地預覽 # hugo server 打開 http://localhost 就能看到你的網站了！\n頁面應該會是套用所安裝 Hugo 主題的文章內容。\n5. 常用指令 # # 文章與頁面相關 hugo new posts/文章標題.md # 建立新文章 hugo new about.md # 建立新頁面 hugo new posts/資料夾/文章.md # 建立子資料夾下的新文章 # 本地開發與預覽 hugo server # 啟動本地伺服器（不含草稿） hugo server -D # 啟動本地伺服器（包含草稿） hugo server --port 1314 # 指定埠號啟動本地伺服器 hugo server --disableFastRender # 停用快取，適合除錯 # 文章發佈與草稿管理 hugo list drafts # 列出所有草稿 hugo undraft content/posts/xxx.md # 取消草稿狀態 # 網站建置 hugo # 建置網站（預設輸出到 public 資料夾） hugo --minify # 建置並壓縮 HTML/CSS/JS hugo -d ./dist # 指定輸出資料夾 # 其他常用指令 hugo version # 查看 Hugo 版本 hugo help # 查看所有指令說明 部署到 Github Pages # 1. 到個人的 Github 主頁，並且在右上角點選「New Repository」 # 2. Repository Name 填寫「使用者名稱.github.io」 # 因為已經有建立過了，所以不允許重複。\n記得要設定為 Public 3. 回推上傳至 Github # 先前在本地端 hugo server 後所需要的靜態檔案會生成到 public/ 的目錄。\n將剛才建立好的 Github Repository Clone 下來 :\ngit clone https://github.com/使用者名稱/使用者名稱.github.io 此時 git 會建立一個資料夾，把 public/ 下的檔案都放到該資料夾內。\n將檔案透過 git指令 回推到 Github 上。\ngit add . \u0026amp;\u0026amp; git commit -m \u0026#34;auto build\u0026#34; \u0026amp;\u0026amp; git push 稍微等待一段時間後，打開 https://使用者名稱.github.io/ 有看到自己的網站就代表成功囉！\n建立自動部署流程 # 每次要更新文章到網站上都需要執行上述步驟，透過 Crontab + Script 可以把上面手動的工作流程自動化。\n1.首先建立一支 deploy.sh 的檔案: # 點擊展開 deploy.sh 腳本內容 #!/usr/bin/env bash # 自動建置 Hugo 靜態站，輸出到目標資料夾，並自動 git commit \u0026amp; push。 # 使用：在專案根目錄執行 `./deploy.sh` # ------------------------------------------- # 設定錯誤處理：遇到錯誤時立即停止執行 set -euo pipefail # 1. 變數設定 # 檢查參數數量 if [ $# -ne 2 ]; then echo \u0026#34;[ERROR] 參數數量錯誤\u0026#34; echo \u0026#34;[ERROR] 使用方式: $0 [專案根目錄] [目標路徑]\u0026#34; echo \u0026#34;[ERROR] 範例: $0 /path/to/blog /path/to/target\u0026#34; exit 1 fi # 兩個參數：提供專案根目錄和目標路徑 BLOG_ROOT=\u0026#34;$1\u0026#34; # 從第一個參數取得專案根目錄 TARGET_DIR=\u0026#34;$2\u0026#34; # 從第二個參數取得目標路徑 echo \u0026#34;[INFO] 開始時間: $(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;)\u0026#34; echo \u0026#34;[INFO] 專案根目錄: $BLOG_ROOT\u0026#34; echo \u0026#34;[INFO] 目標路徑: $TARGET_DIR\u0026#34; # 2. 產生靜態檔 cd \u0026#34;$BLOG_ROOT\u0026#34; echo \u0026#34;[INFO] Building site with Hugo...\u0026#34; /opt/homebrew/bin/hugo --cleanDestinationDir --minify -d \u0026#34;$TARGET_DIR\u0026#34; echo \u0026#34;[INFO] Build finished. Files generated at $TARGET_DIR\u0026#34; # 3. Push 到 GitHub Pages 倉庫 if [ -d \u0026#34;$TARGET_DIR/.git\u0026#34; ]; then cd \u0026#34;$TARGET_DIR\u0026#34; git add -A if git diff --cached --quiet; then echo \u0026#34;[INFO] No changes to commit.\u0026#34; else echo \u0026#34;[INFO] Committing and pushing changes...\u0026#34; git commit -m \u0026#34;auto build\u0026#34; git push fi else echo \u0026#34;[ERROR] $TARGET_DIR 不是一個 Git 倉庫，請先手動初始化 (git init) 並設定遠端。\u0026#34; exit 1 fi echo \u0026#34;[SUCCESS] Deployment completed at $(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;)!\u0026#34; 2.接著測試 deploy.sh 是否能正確執行 # 帶入二個路徑的參數，分別為：\nhugo的專案路徑\n本地端 Github 的目錄 (上面提到 public/ 產生靜態檔放置的地方)\ndeploy.sh \u0026#34;hugo的專案路徑\u0026#34; \u0026#34;本地端 Github 的目錄\u0026#34; 3.設定 crontab # crontab 的詳細設定方式請參考這篇教學。\n打開終端機並輸入\ncrontab -e 將 crontab 設定每天晚上 12 點自動執行 deploy.sh\n＃編輯 crontab -e 0 0 * * * /bin/bash deploy.sh \u0026#34;hugo的專案路徑\u0026#34; \u0026#34;本地端 Github 的目錄\u0026#34; \u0026gt;\u0026gt; deploy.log 2\u0026gt;\u0026amp;1 結語 # 利用 Hugo + Github Pages 是建立個人部落格，只要幾分鐘就能架好網站，熟悉Hugo 語法後，也有很高的彈性能再額外擴展自己想要的 UI 設計 / 擴充功能。\n而且還是免費的！也不用額外再租用主機與購買網域，省去很多時間，剩下的時間可以專注在內容創作上。\n","date":"2024年6月1日","externalUrl":null,"permalink":"/tech-articles/hugo-website/github-page/","section":"技術文章","summary":"","title":"Hugo + Github Page 快速建立自己的部落格網站","type":"tech-articles"},{"content":"","date":"2024年2月3日","externalUrl":null,"permalink":"/tags/fabricjs/","section":"Tags","summary":"","title":"Fabricjs","type":"tags"},{"content":"","date":"2024年2月3日","externalUrl":null,"permalink":"/tags/html2canvas/","section":"Tags","summary":"","title":"Html2canvas","type":"tags"},{"content":" 前言 # 之前在專案上有需要在前端上用 Canvas 開發一些功能，發現了二個好用的工具Html2canvas、Fabricjs。\n在這裡做個紀錄整理一下，安裝參照Github 執行command即可，也可以用CND的方式 Include 進來。\nHtml2canvas 使用 # Html2canvas : 功能如其名，能夠將在定義好的區域內(如div) 渲染成Canvas 的畫布，能夠製作將網頁其中一個區塊截圖下來。\n使用時將 html2canvas 透過 CDN 方式 include 進來\n\u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Fabricjs 使用 # Fabricjs : 能夠在canvas 上實現如拖曳、旋轉和變形等等的互動效果。\n使用時將 Fabricjs 透過 CDN 方式 include 進來\n\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/fabric@6.4.3/dist/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 文字圖片的拖拉移動的範例 # 首先定義一個 Canvas\n\u0026lt;canvas id=\u0026#34;canvas\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; 並在js內設定參數\nconst canvas = new fabric.Canvas(\u0026#39;canvas\u0026#39;, { backgroundColor: \u0026#39;black\u0026#39; // 畫布背景色 }); canvas.setWidth(500); // Width canvas.setHeight(500); // Height 新增三角形圖案至畫布\nconst triangle = new fabric.Triangle({ width: 100, height: 100, fill: \u0026#39;blue\u0026#39;, left: 50, top: 50 }); canvas.add(triangle); 新增文字至畫布\nconst editText = new fabric.IText(\u0026#39;Signature\u0026#39;, { top: 100, left: 250, width: 150, fontSize: 36, // 字體大小 fontWeight: 800, // 字體粗細 fill: \u0026#39;red\u0026#39;, // 字體顏色 fontStyle: \u0026#39;italic\u0026#39;, // 斜體 fontFamily: \u0026#39;Calibri\u0026#39;, // 字型 hasControls: true, borderColor: \u0026#39;white\u0026#39;, editingBorderColor: \u0026#39;blue\u0026#39; }); canvas.add(editText); 新增圖片至畫布\nfabric.Image.fromURL(\u0026#39;https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png\u0026#39;, (img) =\u0026gt; { img.set({ top: 250, left: 50, width: 560, //原圖大小 height: 560, // opacity: 0.85, hasControls: true, borderColor: \u0026#39;orange\u0026#39;, scaleX: 0.3, //放大倍率 scaleY: 0.3 }); canvas.add(img); }); 實際執行效果： See the Pen Fabricjs example by easin0614 (@easin0614) on CodePen. 簡易小畫家範例 # See the Pen Fabricjs example2 by easin0614 (@easin0614) on CodePen. 結語 # 官方也提供其他 Demo 有空可以動手玩看看! ","date":"2024年2月3日","externalUrl":null,"permalink":"/tech-articles/frontend/html2canvas-and-fabricjs/","section":"技術文章","summary":"","title":"Html2canvas + Fabricjs 應用","type":"tech-articles"},{"content":"","date":"2024年2月3日","externalUrl":null,"permalink":"/categories/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC/","section":"Categories","summary":"","title":"前端開發","type":"categories"},{"content":"","date":"2024年1月20日","externalUrl":null,"permalink":"/tags/codepen/","section":"Tags","summary":"","title":"Codepen","type":"tags"},{"content":" 前言 # 之前在 Medium 上直接貼上 Codepen 連結就會直接顯示出來，但是Hugo需要多一些步驟，這裡做個紀錄。\n1. 新增 codepen.html shortcode # 在Hugo的 /layouts/shortcodes/ 目錄下新增 codepen.html 的檔案\ncodepen.html內容如下：\n// codepen.html {{ $height := .Get \u0026#34;height\u0026#34; | default \u0026#34;300\u0026#34; }} {{ $defaultTab := .Get \u0026#34;defaultTab\u0026#34; | default \u0026#34;result\u0026#34; }} {{ $slugHash := .Get \u0026#34;slugHash\u0026#34; }} {{ $penTitle := .Get \u0026#34;penTitle\u0026#34; }} {{ $user := .Get \u0026#34;user\u0026#34; }} \u0026lt;div class=\u0026#34;codepen\u0026#34; data-height=\u0026#34;{{ $height }}\u0026#34; data-default-tab=\u0026#34;{{ $defaultTab }}\u0026#34; data-slug-hash=\u0026#34;{{ $slugHash }}\u0026#34; data-pen-title=\u0026#34;{{ $penTitle }}\u0026#34; data-user=\u0026#34;{{ $user }}\u0026#34; style=\u0026#34;height: {{ $height }}px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;\u0026#34;\u0026gt; \u0026lt;span\u0026gt;See the Pen \u0026lt;a href=\u0026#34;https://codepen.io/{{ $user }}/pen/{{ $slugHash }}\u0026#34;\u0026gt; {{ $penTitle }}\u0026lt;/a\u0026gt; by {{ $user }} (\u0026lt;a href=\u0026#34;https://codepen.io/{{ $user }}\u0026#34;\u0026gt;@{{ $user }}\u0026lt;/a\u0026gt;) on \u0026lt;a href=\u0026#34;https://codepen.io\u0026#34;\u0026gt;CodePen\u0026lt;/a\u0026gt;.\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script async src=\u0026#34;https://public.codepenassets.com/embed/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 2. 到 codepen 作品頁面取得 ID # 打開你想要嵌入文章的 codepen 作品畫面，點擊右下角 Embed 按鈕， 然後將 HTML Code 中的 ID 等資訊複製起來。\n在 Hugo 中 的 markdown 文章中嵌入以下代碼，並將 ID 等資訊帶入。\n// 複製後將 { { 中間的空格拿掉，才會正確被Hugo轉譯 { {\u0026lt; codepen height=\u0026#34;500\u0026#34; defaultTab=\u0026#34;result\u0026#34; slugHash=\u0026#34;NWymLWP\u0026#34; penTitle=\u0026#34;Fabricjs example2\u0026#34; user=\u0026#34;easin0614\u0026#34; \u0026gt;} } 成功會 會看到文章的 CodePen 呈現結果如下： See the Pen Fabricjs example2 by easin0614 (@easin0614) on CodePen. ","date":"2024年1月20日","externalUrl":null,"permalink":"/tech-articles/hugo-website/use-codepen/","section":"技術文章","summary":"","title":"把 Codepen 嵌入 Hugo文章上","type":"tech-articles"},{"content":"","date":"2024年1月3日","externalUrl":null,"permalink":"/tags/browser/","section":"Tags","summary":"","title":"Browser","type":"tags"},{"content":" 前言 # 在開發網頁日常，常會去搜尋語法來實現自己想要的某個功能，但很多時候查到的文件或技術文章沒告訴你，這個語法在各個瀏覽器的相容性。\n在 Chrome 上能成功執行，就很開心地繼續開發下去了，結果到最後系統要上線前，瀏覽器測試才發現 IE 執行有問題，就要再花時間回去改 code …\n什麼是 Can I use？ # Can I use 是一個專門用來查詢各種前端技術（HTML、CSS、JavaScript API 等）在不同瀏覽器上的支援度的網站。\n它會用圖表的方式，清楚地顯示各大主流瀏覽器（Chrome、Firefox、Safari、Edge、IE…）對於某個語法或功能的支援狀況。\n為什麼要用 Can I use？ # 避免踩雷：有些新語法或新功能，並不是所有瀏覽器都支援，直接用在專案裡可能會造成部分用戶無法正常瀏覽。 快速查詢：不用再自己去查官方文件或測試，直接輸入關鍵字就能看到支援狀況。 支援度一目了然：用顏色區分支援（綠色）、不支援（紅色）、部分支援（黃色），非常直觀。 如何使用 Can I use？ # 進入網站\n打開 https://caniuse.com/\n輸入你想查詢的語法或功能\n例如：include、grid、fetch等。 支援度圖表\n綠色：完全支援 黃色：部分支援或有 bug 紅色：不支援 灰色：不知道 查看結果\n搜尋結果有更詳細的說明、各瀏覽器版本的支援狀況、已知問題、參考連結等。 每個版本瀏覽器有 released 的時間，以及 user 使用的比例，useage的資料來源為 StatCounter\n再來看 CSS 的 Grid Layout，這邊會列出在IE 10、11 使用要加上的前綴詞。 結語 # 在開發時要用上查到的語法，不妨先花個幾秒鐘在這個網站查查相容性吧!\n","date":"2024年1月3日","externalUrl":null,"permalink":"/tech-articles/frontend/can-i-use/","section":"技術文章","summary":"","title":"使用Can I Use 檢查瀏覽器相容性","type":"tech-articles"},{"content":"","externalUrl":null,"permalink":"/ja/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/ja/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/ja/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/ja/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]